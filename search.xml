<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Less 嵌套</title>
      <link href="/2022/05/08/Less%20%E5%B5%8C%E5%A5%97/"/>
      <url>/2022/05/08/Less%20%E5%B5%8C%E5%A5%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Less-嵌套"><a href="#Less-嵌套" class="headerlink" title="Less 嵌套"></a>Less 嵌套</h1><p>Less 中的嵌套规则允许在一个<strong>选择器</strong>中嵌套另一个选择器，这样可以使得代码看起来一目了然，后期维护也方便。</p><h2 id="嵌套的使用"><a href="#嵌套的使用" class="headerlink" title="嵌套的使用"></a>嵌套的使用</h2><p>例如上面的 CSS 代码使用 Less 语言来写：</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.title-box</span>&#123;</span><br><span class="line">   <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">   <span class="selector-tag">p</span>&#123;</span><br><span class="line">      <span class="attribute">line-height</span>: <span class="number">25px</span>;</span><br><span class="line">      <span class="selector-tag">span</span>&#123;</span><br><span class="line">         <span class="attribute">color</span>: <span class="number">#ccc</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样整体看起来是不是更直观一些，一层套一层。但是注意哟，一般我们不会嵌套太多层，嵌套的层数越多，性能就越差，建议一般嵌套三层左右。</p><h2 id="amp-符号的使用"><a href="#amp-符号的使用" class="headerlink" title="&amp;符号的使用"></a>&amp;符号的使用</h2><p>在我们使用嵌套规则时，要特别注意 <code>&amp;</code> 符号的使用，<code>&amp;</code> 符号可以表示对父选择器的引用。</p><p>在一个内层选择器的前面，如果没有 <code>&amp;</code> 符号，则这个内层选择器会被解析为父选择器的后代。如果内层选择器前面有一个 <code>&amp;</code> 符号，则内层选择器会被解析为父选择器自身或父选择器的伪类。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>例如我们看下面这段代码：</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.task-item</span> &#123;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="selector-class">.task-item__container</span> &#123;</span><br><span class="line">      <span class="attribute">overflow</span>: auto;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">      <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">10px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="编译成-CSS-代码："><a href="#编译成-CSS-代码：" class="headerlink" title="编译成 CSS 代码："></a>编译成 CSS 代码：</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.task-item</span>&#123;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.task-item</span> task-item__container &#123;</span><br><span class="line">   <span class="attribute">overflow</span>: auto;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">   <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，标签选择器 <code>a</code> 前面没有加 <code>&amp;</code> 符号，所以这个标签选择器 <code>a</code> 被解析为 <code>.xkd</code> 选择器的后代。</p><h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><p>再来看一下内层选择器前面加 <code>&amp;</code> 符号：</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.task-item</span> &#123;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-tag">__container</span> &#123;</span><br><span class="line">      <span class="attribute">overflow</span>: auto;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">      <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">10px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">800px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译成-CSS-代码：-1"><a href="#编译成-CSS-代码：-1" class="headerlink" title="编译成 CSS 代码："></a>编译成 CSS 代码：</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.task-item</span> &#123;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.task-item__container</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: auto;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line">task-item<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">800px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>__container</code> 前面添加了一个 <code>&amp;</code> 符号，这个符号就表示父选择器本身，所以解析后为<code>.task-item__container</code>。当然 <code>:hover</code> 伪类前面的 <code>&amp;</code> 符号也是同理。</p><h2 id="重复引用父选择器"><a href="#重复引用父选择器" class="headerlink" title="重复引用父选择器"></a>重复引用父选择器</h2><p>通过使用 <code>&amp;</code> 符号，可以重复引用父类选择器。</p><h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><p>例如下面这段 Less 代码，如果我们希望每个选择器名的前缀都为 <code>task-item</code>，可以像下面这样简写：</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.task-item</span>&#123;</span><br><span class="line">   <span class="selector-tag">&amp;</span><span class="selector-tag">-one</span>&#123;</span><br><span class="line">       <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="selector-tag">&amp;</span><span class="selector-tag">-two</span>&#123;</span><br><span class="line">       <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="selector-tag">&amp;</span><span class="selector-tag">-three</span>&#123;</span><br><span class="line">       <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译为-CSS-代码："><a href="#编译为-CSS-代码：" class="headerlink" title="编译为 CSS 代码："></a>编译为 CSS 代码：</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.task-item-one</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.task-item-two</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.task-item-three</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，还可以同时使用多个 <code>&amp;</code> 符号，并使用其他运算符连接起来：</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">   <span class="selector-tag">&amp;</span><span class="selector-tag">&amp;</span><span class="selector-tag">-one</span>&#123;</span><br><span class="line">       <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="selector-tag">&amp;</span>, <span class="selector-tag">&amp;</span><span class="selector-tag">-two</span>&#123;</span><br><span class="line">       <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="selector-tag">&amp;</span>, <span class="selector-tag">&amp;</span><span class="selector-tag">er</span>&#123;</span><br><span class="line">       <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">1234567891011</span></span><br></pre></td></tr></table></figure><h4 id="编译为-CSS-代码：-1"><a href="#编译为-CSS-代码：-1" class="headerlink" title="编译为 CSS 代码："></a>编译为 CSS 代码：</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span><span class="selector-class">.item-one</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span>,</span><br><span class="line"><span class="selector-class">.item-two</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span>,</span><br><span class="line"><span class="selector-class">.itemer</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更改选择器顺序"><a href="#更改选择器顺序" class="headerlink" title="更改选择器顺序"></a>更改选择器顺序</h2><p>什么是更改选择器顺序呢，就是有些时候可能需要将内层选择器放在父选择器之前，此时我们可以将 <code>&amp;</code> 放在当前选择器后面来完成。</p><h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><p>例如下面这段代码，我们希望 <code>.item</code> 选择器位于 <code>.nav</code> 选择器之前，可以在 <code>.item</code> 选择器的后面加一个 <code>&amp;</code> 符号：</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.nav</span>&#123;</span><br><span class="line">   <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">   <span class="selector-class">.item</span> <span class="selector-tag">&amp;</span>&#123;</span><br><span class="line">     <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译为-CSS-代码：-2"><a href="#编译为-CSS-代码：-2" class="headerlink" title="编译为 CSS 代码："></a>编译为 CSS 代码：</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.nav</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item</span> <span class="selector-class">.nav</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，编译之后的 CSS 代码中 <code>.item</code> 选择器位于 <code>.nav</code> 选择器前面。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> css </category>
          
          <category> Less </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Less </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>antd日历组件的RangePicker使用问题</title>
      <link href="/2022/05/01/antd%E6%97%A5%E5%8E%86%E7%BB%84%E4%BB%B6%E7%9A%84RangePicker%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2022/05/01/antd%E6%97%A5%E5%8E%86%E7%BB%84%E4%BB%B6%E7%9A%84RangePicker%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="antd日历组件的RangePicker使用问题"><a href="#antd日历组件的RangePicker使用问题" class="headerlink" title="antd日历组件的RangePicker使用问题"></a>antd日历组件的RangePicker使用问题</h1><h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><p><strong>antd和react在四月份升级后出现问题</strong></p><blockquote><p>‘DatePicker.RangePicker’ cannot be used as a JSX component.</p></blockquote><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>const RangePicker:<em>any</em>= DatePicker.RangePicker;//写上<em>any</em>会是正确的</p><p>//const {RangePicker}=DatePicker 这种是错误的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; DatePicker &#125; from &#x27;antd&#x27;;</span><br><span class="line"></span><br><span class="line">const RangePicker:any= DatePicker.RangePicker;</span><br><span class="line">export default function TaskList() &#123;</span><br><span class="line">  </span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;task-list&quot;&gt;</span><br><span class="line">      &lt;RangePicker renderExtraFooter=&#123;() =&gt; &#x27;extra footer&#x27;&#125; showTime /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> react </category>
          
          <category> antd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> antd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java·JVM·JUC(六)</title>
      <link href="/2022/04/25/Java%C2%B7JVM%C2%B7JUC(%E5%85%AD)/"/>
      <url>/2022/04/25/Java%C2%B7JVM%C2%B7JUC(%E5%85%AD)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Java·JVM·JUC-六"><a href="#Java·JVM·JUC-六" class="headerlink" title="Java·JVM·JUC(六)"></a>Java·JVM·JUC(六)</h1><h2 id="CAS-实现原理是什么？"><a href="#CAS-实现原理是什么？" class="headerlink" title="CAS 实现原理是什么？"></a>CAS 实现原理是什么？</h2><h2 id="JVM-是怎么去调优的？了解哪些参数和指令？"><a href="#JVM-是怎么去调优的？了解哪些参数和指令？" class="headerlink" title="JVM 是怎么去调优的？了解哪些参数和指令？"></a>JVM 是怎么去调优的？了解哪些参数和指令？</h2><h2 id="简述-Netty-线程模型，Netty-为什么如此高效？"><a href="#简述-Netty-线程模型，Netty-为什么如此高效？" class="headerlink" title="简述 Netty 线程模型，Netty 为什么如此高效？"></a>简述 Netty 线程模型，Netty 为什么如此高效？</h2><h2 id="什么是-Java-泛型，有什么作用？"><a href="#什么是-Java-泛型，有什么作用？" class="headerlink" title="什么是 Java 泛型，有什么作用？"></a>什么是 Java 泛型，有什么作用？</h2><h2 id="JAVA-创建多线程的方法有哪些？"><a href="#JAVA-创建多线程的方法有哪些？" class="headerlink" title="JAVA 创建多线程的方法有哪些？"></a>JAVA 创建多线程的方法有哪些？</h2><h2 id="如何解决-Spring-的循环依赖问题？"><a href="#如何解决-Spring-的循环依赖问题？" class="headerlink" title="如何解决 Spring 的循环依赖问题？"></a>如何解决 Spring 的循环依赖问题？</h2><h2 id="简述-Synchronized，volatile，可重入锁的不同使用场景及优缺点"><a href="#简述-Synchronized，volatile，可重入锁的不同使用场景及优缺点" class="headerlink" title="简述 Synchronized，volatile，可重入锁的不同使用场景及优缺点"></a>简述 Synchronized，volatile，可重入锁的不同使用场景及优缺点</h2><h2 id="如何优化-JVM-频繁-minor-GC"><a href="#如何优化-JVM-频繁-minor-GC" class="headerlink" title="如何优化 JVM 频繁 minor GC"></a>如何优化 JVM 频繁 minor GC</h2><h2 id="简述-Spring-的-IOC-机制"><a href="#简述-Spring-的-IOC-机制" class="headerlink" title="简述 Spring 的 IOC 机制"></a>简述 Spring 的 IOC 机制</h2><h2 id="简述-Dubbo-服务调用过程"><a href="#简述-Dubbo-服务调用过程" class="headerlink" title="简述 Dubbo 服务调用过程"></a>简述 Dubbo 服务调用过程</h2><h2 id="简述并实现工厂模式，工厂模式有什么常见问题？"><a href="#简述并实现工厂模式，工厂模式有什么常见问题？" class="headerlink" title="简述并实现工厂模式，工厂模式有什么常见问题？"></a>简述并实现工厂模式，工厂模式有什么常见问题？</h2><h2 id="产生死锁的必要条件有哪些？如何解决死锁？"><a href="#产生死锁的必要条件有哪些？如何解决死锁？" class="headerlink" title="产生死锁的必要条件有哪些？如何解决死锁？"></a>产生死锁的必要条件有哪些？如何解决死锁？</h2><h2 id="String-为什么是-final-类型？"><a href="#String-为什么是-final-类型？" class="headerlink" title="String 为什么是 final 类型？"></a>String 为什么是 final 类型？</h2><h2 id="如何设计-Java-的异常体系？"><a href="#如何设计-Java-的异常体系？" class="headerlink" title="如何设计 Java 的异常体系？"></a>如何设计 Java 的异常体系？</h2><h2 id="常用的排序方式有哪些，时间复杂度是多少？"><a href="#常用的排序方式有哪些，时间复杂度是多少？" class="headerlink" title="常用的排序方式有哪些，时间复杂度是多少？"></a>常用的排序方式有哪些，时间复杂度是多少？</h2><h2 id="简述装饰者模式以及适配器模式"><a href="#简述装饰者模式以及适配器模式" class="headerlink" title="简述装饰者模式以及适配器模式"></a>简述装饰者模式以及适配器模式</h2><h2 id="简述-HashMap-和-TreeMap-的实现原理以及常见操作的时间复杂度"><a href="#简述-HashMap-和-TreeMap-的实现原理以及常见操作的时间复杂度" class="headerlink" title="简述 HashMap 和 TreeMap 的实现原理以及常见操作的时间复杂度"></a>简述 HashMap 和 TreeMap 的实现原理以及常见操作的时间复杂度</h2><h2 id="如何设计一个线程池"><a href="#如何设计一个线程池" class="headerlink" title="如何设计一个线程池"></a>如何设计一个线程池</h2><h2 id="Java-线程间有多少通信方式？"><a href="#Java-线程间有多少通信方式？" class="headerlink" title="Java 线程间有多少通信方式？"></a>Java 线程间有多少通信方式？</h2><h2 id="简述-Java-中-final-关键字的作用"><a href="#简述-Java-中-final-关键字的作用" class="headerlink" title="简述 Java 中 final 关键字的作用"></a>简述 Java 中 final 关键字的作用</h2><h2 id="手写生产者消费者模型"><a href="#手写生产者消费者模型" class="headerlink" title="手写生产者消费者模型"></a>手写生产者消费者模型</h2><h2 id="简述-HashSet-与-HashMap-的异同"><a href="#简述-HashSet-与-HashMap-的异同" class="headerlink" title="简述 HashSet 与 HashMap 的异同"></a>简述 HashSet 与 HashMap 的异同</h2><h2 id="深拷贝与浅拷贝区别是什么？"><a href="#深拷贝与浅拷贝区别是什么？" class="headerlink" title="深拷贝与浅拷贝区别是什么？"></a>深拷贝与浅拷贝区别是什么？</h2><h2 id="简述-Spring-的初始化流程"><a href="#简述-Spring-的初始化流程" class="headerlink" title="简述 Spring 的初始化流程"></a>简述 Spring 的初始化流程</h2><h2 id="Java-缓冲流-buffer-的用途和原理是什么？"><a href="#Java-缓冲流-buffer-的用途和原理是什么？" class="headerlink" title="Java 缓冲流 buffer 的用途和原理是什么？"></a>Java 缓冲流 buffer 的用途和原理是什么？</h2><h2 id="简述-Java-内置排序算法的实现原理"><a href="#简述-Java-内置排序算法的实现原理" class="headerlink" title="简述 Java 内置排序算法的实现原理"></a>简述 Java 内置排序算法的实现原理</h2><h2 id="HTTP-中-GET-和-POST-区别"><a href="#HTTP-中-GET-和-POST-区别" class="headerlink" title="HTTP 中 GET 和 POST 区别"></a>HTTP 中 GET 和 POST 区别</h2><h2 id="JDK-1-8有什么新特性？"><a href="#JDK-1-8有什么新特性？" class="headerlink" title="JDK 1.8有什么新特性？"></a>JDK 1.8有什么新特性？</h2><h2 id="有哪些解决哈希表冲突的方式？"><a href="#有哪些解决哈希表冲突的方式？" class="headerlink" title="有哪些解决哈希表冲突的方式？"></a>有哪些解决哈希表冲突的方式？</h2><h2 id="简述-Zookeeper-基础原理以及使用场景"><a href="#简述-Zookeeper-基础原理以及使用场景" class="headerlink" title="简述 Zookeeper 基础原理以及使用场景"></a>简述 Zookeeper 基础原理以及使用场景</h2><h2 id="简述标记清除算法的流程"><a href="#简述标记清除算法的流程" class="headerlink" title="简述标记清除算法的流程"></a>简述标记清除算法的流程</h2><h2 id="简述-SortedSet-实现原理"><a href="#简述-SortedSet-实现原理" class="headerlink" title="简述 SortedSet 实现原理"></a>简述 SortedSet 实现原理</h2><h2 id="Java-有几种基本数据类型，分别占多少字节？"><a href="#Java-有几种基本数据类型，分别占多少字节？" class="headerlink" title="Java 有几种基本数据类型，分别占多少字节？"></a>Java 有几种基本数据类型，分别占多少字节？</h2><h2 id="简述-HashSet-实现原理"><a href="#简述-HashSet-实现原理" class="headerlink" title="简述 HashSet 实现原理"></a>简述 HashSet 实现原理</h2><h2 id="数组与链表有什么区别？"><a href="#数组与链表有什么区别？" class="headerlink" title="数组与链表有什么区别？"></a>数组与链表有什么区别？</h2><h2 id="简述偏向锁以及轻量级锁的区别"><a href="#简述偏向锁以及轻量级锁的区别" class="headerlink" title="简述偏向锁以及轻量级锁的区别"></a>简述偏向锁以及轻量级锁的区别</h2><h2 id="如何回收循环依赖的对象"><a href="#如何回收循环依赖的对象" class="headerlink" title="如何回收循环依赖的对象"></a>如何回收循环依赖的对象</h2><h2 id="Linux-实现虚拟内存有什么方式？"><a href="#Linux-实现虚拟内存有什么方式？" class="headerlink" title="Linux 实现虚拟内存有什么方式？"></a>Linux 实现虚拟内存有什么方式？</h2><h2 id="简述-Java-的序列化和使用场景"><a href="#简述-Java-的序列化和使用场景" class="headerlink" title="简述 Java 的序列化和使用场景"></a>简述 Java 的序列化和使用场景</h2><h2 id="String-为什么是-final？"><a href="#String-为什么是-final？" class="headerlink" title="String 为什么是 final？"></a>String 为什么是 final？</h2><h2 id="Java-多线程有几种实现方式"><a href="#Java-多线程有几种实现方式" class="headerlink" title="Java 多线程有几种实现方式"></a>Java 多线程有几种实现方式</h2><h2 id="如何确定-eden-区的对象何时进入老年代？"><a href="#如何确定-eden-区的对象何时进入老年代？" class="headerlink" title="如何确定 eden 区的对象何时进入老年代？"></a>如何确定 eden 区的对象何时进入老年代？</h2><h2 id="Spring-MVC-如何处理一个请求？"><a href="#Spring-MVC-如何处理一个请求？" class="headerlink" title="Spring MVC 如何处理一个请求？"></a>Spring MVC 如何处理一个请求？</h2><h2 id="Java-中-arrayblockingqueue-与-linkedblockingqueue-的用途和区别"><a href="#Java-中-arrayblockingqueue-与-linkedblockingqueue-的用途和区别" class="headerlink" title="Java 中 arrayblockingqueue 与 linkedblockingqueue 的用途和区别"></a>Java 中 arrayblockingqueue 与 linkedblockingqueue 的用途和区别</h2><h2 id="简述-Java-的-happen-before-原则"><a href="#简述-Java-的-happen-before-原则" class="headerlink" title="简述 Java 的 happen before 原则"></a>简述 Java 的 happen before 原则</h2><h2 id="SpringBoot-是如何进行自动配置的？"><a href="#SpringBoot-是如何进行自动配置的？" class="headerlink" title="SpringBoot 是如何进行自动配置的？"></a>SpringBoot 是如何进行自动配置的？</h2><h2 id="如何判断一个-Hash-函数好不好？"><a href="#如何判断一个-Hash-函数好不好？" class="headerlink" title="如何判断一个 Hash 函数好不好？"></a>如何判断一个 Hash 函数好不好？</h2><h2 id="简述使用协程的优点"><a href="#简述使用协程的优点" class="headerlink" title="简述使用协程的优点"></a>简述使用协程的优点</h2><h2 id="error-和-exception-的区别是什么？"><a href="#error-和-exception-的区别是什么？" class="headerlink" title="error 和 exception 的区别是什么？"></a>error 和 exception 的区别是什么？</h2><h2 id="简述生产者消费者模型"><a href="#简述生产者消费者模型" class="headerlink" title="简述生产者消费者模型"></a>简述生产者消费者模型</h2><h2 id="JVM-是怎么去调优的？简述过程和调优的结果"><a href="#JVM-是怎么去调优的？简述过程和调优的结果" class="headerlink" title="JVM 是怎么去调优的？简述过程和调优的结果"></a>JVM 是怎么去调优的？简述过程和调优的结果</h2><h2 id="简述读写屏障底层原理"><a href="#简述读写屏障底层原理" class="headerlink" title="简述读写屏障底层原理"></a>简述读写屏障底层原理</h2><h2 id="什么是堆内存异常？"><a href="#什么是堆内存异常？" class="headerlink" title="什么是堆内存异常？"></a>什么是堆内存异常？</h2><h2 id="简述有哪些同步锁以及它们的实现原理"><a href="#简述有哪些同步锁以及它们的实现原理" class="headerlink" title="简述有哪些同步锁以及它们的实现原理"></a>简述有哪些同步锁以及它们的实现原理</h2><h2 id="什么是-Spring-容器，有什么作用？"><a href="#什么是-Spring-容器，有什么作用？" class="headerlink" title="什么是 Spring 容器，有什么作用？"></a>什么是 Spring 容器，有什么作用？</h2><h2 id="如何设计一个无锁队列"><a href="#如何设计一个无锁队列" class="headerlink" title="如何设计一个无锁队列"></a>如何设计一个无锁队列</h2><h2 id="如何停止一个线程？"><a href="#如何停止一个线程？" class="headerlink" title="如何停止一个线程？"></a>如何停止一个线程？</h2><h2 id="在一个静态方法内调用一个非静态成员为什么是非法的？"><a href="#在一个静态方法内调用一个非静态成员为什么是非法的？" class="headerlink" title="在一个静态方法内调用一个非静态成员为什么是非法的？"></a>在一个静态方法内调用一个非静态成员为什么是非法的？</h2><h2 id="Spring-是怎么解析-JSON-数据的？"><a href="#Spring-是怎么解析-JSON-数据的？" class="headerlink" title="Spring 是怎么解析 JSON 数据的？"></a>Spring 是怎么解析 JSON 数据的？</h2><h2 id="Java-如何高效进行数组拷贝"><a href="#Java-如何高效进行数组拷贝" class="headerlink" title="Java 如何高效进行数组拷贝"></a>Java 如何高效进行数组拷贝</h2><h2 id="成员变量和方法的区别？"><a href="#成员变量和方法的区别？" class="headerlink" title="成员变量和方法的区别？"></a>成员变量和方法的区别？</h2><h2 id="阻塞队列都有哪几种，有什么区别？"><a href="#阻塞队列都有哪几种，有什么区别？" class="headerlink" title="阻塞队列都有哪几种，有什么区别？"></a>阻塞队列都有哪几种，有什么区别？</h2><h2 id="Java-中如何进行-GC-调优？"><a href="#Java-中如何进行-GC-调优？" class="headerlink" title="Java 中如何进行 GC 调优？"></a>Java 中如何进行 GC 调优？</h2><h2 id="MVC-模型和-MVVM-模型的区别"><a href="#MVC-模型和-MVVM-模型的区别" class="headerlink" title="MVC 模型和 MVVM 模型的区别"></a>MVC 模型和 MVVM 模型的区别</h2><h2 id="Cookie-和-Session-的关系和区别是什么？"><a href="#Cookie-和-Session-的关系和区别是什么？" class="headerlink" title="Cookie 和 Session 的关系和区别是什么？"></a>Cookie 和 Session 的关系和区别是什么？</h2><h2 id="简述-Java-的逃逸分析机制"><a href="#简述-Java-的逃逸分析机制" class="headerlink" title="简述 Java 的逃逸分析机制"></a>简述 Java 的逃逸分析机制</h2><h2 id="new-Integer-和-Integer-valueOf-的区别是什么？"><a href="#new-Integer-和-Integer-valueOf-的区别是什么？" class="headerlink" title="new Integer 和 Integer.valueOf 的区别是什么？"></a>new Integer 和 Integer.valueOf 的区别是什么？</h2><h2 id="简述-Java-中的自动装箱与拆箱"><a href="#简述-Java-中的自动装箱与拆箱" class="headerlink" title="简述 Java 中的自动装箱与拆箱"></a>简述 Java 中的自动装箱与拆箱</h2><h2 id="简单介绍-MyBatis，MyBatis-是如何实现-ORM-映射的"><a href="#简单介绍-MyBatis，MyBatis-是如何实现-ORM-映射的" class="headerlink" title="简单介绍 MyBatis，MyBatis 是如何实现 ORM 映射的"></a>简单介绍 MyBatis，MyBatis 是如何实现 ORM 映射的</h2><h2 id="简述-Web-socket-与-HTTP-的使用场景"><a href="#简述-Web-socket-与-HTTP-的使用场景" class="headerlink" title="简述 Web socket 与 HTTP 的使用场景"></a>简述 Web socket 与 HTTP 的使用场景</h2><p>由于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用 中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。</p><p>而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。</p><p>很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数据传送给 客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以 保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。</p><h2 id="Java-编译后的-class-文件包含了什么内容？"><a href="#Java-编译后的-class-文件包含了什么内容？" class="headerlink" title="Java 编译后的 .class 文件包含了什么内容？"></a>Java 编译后的 .class 文件包含了什么内容？</h2><p>一、类信息</p><p>一部分是描述类的信息，包括类的名字、修饰符(public或private)、父类、接口以及注解(annotation)。</p><p>二、变量信息</p><p>一部分是描述类变量的信息，包括每个变量的名字、修饰符、类型和注解(annotation)。</p><p>三、方法信息</p><p>一部分是描述类方法的信息，包括每个方法的名字、修饰符、参数的类型和返回值的类型、方法的注解(annotation)，还包括编译后的、字节码形式的方法代码。</p><h2 id="Java-中-int-的最大值是多少？"><a href="#Java-中-int-的最大值是多少？" class="headerlink" title="Java 中 int 的最大值是多少？"></a>Java 中 int 的最大值是多少？</h2><p>java int 类整数的最大值是 2 的 31 次方 - 1 = <strong>2147483648 - 1</strong> = <strong>2147483647</strong></p><p>可以用 <strong>Integer.MAX_VALUE</strong> 表示它，即 int value = Integer.MAX_VALUE;</p><p>Integer.MAX_VALUE + 1 = Integer.MIN_VALUE = <strong>-2147483648</strong></p><h2 id="简述封装、继承、多态的特性及使用场景"><a href="#简述封装、继承、多态的特性及使用场景" class="headerlink" title="简述封装、继承、多态的特性及使用场景"></a>简述封装、继承、多态的特性及使用场景</h2><h5 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h5><ul><li>封装的意义在于保护或者防止代码（数据）被我们无意中破坏。</li><li>保护成员属性，不让类以外的程序直接访问和修改；</li><li>隐藏方法细节</li></ul><h5 id="继承的意义"><a href="#继承的意义" class="headerlink" title="继承的意义"></a>继承的意义</h5><p>主要实现重用代码，节省开发时间。</p><p><strong>多态的三个条件:</strong></p><ol><li>继承的存在(继承是多态的基础,没有继承就没有多态).</li><li>子类重写父类的方法(多态下调用子类重写的方法).</li><li>父类引用变量指向子类对象(子类到父类的类型转换).</li></ol><h5 id="实现多态方式"><a href="#实现多态方式" class="headerlink" title="实现多态方式"></a>实现多态方式</h5><ol><li>接口多态性。</li><li>继承多态性。</li><li>通过抽象类实现的多态性。</li></ol><p>题目答案均为转载，题目先后顺序按各大厂总出题次数排列！</p>]]></content>
      
      
      <categories>
          
          <category> 面试技巧 </category>
          
          <category> Java·JVM·JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java·JVM·JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java·JVM·JUC(六)</title>
      <link href="/2022/04/20/Java%C2%B7JVM%C2%B7JUC(%E5%85%AD)%20/"/>
      <url>/2022/04/20/Java%C2%B7JVM%C2%B7JUC(%E5%85%AD)%20/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Java·JVM·JUC-六"><a href="#Java·JVM·JUC-六" class="headerlink" title="Java·JVM·JUC(六)"></a>Java·JVM·JUC(六)</h1><h2 id="CAS-实现原理是什么？"><a href="#CAS-实现原理是什么？" class="headerlink" title="CAS 实现原理是什么？"></a>CAS 实现原理是什么？</h2><h2 id="JVM-是怎么去调优的？了解哪些参数和指令？"><a href="#JVM-是怎么去调优的？了解哪些参数和指令？" class="headerlink" title="JVM 是怎么去调优的？了解哪些参数和指令？"></a>JVM 是怎么去调优的？了解哪些参数和指令？</h2><h2 id="简述-Netty-线程模型，Netty-为什么如此高效？"><a href="#简述-Netty-线程模型，Netty-为什么如此高效？" class="headerlink" title="简述 Netty 线程模型，Netty 为什么如此高效？"></a>简述 Netty 线程模型，Netty 为什么如此高效？</h2><h2 id="什么是-Java-泛型，有什么作用？"><a href="#什么是-Java-泛型，有什么作用？" class="headerlink" title="什么是 Java 泛型，有什么作用？"></a>什么是 Java 泛型，有什么作用？</h2><h2 id="JAVA-创建多线程的方法有哪些？"><a href="#JAVA-创建多线程的方法有哪些？" class="headerlink" title="JAVA 创建多线程的方法有哪些？"></a>JAVA 创建多线程的方法有哪些？</h2><h2 id="如何解决-Spring-的循环依赖问题？"><a href="#如何解决-Spring-的循环依赖问题？" class="headerlink" title="如何解决 Spring 的循环依赖问题？"></a>如何解决 Spring 的循环依赖问题？</h2><h2 id="简述-Synchronized，volatile，可重入锁的不同使用场景及优缺点"><a href="#简述-Synchronized，volatile，可重入锁的不同使用场景及优缺点" class="headerlink" title="简述 Synchronized，volatile，可重入锁的不同使用场景及优缺点"></a>简述 Synchronized，volatile，可重入锁的不同使用场景及优缺点</h2><h2 id="如何优化-JVM-频繁-minor-GC"><a href="#如何优化-JVM-频繁-minor-GC" class="headerlink" title="如何优化 JVM 频繁 minor GC"></a>如何优化 JVM 频繁 minor GC</h2><h2 id="简述-Spring-的-IOC-机制"><a href="#简述-Spring-的-IOC-机制" class="headerlink" title="简述 Spring 的 IOC 机制"></a>简述 Spring 的 IOC 机制</h2><h2 id="简述-Dubbo-服务调用过程"><a href="#简述-Dubbo-服务调用过程" class="headerlink" title="简述 Dubbo 服务调用过程"></a>简述 Dubbo 服务调用过程</h2><h2 id="简述并实现工厂模式，工厂模式有什么常见问题？"><a href="#简述并实现工厂模式，工厂模式有什么常见问题？" class="headerlink" title="简述并实现工厂模式，工厂模式有什么常见问题？"></a>简述并实现工厂模式，工厂模式有什么常见问题？</h2><h2 id="产生死锁的必要条件有哪些？如何解决死锁？"><a href="#产生死锁的必要条件有哪些？如何解决死锁？" class="headerlink" title="产生死锁的必要条件有哪些？如何解决死锁？"></a>产生死锁的必要条件有哪些？如何解决死锁？</h2><h2 id="String-为什么是-final-类型？"><a href="#String-为什么是-final-类型？" class="headerlink" title="String 为什么是 final 类型？"></a>String 为什么是 final 类型？</h2><h2 id="如何设计-Java-的异常体系？"><a href="#如何设计-Java-的异常体系？" class="headerlink" title="如何设计 Java 的异常体系？"></a>如何设计 Java 的异常体系？</h2><h2 id="常用的排序方式有哪些，时间复杂度是多少？"><a href="#常用的排序方式有哪些，时间复杂度是多少？" class="headerlink" title="常用的排序方式有哪些，时间复杂度是多少？"></a>常用的排序方式有哪些，时间复杂度是多少？</h2><h2 id="简述装饰者模式以及适配器模式"><a href="#简述装饰者模式以及适配器模式" class="headerlink" title="简述装饰者模式以及适配器模式"></a>简述装饰者模式以及适配器模式</h2><h2 id="简述-HashMap-和-TreeMap-的实现原理以及常见操作的时间复杂度"><a href="#简述-HashMap-和-TreeMap-的实现原理以及常见操作的时间复杂度" class="headerlink" title="简述 HashMap 和 TreeMap 的实现原理以及常见操作的时间复杂度"></a>简述 HashMap 和 TreeMap 的实现原理以及常见操作的时间复杂度</h2><h2 id="如何设计一个线程池"><a href="#如何设计一个线程池" class="headerlink" title="如何设计一个线程池"></a>如何设计一个线程池</h2><h2 id="Java-线程间有多少通信方式？"><a href="#Java-线程间有多少通信方式？" class="headerlink" title="Java 线程间有多少通信方式？"></a>Java 线程间有多少通信方式？</h2><h2 id="简述-Java-中-final-关键字的作用"><a href="#简述-Java-中-final-关键字的作用" class="headerlink" title="简述 Java 中 final 关键字的作用"></a>简述 Java 中 final 关键字的作用</h2><h2 id="手写生产者消费者模型"><a href="#手写生产者消费者模型" class="headerlink" title="手写生产者消费者模型"></a>手写生产者消费者模型</h2><h2 id="简述-HashSet-与-HashMap-的异同"><a href="#简述-HashSet-与-HashMap-的异同" class="headerlink" title="简述 HashSet 与 HashMap 的异同"></a>简述 HashSet 与 HashMap 的异同</h2><h2 id="深拷贝与浅拷贝区别是什么？"><a href="#深拷贝与浅拷贝区别是什么？" class="headerlink" title="深拷贝与浅拷贝区别是什么？"></a>深拷贝与浅拷贝区别是什么？</h2><h2 id="简述-Spring-的初始化流程"><a href="#简述-Spring-的初始化流程" class="headerlink" title="简述 Spring 的初始化流程"></a>简述 Spring 的初始化流程</h2><h2 id="Java-缓冲流-buffer-的用途和原理是什么？"><a href="#Java-缓冲流-buffer-的用途和原理是什么？" class="headerlink" title="Java 缓冲流 buffer 的用途和原理是什么？"></a>Java 缓冲流 buffer 的用途和原理是什么？</h2><h2 id="简述-Java-内置排序算法的实现原理"><a href="#简述-Java-内置排序算法的实现原理" class="headerlink" title="简述 Java 内置排序算法的实现原理"></a>简述 Java 内置排序算法的实现原理</h2><h2 id="HTTP-中-GET-和-POST-区别"><a href="#HTTP-中-GET-和-POST-区别" class="headerlink" title="HTTP 中 GET 和 POST 区别"></a>HTTP 中 GET 和 POST 区别</h2><h2 id="JDK-1-8有什么新特性？"><a href="#JDK-1-8有什么新特性？" class="headerlink" title="JDK 1.8有什么新特性？"></a>JDK 1.8有什么新特性？</h2><h2 id="有哪些解决哈希表冲突的方式？"><a href="#有哪些解决哈希表冲突的方式？" class="headerlink" title="有哪些解决哈希表冲突的方式？"></a>有哪些解决哈希表冲突的方式？</h2><h2 id="简述-Zookeeper-基础原理以及使用场景"><a href="#简述-Zookeeper-基础原理以及使用场景" class="headerlink" title="简述 Zookeeper 基础原理以及使用场景"></a>简述 Zookeeper 基础原理以及使用场景</h2><h2 id="简述标记清除算法的流程"><a href="#简述标记清除算法的流程" class="headerlink" title="简述标记清除算法的流程"></a>简述标记清除算法的流程</h2><h2 id="简述-SortedSet-实现原理"><a href="#简述-SortedSet-实现原理" class="headerlink" title="简述 SortedSet 实现原理"></a>简述 SortedSet 实现原理</h2><h2 id="Java-有几种基本数据类型，分别占多少字节？"><a href="#Java-有几种基本数据类型，分别占多少字节？" class="headerlink" title="Java 有几种基本数据类型，分别占多少字节？"></a>Java 有几种基本数据类型，分别占多少字节？</h2><h2 id="简述-HashSet-实现原理"><a href="#简述-HashSet-实现原理" class="headerlink" title="简述 HashSet 实现原理"></a>简述 HashSet 实现原理</h2><h2 id="数组与链表有什么区别？"><a href="#数组与链表有什么区别？" class="headerlink" title="数组与链表有什么区别？"></a>数组与链表有什么区别？</h2><h2 id="简述偏向锁以及轻量级锁的区别"><a href="#简述偏向锁以及轻量级锁的区别" class="headerlink" title="简述偏向锁以及轻量级锁的区别"></a>简述偏向锁以及轻量级锁的区别</h2><h2 id="如何回收循环依赖的对象"><a href="#如何回收循环依赖的对象" class="headerlink" title="如何回收循环依赖的对象"></a>如何回收循环依赖的对象</h2><h2 id="Linux-实现虚拟内存有什么方式？"><a href="#Linux-实现虚拟内存有什么方式？" class="headerlink" title="Linux 实现虚拟内存有什么方式？"></a>Linux 实现虚拟内存有什么方式？</h2><h2 id="简述-Java-的序列化和使用场景"><a href="#简述-Java-的序列化和使用场景" class="headerlink" title="简述 Java 的序列化和使用场景"></a>简述 Java 的序列化和使用场景</h2><h2 id="String-为什么是-final？"><a href="#String-为什么是-final？" class="headerlink" title="String 为什么是 final？"></a>String 为什么是 final？</h2><h2 id="Java-多线程有几种实现方式"><a href="#Java-多线程有几种实现方式" class="headerlink" title="Java 多线程有几种实现方式"></a>Java 多线程有几种实现方式</h2><h2 id="如何确定-eden-区的对象何时进入老年代？"><a href="#如何确定-eden-区的对象何时进入老年代？" class="headerlink" title="如何确定 eden 区的对象何时进入老年代？"></a>如何确定 eden 区的对象何时进入老年代？</h2><h2 id="Spring-MVC-如何处理一个请求？"><a href="#Spring-MVC-如何处理一个请求？" class="headerlink" title="Spring MVC 如何处理一个请求？"></a>Spring MVC 如何处理一个请求？</h2><h2 id="Java-中-arrayblockingqueue-与-linkedblockingqueue-的用途和区别"><a href="#Java-中-arrayblockingqueue-与-linkedblockingqueue-的用途和区别" class="headerlink" title="Java 中 arrayblockingqueue 与 linkedblockingqueue 的用途和区别"></a>Java 中 arrayblockingqueue 与 linkedblockingqueue 的用途和区别</h2><h2 id="简述-Java-的-happen-before-原则"><a href="#简述-Java-的-happen-before-原则" class="headerlink" title="简述 Java 的 happen before 原则"></a>简述 Java 的 happen before 原则</h2><h2 id="SpringBoot-是如何进行自动配置的？"><a href="#SpringBoot-是如何进行自动配置的？" class="headerlink" title="SpringBoot 是如何进行自动配置的？"></a>SpringBoot 是如何进行自动配置的？</h2><h2 id="如何判断一个-Hash-函数好不好？"><a href="#如何判断一个-Hash-函数好不好？" class="headerlink" title="如何判断一个 Hash 函数好不好？"></a>如何判断一个 Hash 函数好不好？</h2><h2 id="简述使用协程的优点"><a href="#简述使用协程的优点" class="headerlink" title="简述使用协程的优点"></a>简述使用协程的优点</h2><h2 id="error-和-exception-的区别是什么？"><a href="#error-和-exception-的区别是什么？" class="headerlink" title="error 和 exception 的区别是什么？"></a>error 和 exception 的区别是什么？</h2><h2 id="简述生产者消费者模型"><a href="#简述生产者消费者模型" class="headerlink" title="简述生产者消费者模型"></a>简述生产者消费者模型</h2><h2 id="JVM-是怎么去调优的？简述过程和调优的结果"><a href="#JVM-是怎么去调优的？简述过程和调优的结果" class="headerlink" title="JVM 是怎么去调优的？简述过程和调优的结果"></a>JVM 是怎么去调优的？简述过程和调优的结果</h2><h2 id="简述读写屏障底层原理"><a href="#简述读写屏障底层原理" class="headerlink" title="简述读写屏障底层原理"></a>简述读写屏障底层原理</h2><h2 id="什么是堆内存异常？"><a href="#什么是堆内存异常？" class="headerlink" title="什么是堆内存异常？"></a>什么是堆内存异常？</h2><h2 id="简述有哪些同步锁以及它们的实现原理"><a href="#简述有哪些同步锁以及它们的实现原理" class="headerlink" title="简述有哪些同步锁以及它们的实现原理"></a>简述有哪些同步锁以及它们的实现原理</h2><h2 id="什么是-Spring-容器，有什么作用？"><a href="#什么是-Spring-容器，有什么作用？" class="headerlink" title="什么是 Spring 容器，有什么作用？"></a>什么是 Spring 容器，有什么作用？</h2><h2 id="如何设计一个无锁队列"><a href="#如何设计一个无锁队列" class="headerlink" title="如何设计一个无锁队列"></a>如何设计一个无锁队列</h2><h2 id="如何停止一个线程？"><a href="#如何停止一个线程？" class="headerlink" title="如何停止一个线程？"></a>如何停止一个线程？</h2><h2 id="在一个静态方法内调用一个非静态成员为什么是非法的？"><a href="#在一个静态方法内调用一个非静态成员为什么是非法的？" class="headerlink" title="在一个静态方法内调用一个非静态成员为什么是非法的？"></a>在一个静态方法内调用一个非静态成员为什么是非法的？</h2><h2 id="Spring-是怎么解析-JSON-数据的？"><a href="#Spring-是怎么解析-JSON-数据的？" class="headerlink" title="Spring 是怎么解析 JSON 数据的？"></a>Spring 是怎么解析 JSON 数据的？</h2><h2 id="Java-如何高效进行数组拷贝"><a href="#Java-如何高效进行数组拷贝" class="headerlink" title="Java 如何高效进行数组拷贝"></a>Java 如何高效进行数组拷贝</h2><h2 id="成员变量和方法的区别？"><a href="#成员变量和方法的区别？" class="headerlink" title="成员变量和方法的区别？"></a>成员变量和方法的区别？</h2><h2 id="阻塞队列都有哪几种，有什么区别？"><a href="#阻塞队列都有哪几种，有什么区别？" class="headerlink" title="阻塞队列都有哪几种，有什么区别？"></a>阻塞队列都有哪几种，有什么区别？</h2><h2 id="Java-中如何进行-GC-调优？"><a href="#Java-中如何进行-GC-调优？" class="headerlink" title="Java 中如何进行 GC 调优？"></a>Java 中如何进行 GC 调优？</h2><h2 id="MVC-模型和-MVVM-模型的区别"><a href="#MVC-模型和-MVVM-模型的区别" class="headerlink" title="MVC 模型和 MVVM 模型的区别"></a>MVC 模型和 MVVM 模型的区别</h2><h2 id="Cookie-和-Session-的关系和区别是什么？"><a href="#Cookie-和-Session-的关系和区别是什么？" class="headerlink" title="Cookie 和 Session 的关系和区别是什么？"></a>Cookie 和 Session 的关系和区别是什么？</h2><h2 id="简述-Java-的逃逸分析机制"><a href="#简述-Java-的逃逸分析机制" class="headerlink" title="简述 Java 的逃逸分析机制"></a>简述 Java 的逃逸分析机制</h2><h2 id="new-Integer-和-Integer-valueOf-的区别是什么？"><a href="#new-Integer-和-Integer-valueOf-的区别是什么？" class="headerlink" title="new Integer 和 Integer.valueOf 的区别是什么？"></a>new Integer 和 Integer.valueOf 的区别是什么？</h2><h2 id="简述-Java-中的自动装箱与拆箱"><a href="#简述-Java-中的自动装箱与拆箱" class="headerlink" title="简述 Java 中的自动装箱与拆箱"></a>简述 Java 中的自动装箱与拆箱</h2><h2 id="简单介绍-MyBatis，MyBatis-是如何实现-ORM-映射的"><a href="#简单介绍-MyBatis，MyBatis-是如何实现-ORM-映射的" class="headerlink" title="简单介绍 MyBatis，MyBatis 是如何实现 ORM 映射的"></a>简单介绍 MyBatis，MyBatis 是如何实现 ORM 映射的</h2><h2 id="简述-Web-socket-与-HTTP-的使用场景"><a href="#简述-Web-socket-与-HTTP-的使用场景" class="headerlink" title="简述 Web socket 与 HTTP 的使用场景"></a>简述 Web socket 与 HTTP 的使用场景</h2><p>由于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用 中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。</p><p>而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。</p><p>很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数据传送给 客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以 保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。</p><h2 id="Java-编译后的-class-文件包含了什么内容？"><a href="#Java-编译后的-class-文件包含了什么内容？" class="headerlink" title="Java 编译后的 .class 文件包含了什么内容？"></a>Java 编译后的 .class 文件包含了什么内容？</h2><p>一、类信息</p><p>一部分是描述类的信息，包括类的名字、修饰符(public或private)、父类、接口以及注解(annotation)。</p><p>二、变量信息</p><p>一部分是描述类变量的信息，包括每个变量的名字、修饰符、类型和注解(annotation)。</p><p>三、方法信息</p><p>一部分是描述类方法的信息，包括每个方法的名字、修饰符、参数的类型和返回值的类型、方法的注解(annotation)，还包括编译后的、字节码形式的方法代码。</p><h2 id="Java-中-int-的最大值是多少？"><a href="#Java-中-int-的最大值是多少？" class="headerlink" title="Java 中 int 的最大值是多少？"></a>Java 中 int 的最大值是多少？</h2><p>java int 类整数的最大值是 2 的 31 次方 - 1 = <strong>2147483648 - 1</strong> = <strong>2147483647</strong></p><p>可以用 <strong>Integer.MAX_VALUE</strong> 表示它，即 int value = Integer.MAX_VALUE;</p><p>Integer.MAX_VALUE + 1 = Integer.MIN_VALUE = <strong>-2147483648</strong></p><h2 id="简述封装、继承、多态的特性及使用场景"><a href="#简述封装、继承、多态的特性及使用场景" class="headerlink" title="简述封装、继承、多态的特性及使用场景"></a>简述封装、继承、多态的特性及使用场景</h2><h5 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h5><ul><li>封装的意义在于保护或者防止代码（数据）被我们无意中破坏。</li><li>保护成员属性，不让类以外的程序直接访问和修改；</li><li>隐藏方法细节</li></ul><h5 id="继承的意义"><a href="#继承的意义" class="headerlink" title="继承的意义"></a>继承的意义</h5><p>主要实现重用代码，节省开发时间。</p><p><strong>多态的三个条件:</strong></p><ol><li>继承的存在(继承是多态的基础,没有继承就没有多态).</li><li>子类重写父类的方法(多态下调用子类重写的方法).</li><li>父类引用变量指向子类对象(子类到父类的类型转换).</li></ol><h5 id="实现多态方式"><a href="#实现多态方式" class="headerlink" title="实现多态方式"></a>实现多态方式</h5><ol><li>接口多态性。</li><li>继承多态性。</li><li>通过抽象类实现的多态性。</li></ol><p>题目答案均为转载，题目先后顺序按各大厂总出题次数排列！</p>]]></content>
      
      
      <categories>
          
          <category> 面试技巧 </category>
          
          <category> Java·JVM·JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java·JVM·JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java·JVM·JUC(五)</title>
      <link href="/2022/04/11/Java%C2%B7JVM%C2%B7JUC(%E4%BA%94)/"/>
      <url>/2022/04/11/Java%C2%B7JVM%C2%B7JUC(%E4%BA%94)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Java·JVM·JUC-五"><a href="#Java·JVM·JUC-五" class="headerlink" title="Java·JVM·JUC(五)"></a>Java·JVM·JUC(五)</h1><h2 id="什么是设计模式，描述几个常用的设计模式"><a href="#什么是设计模式，描述几个常用的设计模式" class="headerlink" title="什么是设计模式，描述几个常用的设计模式"></a>什么是设计模式，描述几个常用的设计模式</h2><h3 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h3><p>设计模式就是经过前任无数次的实践总结出的，设计过程中可以反复使用的，可以解决特定问题的设计方法。</p><h3 id="常用的设计模式"><a href="#常用的设计模式" class="headerlink" title="常用的设计模式"></a>常用的设计模式</h3><h4 id="单例模式（懒汉式、饿汉式）"><a href="#单例模式（懒汉式、饿汉式）" class="headerlink" title="单例模式（懒汉式、饿汉式）"></a>单例模式（懒汉式、饿汉式）</h4><p>步骤：<br>1、构造方法私有化，让除了自己类能创建，其他类都不能创建。<br>2、在自己的类中创建一个单实例（懒汉模式是在需要的时候才创建，饿汉模式是一开始就创建）<br>3、提供一个方法获取该实例对象</p><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>spring IOC就是使用了工厂模式，对象的创建都交给一个工厂去创建。</p><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>spring AOP就是使用的动态代理模式。一般是指接口的实现。</p><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><p>小美是被观察者，小王和小李是观察者，被观察者发出一条信息，然后观察者们进行相应的处理，看代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="comment">//小王和小李通过这个接口可以接收到小美发过来的消息</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">getMessage</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口相当于小王和小李的电话号码，小美发送通知的时候就会拨打getMessage这个电话，拨打电话就是调用接口，看不懂没关系，先往下看</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LaoWang</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String name = <span class="string">&quot;小王&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">LaoWang</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMessage</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       System.out.println(name + <span class="string">&quot;接到了小美打过来的电话，电话内容是：&quot;</span> + s);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LaoLi</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String name = <span class="string">&quot;小李&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">LaoLi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMessage</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       System.out.println(name + <span class="string">&quot;接到了小美打过来的电话，电话内容是：-&gt;&quot;</span> + s);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，我们再看看小美的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMei</span> </span>&#123;</span><br><span class="line">   List&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XiaoMei</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPerson</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">        list.add(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历list，把自己的通知发送给所有暗恋自己的人</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Person person:list)&#123;</span><br><span class="line">            person.getMessage(<span class="string">&quot;你们过来吧，谁先过来谁就能陪我一起玩儿游戏!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们写一个测试类来看一下结果对不对</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       XiaoMei xiao_mei = <span class="keyword">new</span> XiaoMei();</span><br><span class="line">       LaoWang lao_wang = <span class="keyword">new</span> LaoWang();</span><br><span class="line">       LaoLi lao_li = <span class="keyword">new</span> LaoLi();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//小王和小李在小美那里都注册了一下</span></span><br><span class="line">       xiao_mei.addPerson(lao_wang);</span><br><span class="line">       xiao_mei.addPerson(lao_li);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//小美向小王和小李发送通知</span></span><br><span class="line">       xiao_mei.notifyPerson();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h4><p>对已有的业务逻辑进一步的封装，使其增加额外的功能，如Java中的IO流就使用了装饰者模式，用户在使用的时候，可以任意组装，达到自己想要的效果。举个栗子，我想吃三明治，首先我需要一根大大的香肠，我喜欢吃奶油，在香肠上面加一点奶油，再放一点蔬菜，最后再用两片面包夹一下，很丰盛的一顿午饭，营养又健康。那我们应该怎么来写代码呢？首先，我们需要写一个Food类，让其他所有食物都来继承这个类，看代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String food_name;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Food</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Food</span><span class="params">(String food_name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.food_name = food_name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> food_name;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，我就不解释了，然后我们写几个子类继承它：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//面包类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bread</span> <span class="keyword">extends</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Food basic_food;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Bread</span><span class="params">(Food basic_food)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.basic_food = basic_food;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> basic_food.make()+<span class="string">&quot;+面包&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//奶油类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cream</span> <span class="keyword">extends</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Food basic_food;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Cream</span><span class="params">(Food basic_food)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.basic_food = basic_food;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> basic_food.make()+<span class="string">&quot;+奶油&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//蔬菜类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vegetable</span> <span class="keyword">extends</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Food basic_food;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Vegetable</span><span class="params">(Food basic_food)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.basic_food = basic_food;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> basic_food.make()+<span class="string">&quot;+蔬菜&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几个类都是差不多的，构造方法传入一个Food类型的参数，然后在make方法中加入一些自己的逻辑，如果你还是看不懂为什么这么写，不急，你看看我的Test类是怎么写的，一看你就明白了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       Food food = <span class="keyword">new</span> Bread(<span class="keyword">new</span> Vegetable(<span class="keyword">new</span> Cream(<span class="keyword">new</span> Food(<span class="string">&quot;香肠&quot;</span>))));</span><br><span class="line">       System.out.println(food.make());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到没有，一层一层封装，我们从里往外看：最里面我new了一个香肠，在香肠的外面我包裹了一层奶油，在奶油的外面我又加了一层蔬菜，最外面我放的是面包。</p><h2 id="简述-CMS-与-G1-机制的区别"><a href="#简述-CMS-与-G1-机制的区别" class="headerlink" title="简述 CMS 与 G1 机制的区别"></a>简述 CMS 与 G1 机制的区别</h2><h3 id="区别一：-使用范围不一样"><a href="#区别一：-使用范围不一样" class="headerlink" title="区别一： 使用范围不一样"></a>区别一： 使用范围不一样</h3><p>CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用<br> G1收集器收集范围是老年代和新生代。不需要结合其他收集器使用</p><h3 id="区别二：-STW的时间"><a href="#区别二：-STW的时间" class="headerlink" title="区别二： STW的时间"></a>区别二： STW的时间</h3><p>CMS收集器以最小的停顿时间为目标的收集器。</p><p>G1收集器可预测垃圾回收的停顿时间（建立可预测的停顿时间模型）</p><h3 id="区别三：-垃圾碎片"><a href="#区别三：-垃圾碎片" class="headerlink" title="区别三： 垃圾碎片"></a>区别三： 垃圾碎片</h3><p>CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片</p><p>G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。</p><h2 id="集合类中的-List-和-Map-的线程安全版本是什么，如何保证线程安全的？"><a href="#集合类中的-List-和-Map-的线程安全版本是什么，如何保证线程安全的？" class="headerlink" title="集合类中的 List 和 Map 的线程安全版本是什么，如何保证线程安全的？"></a>集合类中的 List 和 Map 的线程安全版本是什么，如何保证线程安全的？</h2><ol><li><p>线程安全与线程不安全集合<br>集合类型中存在线程安全与线程不安全的两种,常见例如:<br>ArrayList —– Vector<br>HashMap —–HashTable<br>但是以上都是通过 synchronized 关键字实现,效率较低</p></li><li><p>Collections 构建的线程安全集合，Collections 提供了方法 synchronizedList 保证 list 是同步线程安全的,如Collections.synchronizedList()</p></li><li><p>java.util.concurrent 并发包下<br>CopyOnWriteArrayList CopyOnWriteArraySet 类型,通过动态数组与线程安全个方面保证线程安全</p></li></ol><h2 id="Java-的线程有哪些状态，转换关系是怎么样的？"><a href="#Java-的线程有哪些状态，转换关系是怎么样的？" class="headerlink" title="Java 的线程有哪些状态，转换关系是怎么样的？"></a>Java 的线程有哪些状态，转换关系是怎么样的？</h2><ol><li><p>新建(NEW)：新创建了一个线程对象。</p></li><li><p>可运行(RUNNABLE**)**：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。</p></li><li><p>运行(RUNNING)：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。</p></li><li><p>阻塞(BLOCKED)：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： </p><ul><li> 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。</li><li> 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</li><li> 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</li></ul></li><li><p>死亡(DEAD)：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p></li></ol><h2 id="简述-Java-AQS-的原理以及使用场景"><a href="#简述-Java-AQS-的原理以及使用场景" class="headerlink" title="简述 Java AQS 的原理以及使用场景"></a>简述 Java AQS 的原理以及使用场景</h2><h3 id="AQS核心思想"><a href="#AQS核心思想" class="headerlink" title="AQS核心思想"></a>AQS核心思想</h3><p>如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。</p><p>CLH：Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO），AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。</p><h2 id="Java-异常有哪些类型？"><a href="#Java-异常有哪些类型？" class="headerlink" title="Java 异常有哪些类型？"></a>Java 异常有哪些类型？</h2><p><img src="https://s2.loli.net/2022/04/11/d1cpj4mgISif5zB.png" alt="image-20220411090142921"></p><h3 id="可查的异常（checked-exceptions）和不可查的异常（unchecked-exceptions）"><a href="#可查的异常（checked-exceptions）和不可查的异常（unchecked-exceptions）" class="headerlink" title="可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）"></a>可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）</h3><ul><li><strong>可查异常</strong>（编译器要求必须处置的异常）：</li></ul><p>正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。</p><p>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p><ul><li><strong>不可查异常</strong>(编译器不要求强制处置的异常)</li></ul><p>包括运行时异常（RuntimeException与其子类）和错误（Error）。</p><h2 id="hashmap-和-hashtable-的区别是什么？"><a href="#hashmap-和-hashtable-的区别是什么？" class="headerlink" title="hashmap 和 hashtable 的区别是什么？"></a>hashmap 和 hashtable 的区别是什么？</h2><ol><li>线程安全性不同。HashMap线程不安全；Hashtable 中的方法是Synchronize的。</li><li>key、value是否允许null。HashMap的key和value都是可以是null，key只允许一个null；Hashtable的key和value都不可为null。</li><li>迭代器不同。HashMap的Iterator是fail-fast迭代器；Hashtable还使用了enumerator迭代器。</li><li>hash的计算方式不同。HashMap计算了hash值；Hashtable使用了key的hashCode方法。</li><li>默认初始大小和扩容方式不同。HashMap默认初始大小16，容量必须是2的整数次幂，扩容时将容量变为原来的2倍；Hashtable默认初始大小11，扩容时将容量变为原来的2倍加1。</li><li>是否有contains方法。HashMap没有contains方法；Hashtable包含contains方法，类似于containsValue。</li><li>父类不同。HashMap继承自AbstractMap；Hashtable继承自Dictionary。</li></ol><h2 id="简述-Spring-注解的实现原理"><a href="#简述-Spring-注解的实现原理" class="headerlink" title="简述 Spring 注解的实现原理"></a>简述 Spring 注解的实现原理</h2><h3 id="注解如何实现"><a href="#注解如何实现" class="headerlink" title="注解如何实现"></a>注解如何实现</h3><p>1、接口使用****@interface****定义。</p><p>2、通过继承以下注解，实现功能：</p><p> 元注解**@Target,@Retention,@Documented,@Inherited** </p><h3 id="Spring注解的实现原理"><a href="#Spring注解的实现原理" class="headerlink" title="Spring注解的实现原理"></a>Spring注解的实现原理</h3><p>【两种处理策略】<br> (1)类级别的注解：如@Component、@Repository、@Controller、@Service以及JavaEE6的@ManagedBean和@Named注解，都是添加在类上面的类级别注解。<br> Spring容器根据注解的过滤规则扫描读取注解Bean定义类，并将其注册到Spring IoC容器中。</p><p>(2)类内部的注解：如@Autowire、@Value、@Resource以及EJB和WebService相关的注解等，都是添加在类内部的字段或者方法上的类内部注解。<br> SpringIoC容器通过Bean后置注解处理器解析Bean内部的注解。</p><p><strong>Spring 3.0 新增AnnotationConfigApplicationContext注解处理器实现原理</strong></p><p>AnnotationConfigApplicationContext注解处理器是Spring boot提供的一个比较常用的注解处理器。我们先看看它的工作原理。</p><p>第一步：初始化读取器AnnotationBeanDefinitionReader</p><p>第二步：初始化扫描器AnnotationBeanDefinitionScanner</p><p>第三步：调用父GenericApplicationContext的无参构造方法初始化一个BeanFactory。这里初始化使用的是DefaultListableBeanFactory。</p><p>第四步：注册Bean配置类</p><p>第五步：刷新上下文</p><h2 id="Java-线程和操作系统的线程是怎么对应的？Java线程是怎样进行调度的"><a href="#Java-线程和操作系统的线程是怎么对应的？Java线程是怎样进行调度的" class="headerlink" title="Java 线程和操作系统的线程是怎么对应的？Java线程是怎样进行调度的?"></a>Java 线程和操作系统的线程是怎么对应的？Java线程是怎样进行调度的?</h2><h3 id="Java-线程和操作系统的线程是怎么对应"><a href="#Java-线程和操作系统的线程是怎么对应" class="headerlink" title="Java 线程和操作系统的线程是怎么对应"></a>Java 线程和操作系统的线程是怎么对应</h3><p>从实际意义上来讲，操作系统中的线程除去new和terminated状态，一个线程真实存在的状态，只有：</p><ul><li>ready：表示线程已经被创建，正在等待系统调度分配CPU使用权。</li><li>running：表示线程获得了CPU使用权，正在进行运算</li><li>waiting：表示线程等待（或者说挂起），让出CPU资源给其他线程使用</li></ul><p>对于Java中的线程状态：</p><p>无论是<code>Timed Waiting</code> ，<code>Waiting</code>还是<code>Blocked</code>，对应的都是操作系统线程的**<code>waiting</code>（等待**）状态。<br>而<code>Runnable</code>状态，则对应了操作系统中的<code>ready</code>和<code>running</code>状态。</p><p><strong>JVM在设计上，就已经声明：</strong></p><blockquote><p>虚拟机中的线程状态，不反应任何操作系统线程状态</p></blockquote><h3 id="Java线程是怎样进行调度的"><a href="#Java线程是怎样进行调度的" class="headerlink" title="Java线程是怎样进行调度的"></a>Java线程是怎样进行调度的</h3><ol><li><p>Java在调度机制上采用的时抢占式的线程调度机制。</p></li><li><p>Java线程在运行的过程中多个线程之间式协作式的。</p></li></ol><p>第一个《深入理解Java虚拟机》一书中所说的<strong>Java采用抢占式线程调度</strong>，是对的，<strong>但是他是站在JVM的层面上说的，是站在线程调度的角度来说的</strong>，确实，在JVM层面上，我们的线程都是由JVM负责调度与打断的，当某个线程的时间片用完了，JVM就会剥夺其对CPU的使用权，交给另一个线程使用（这里就可以理解为抢占）。</p><p>第二个，说<strong>Java线程是协作式的</strong>，也是对的，<strong>但是他是站在Java api的层面上来说的，是站在多线程并发运行的角度来说的，</strong>确实，你会发现，<strong>一个线程调用另一个线程的interrupt() 方法中断线程</strong>，并不是强行关闭这个线程，只是跟这个线程打个招呼，<strong>将线程的中断标志位置为true</strong>，线程是否中断，由线程本身决定。如果真的想要中断当前线程，我们可以对其<strong>“中断标志位</strong>”进行判断，如果是true我们就在代码层面上停止当前线程的执行逻辑。这里就充分的体现了线程协作的思想，<strong>“你不能强行中断我，只要我主动放弃你才能占有我的cpu”</strong>。</p><h2 id="Java-线程池里的-arrayblockingqueue-与-linkedblockingqueue-的使用场景和区别"><a href="#Java-线程池里的-arrayblockingqueue-与-linkedblockingqueue-的使用场景和区别" class="headerlink" title="Java 线程池里的 arrayblockingqueue 与 linkedblockingqueue 的使用场景和区别"></a>Java 线程池里的 arrayblockingqueue 与 linkedblockingqueue 的使用场景和区别</h2><p>BlockingQueue接口定义了一种阻塞的<a href="https://so.csdn.net/so/search?q=FIFO&spm=1001.2101.3001.7020">FIFO</a> queue，每一个BlockingQueue都有一个容量，让容量满时往BlockingQueue中添加数据时会造成阻塞，当容量为空时取元素操作会阻塞。</p><p>ArrayBlockingQueue是一个由数组支持的有界阻塞<a href="https://so.csdn.net/so/search?q=%E9%98%9F%E5%88%97&spm=1001.2101.3001.7020">队列</a>。在读写操作上都需要锁住整个容器，因此吞吐量与一般的实现是相似的，适合于实现“生产者消费者”模式。</p><h3 id="ArrayBlockingQueue与LinkedBlockingQueue实现"><a href="#ArrayBlockingQueue与LinkedBlockingQueue实现" class="headerlink" title="ArrayBlockingQueue与LinkedBlockingQueue实现"></a>ArrayBlockingQueue与LinkedBlockingQueue实现</h3><p>ArrayBlockingQueue内部是采用数组进行数据存储的（<code>属性items</code>），为了保证线程安全，采用的是<code>ReentrantLock lock</code>，为了保证可阻塞式的插入删除数据利用的是Condition，当获取数据的消费者线程被阻塞时会将该线程放置到notEmpty等待队列中，当插入数据的生产者线程被阻塞时，会将该线程放置到notFull等待队列中。而notEmpty和notFull等中要属性在构造方法中进行创建：</p><p>LinkedBlockingQueue是用链表实现的有界阻塞队列，当构造对象时为指定队列大小时，队列默认大小为<code>Integer.MAX_VALUE</code>。</p><h3 id="ArrayBlockingQueue与LinkedBlockingQueue的比较"><a href="#ArrayBlockingQueue与LinkedBlockingQueue的比较" class="headerlink" title="ArrayBlockingQueue与LinkedBlockingQueue的比较"></a>ArrayBlockingQueue与LinkedBlockingQueue的比较</h3><p><strong>相同点</strong>：ArrayBlockingQueue和LinkedBlockingQueue都是通过condition通知机制来实现可阻塞式插入和删除元素，并满足线程安全的特性；</p><p><strong>不同点</strong>：</p><ol><li>ArrayBlockingQueue底层是采用的数组进行实现，而LinkedBlockingQueue则是采用链表数据结构；</li><li>ArrayBlockingQueue插入和删除数据，只采用了一个lock，而LinkedBlockingQueue则是在插入和删除分别采用了<code>putLock</code>和<code>takeLock</code>，这样可以降低线程由于线程无法获取到lock而进入WAITING状态的可能性，从而提高了线程并发执行的效率。</li></ol><p>题目答案均为转载，题目先后顺序按各大厂总出题次数排列！</p>]]></content>
      
      
      <categories>
          
          <category> 面试技巧 </category>
          
          <category> Java·JVM·JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java·JVM·JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java·JVM·JUC(四)</title>
      <link href="/2022/04/03/Java%C2%B7JVM%C2%B7JUC(%E5%9B%9B)%20/"/>
      <url>/2022/04/03/Java%C2%B7JVM%C2%B7JUC(%E5%9B%9B)%20/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Java·JVM·JUC-四"><a href="#Java·JVM·JUC-四" class="headerlink" title="Java·JVM·JUC(四)"></a>Java·JVM·JUC(四)</h1><h2 id="什么是公平锁？什么是非公平锁？"><a href="#什么是公平锁？什么是非公平锁？" class="headerlink" title="什么是公平锁？什么是非公平锁？"></a>什么是公平锁？什么是非公平锁？</h2><p>公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。</p><ul><li>优点：所有的线程都能得到资源，不会饿死在队列中。</li><li>缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。</li></ul><p>非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</p><ul><li>优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。</li><li>缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。</li></ul><h2 id="简述动态代理与静态代理"><a href="#简述动态代理与静态代理" class="headerlink" title="简述动态代理与静态代理"></a>简述动态代理与静态代理</h2><p><strong>代理模式的常见实现方式：基于接口的代理模式 和 基于类继承的代理模式</strong></p><p>代理实现方式：如果按照代理创建的时期来进行分类的话， 可以分为静态代理、动态代理。</p><p>一：静态代理是由程序员创建或特定工具自动生成代理类，再对其编译，在程序运行之前，代理类.class文件就已经被创建了。</p><p>二：动态代理是在程序运行时通过反射机制动态创建代理对象。</p><p><img src="https://s2.loli.net/2022/04/06/39MNhtOCHq5VZUu.png" alt="image-20220406130748971"></p><p><strong>静态代理总结：</strong></p><p>优点：</p><p>1、在符合开闭原则的情况下，对目标对象功能进行扩展和拦截。</p><p>2、在访问无法访问的资源，增强现有的接口业务功能方面有很大的优点。</p><p>3、一个代理类只能代理一个真实的对象。</p><p>缺点：</p><p>1、需要为每个目标类创建代理类和接口，导致类的数量大大增加，工作量大，导致系统结构比较臃肿和松散。</p><p>2、接口功能一旦修改，代理类和目标类也得相应修改，不易维护。</p><p><strong>动态代理的特点</strong></p><ol><li>目标对象不固定</li><li>在应用程序执行时动态创建目标对象</li><li>代理对象会增强目标对象的行为</li></ol><p><strong>JDK代理与CGLIB代理的区别</strong></p><ul><li>JDK动态代理实现接口，Cglib动态代理继承思想</li><li>JDK动态代理（目标对象存在接口时）执行效率高于Ciglib</li><li>如果目标对象有接口实现，选择JDK代理，如果没有接口实现选择Cglib代理</li></ul><h2 id="Java-是如何实现线程安全的，哪些数据结构是线程安全的？"><a href="#Java-是如何实现线程安全的，哪些数据结构是线程安全的？" class="headerlink" title="Java 是如何实现线程安全的，哪些数据结构是线程安全的？"></a>Java 是如何实现线程安全的，哪些数据结构是线程安全的？</h2><ol><li>HashTable是线程安全类；通过对其方法函数进行synchronized修饰实现其特性，效率低下，目前已被jdk废弃，不再推荐使用。</li><li>在多线程环境下，我们常用ConcurrentHashMap在需要保证数据安全的场景中去替换HashMap；此外ConcurrentHashMap也有不错的性能表现</li><li>CopyOnWriteArrayList类是一个线程安全的List接口的实现，在高并发的情况下，可以提供高性能的并发读取，并且保证读取的内容一定是正确的，这对于读操作远远多于写操作的应用非常适合。</li><li>CopyOnWriteArraySet是对CopyOnWriteArrayList使用了装饰模式后的具体实现，可理解为线程安全的Set。</li><li>ConcurrentLinkedQueue应该算是在高并发环境中性能最好的队列；在多线程的队列应用场景中，强烈推荐使用。</li><li>Vector中的操作是线程安全的，它是利用synchronized同步锁机制进行实现，其实现方式与HashTable类似。</li><li>StringBuffer与StringBuilder常用于字符串拼接；前者线程安全，后者不是线程安全的；在多线程环境中下，考虑数据安全使用前者，否则使用后者。</li></ol><h2 id="Spring-MVC-的原理和流程"><a href="#Spring-MVC-的原理和流程" class="headerlink" title="Spring MVC 的原理和流程"></a>Spring MVC 的原理和流程</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul><li>M:Model(完成业务逻辑 Service/dao/entity/)</li><li>V:View(完成界面渲染 jsp/html)</li><li>C:Controller(控制器-&gt;类似于CPU 接受请求-&gt;调用M-&gt;返回V)</li></ul><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><img src="https://s2.loli.net/2022/04/11/Eyi9w6fRjkQLmP5.png" alt="image-20220406160034120"></p><p><strong>SpringMVC执行流程:</strong></p><ol><li>用户发送请求至前端控制器DispatcherServlet</li><li>DispatcherServlet收到请求调用处理器映射器HandlerMapping。</li><li>处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet。</li><li>DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作</li><li>执行处理器Handler(Controller，也叫页面控制器)。</li><li>Handler执行完成返回ModelAndView</li><li>HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet</li><li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li><li>ViewReslover解析后返回具体View</li><li>DispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中）。</li><li>DispatcherServlet响应用户。</li></ol><h2 id="Java-怎么防止内存溢出"><a href="#Java-怎么防止内存溢出" class="headerlink" title="Java 怎么防止内存溢出"></a>Java 怎么防止内存溢出</h2><ul><li>内存泄漏 memory leak：对象可达但不可用；是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。</li><li>内存溢出 out of memory：内存大小不够；是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。</li></ul><h3 id="避免内存泄漏、溢出"><a href="#避免内存泄漏、溢出" class="headerlink" title="避免内存泄漏、溢出"></a>避免内存泄漏、溢出</h3><ul><li>1、尽早释放无用对象的引用<br>好的办法是使用临时变量的时候，让引用变量在推出活动域后自动设置为null，暗示垃圾收集器来收集该对象，防止发生内存泄漏。</li><li>2、程序进行字符串处理时，尽量避免使用String，而应该使用StringBuffer。<br>因为String类是不可变的，每一个String对象都会独立占用内存一块区域。</li><li>3、尽量少用静态变量<br>因为静态变量是全局的，存在方法区，GC不会回收。（用永久代实现的方法区，垃圾回收行为在这个区域是比较少出现的，垃圾回收器的主要目标是针对常量池和类型的卸载）</li><li>4、避免集中创建对象，尤其是大对象，如果可以的话尽量使用流操作<br>JVM会突然需要大量neicun，这时会出发GC优化系统内存环境</li><li>5、尽量运用对象池技术以提高系统性能<br>生命周期长的对象拥有生命周期短的对象时容易引发内存泄漏，例如大集合对象拥有大数据量的业务对象的时候，可以考虑分块进行处理，然后解决一块释放一块的策略。</li><li>6、不要在经常调用的方法中创建对象，尤其忌讳在循环中创建对象<br>可以适当的使用hashtable，vector创建一组对象容器，然后从容器中去取这些对象，而不用每次new之后又丢弃。</li><li>7、优化配置<ul><li>设置－Xms、－Xmx等 </li><li>设置NewSize、MaxNewSize相等 </li><li>设置 Heap size，PermGen space</li></ul></li></ul><h2 id="简述-Java-锁升级的机制"><a href="#简述-Java-锁升级的机制" class="headerlink" title="简述 Java 锁升级的机制"></a>简述 Java 锁升级的机制</h2><p>锁的状态</p><ul><li>无锁 ：无锁是指没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</li><li>偏向锁 ：偏向锁是指当一段同步代码一直被同一个线程所访问时，即不存在多个线程的竞争时，那么该线程在后续访问时便会自动获得锁，从而降低获取锁带来的消耗，即提高性能。</li><li>轻量级锁 ：轻量级锁是指当锁是偏向锁的时候，却被另外的线程所访问，此时偏向锁就会升级为轻量级锁，其他线程会通过自旋（关于自旋的介绍见文末）的形式尝试获取锁，线程不会阻塞，从而提高性能。</li><li>重量级锁 ：重量级锁是指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。</li></ul><h3 id="锁升级过程"><a href="#锁升级过程" class="headerlink" title="锁升级过程"></a>锁升级过程</h3><ul><li><p>无锁到偏向锁</p><p>初次执行到synchronized代码块的时候，锁对象变成偏向锁，通过CAS修改对象头里的锁标志位。</p></li><li><p>偏向锁到轻量级锁</p><p>轻量级锁是指当锁是偏向锁的时候，却被另外的线程所访问，此时偏向锁就会升级为轻量级锁</p></li><li><p>轻量级锁到重量级锁</p><p>如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁，依然是CAS修改锁标志位，但不修改持有锁的线程ID。</p></li></ul><p><img src="https://s2.loli.net/2022/04/06/t3kH5yBpRvbjYDm.png" alt="image-20220406161020540"></p><h3 id="锁升级的目的"><a href="#锁升级的目的" class="headerlink" title="锁升级的目的"></a>锁升级的目的</h3><h4 id="锁竞争"><a href="#锁竞争" class="headerlink" title="锁竞争"></a>锁竞争</h4><p>这里要明确一下什么是锁竞争：如果多个线程轮流获取一个锁，但是每次获取锁的时候都很顺利，没有发生阻塞，那么就不存在锁竞争。只有当某线程尝试获取锁的时候，发现该锁已经被占用，只能等待其释放，这才发生了锁竞争。</p><p>我们Java团队发现，很多情况下，即便是多线程环境，由于每次占用资源的时间短，实际上可能没有发生锁竞争，偏向锁主要就是对这个层面进行优化。</p><h4 id="自旋"><a href="#自旋" class="headerlink" title="自旋"></a>自旋</h4><p>轻量级锁是通过自选的方式来等待资源的，在Jdk1.6我们的自旋尝试次数是一个JVM参数，默认是10。但是在后序版本中，自旋的尝试次数都交给JVM进行控制，也就是编程了<strong>自适应自旋锁</strong>。</p><p>简单的说就是锁变聪明了，假如上一次CAS尝试了十次并且成功了。我们此次CAS自旋了十次也没有成功，但是由于上一次CAS成功了，我们自适应自旋锁认为本次也很可能成功，会多尝试几次。</p><h4 id="忙等"><a href="#忙等" class="headerlink" title="忙等"></a>忙等</h4><p>长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他线程就只能在原地空耗CPU，执行不了任何有效的任务，这种现象叫做忙等（busy-waiting）。如果多个线程用一个锁，但是没有发生锁竞争，或者发生了很轻微的锁竞争，那么synchronized就用轻量级锁，允许短时间的忙等现象。这是一种折衷的想法，短时间的忙等，换取线程在用户态和内核态之间切换的开销。</p><p>用户态和内核态</p><h4 id="线程挂起"><a href="#线程挂起" class="headerlink" title="线程挂起"></a>线程挂起</h4><p>重量级锁是指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。</p><p>简言之，就是所有的控制权都交给了操作系统，由操作系统来负责线程间的调度和线程的状态变更。而这样会出现频繁地对线程运行状态的切换，线程的挂起和唤醒，从而消耗大量的系统资源。</p><h2 id="HashMap-实现原理，为什么使用红黑树？"><a href="#HashMap-实现原理，为什么使用红黑树？" class="headerlink" title="HashMap 实现原理，为什么使用红黑树？"></a>HashMap 实现原理，为什么使用红黑树？</h2><p>在jdk1.8版本后，Java对HashMap做了改进，<strong>在链表长度大于8的时候</strong>，将后面的数据存在<strong>红黑树</strong>中，以<strong>加快检索速度</strong>。（数组+链表+红黑树）</p><h3 id="红黑树特点"><a href="#红黑树特点" class="headerlink" title="红黑树特点"></a>红黑树特点</h3><p>①：每个节点都有红色或黑色树的根始终是黑色的<br>②：没有两个相邻的红色节点<br>③：从节点（包括根）到其任何后代NULL节点(叶子结点下方挂的两个空节点，并且认为他们是黑色的)的每条路径都具有相同数量的黑色节点</p><h3 id="HashMap红黑树原理分析："><a href="#HashMap红黑树原理分析：" class="headerlink" title="HashMap红黑树原理分析："></a>HashMap红黑树原理分析：</h3><p>1.好处就是避免在最极端的情况下链表变得很长很长，在查询的时候，效率会非常慢。<br>2.红黑树查询：其访问性能近似于折半查找，时间复杂度 O(logn)；<br>3.链表查询：这种情况下，需要遍历全部元素才行，时间复杂度 O(n)；<br>4.简单的说，红黑树是一种近似平衡的二叉查找树，其主要的优点就是“平衡“，即左右子树高度几乎一致，以此来防止树退化为链表，通过这种方式来保障查找的时间复杂度为 log(n)。</p><h2 id="hashcode-和-equals-方法的联系"><a href="#hashcode-和-equals-方法的联系" class="headerlink" title="hashcode 和 equals 方法的联系"></a>hashcode 和 equals 方法的联系</h2><ul><li>如果两个对象equals()方法相等则它们的hashCode返回值一定要相同，如果两个对象的hashCode返回值相同，但它们的equals()方法不一定相等。</li><li>两个对象的hashCode()返回值相等不能判断这两个对象是相等的，但两个对象的hashcode()返回值不相等则可以判定两个对象一定不相等。</li></ul><h2 id="什么是重写和重载？"><a href="#什么是重写和重载？" class="headerlink" title="什么是重写和重载？"></a>什么是重写和重载？</h2><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><ol><li>发生在父类与子类之间</li><li>方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同<br>访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private)</li><li>重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常</li></ol><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><ol><li>重载Overload是一个类中多态性的一种表现</li><li>重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序)</li><li>重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准</li></ol><h2 id="Java-中-sleep-与-wait-的区别"><a href="#Java-中-sleep-与-wait-的区别" class="headerlink" title="Java 中 sleep() 与 wait() 的区别"></a>Java 中 sleep() 与 wait() 的区别</h2><ol><li>这两个方法来自不同的类分别是，sleep来自Thread类，和wait来自Object类。</li><li>最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。</li><li>使用范围：wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用</li><li>sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常</li></ol><h2 id="什么是内存泄漏，怎么确定内存泄漏？"><a href="#什么是内存泄漏，怎么确定内存泄漏？" class="headerlink" title="什么是内存泄漏，怎么确定内存泄漏？"></a>什么是内存泄漏，怎么确定内存泄漏？</h2><p><strong>内存泄漏</strong>：一部分内存空间我明明已经使用了，却没有引用指向这部分空间。造成这片已经使用的空间无法处理的情况。</p><blockquote><p>动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元，直到程序结束。</p></blockquote><h3 id="内存泄漏的危害"><a href="#内存泄漏的危害" class="headerlink" title="内存泄漏的危害"></a>内存泄漏的危害</h3><ul><li>长时间运行，程序变卡，性能严重下降</li><li>程序莫名其妙挂掉</li><li><em>OutOfMemoryError</em>错误</li><li>乱七八糟的错误，还不易排查</li></ul><h3 id="内存泄漏原因"><a href="#内存泄漏原因" class="headerlink" title="内存泄漏原因"></a>内存泄漏原因</h3><ol><li>大量使用静态变量  (由于静态变量与程序生命周期一致，因此对象常驻内存，造成内存泄漏)</li><li>连接资源未关闭 (每当建立一个连接，jvm就会为这么资源分配内存。比如数据库连接、文件输入输出流、网络连接等等。<strong>解决：使用完关闭连接</strong>)</li><li>equals()和hashCode()方法使用不当（<strong>解决：对象判断相等时重新equals来保证hashcode是相等的</strong>）</li><li>内部类持有外部类</li><li>finalize方法 （这个对象含有finalize，进入了队列但一直没有被调用的这段时间，会一直占用内存。）</li><li>ThreadLocal的错误使用 （<strong>解决：使用完ThreadLocal后，执行remove操作，避免出现内存溢出情况。</strong>）</li></ol><p>题目答案均为转载，题目先后顺序按各大厂总出题次数排列！</p>]]></content>
      
      
      <categories>
          
          <category> 面试技巧 </category>
          
          <category> Java·JVM·JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java·JVM·JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树四种遍历</title>
      <link href="/2022/03/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%9B%E7%A7%8D%E9%81%8D%E5%8E%86/"/>
      <url>/2022/03/18/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%9B%E7%A7%8D%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="二叉树四种遍历"><a href="#二叉树四种遍历" class="headerlink" title="二叉树四种遍历"></a>二叉树四种遍历</h1><h2 id="遍历描述"><a href="#遍历描述" class="headerlink" title="遍历描述"></a>遍历描述</h2><p><img src="https://s2.loli.net/2022/03/16/IL92Euw1fSmaiM7.png" alt="image-20220316114347259"></p><p><strong>前序遍历</strong>：先根节点，再左子树，最后右子树；上图的访问结果为：GDAFEMHZ。</p><p><strong>中序遍历</strong>：先左子树，再根节点，最后右子树；上图的访问结果为：ADEFGHMZ。</p><p><strong>后序遍历</strong>：先左子树，再右子树，最后根节点，上图的访问结果为：AEFDHZMG。</p><p><strong>层次遍历</strong>：上图的访问结果为：GDMAFHZE。</p><h2 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] preorderTraversal (TreeNode root) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(list,root);</span><br><span class="line">        <span class="keyword">int</span>[] arr = list.stream().mapToInt(num -&gt; Integer.valueOf(num)).toArray();</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;Integer&gt; list,TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            dfs(list,root.left);</span><br><span class="line">            dfs(list,root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] inorderTraversal (TreeNode root) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(list,root);</span><br><span class="line">        <span class="keyword">int</span>[] ints = list.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">        <span class="keyword">return</span> ints;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;Integer&gt; list,TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(list,root.left);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        dfs(list,root.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h2><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] postorderTraversal (TreeNode root) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(list,root);</span><br><span class="line">        <span class="keyword">int</span>[] ints = list.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">        <span class="keyword">return</span> ints;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;Integer&gt; list, TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(list,root.left);</span><br><span class="line">        dfs(list,root.right);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的层次遍历实现"><a href="#二叉树的层次遍历实现" class="headerlink" title="二叉树的层次遍历实现"></a>二叉树的层次遍历实现</h2><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder (TreeNode root) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        bfs(lists,root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; lists,TreeNode root,<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(level &gt;= lists.size())&#123;</span><br><span class="line">            lists.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        lists.get(level).add(root.val);</span><br><span class="line">        bfs(lists,root.left,level+<span class="number">1</span>);</span><br><span class="line">        bfs(lists,root.right,level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试技巧 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java·JVM·JUC(三)</title>
      <link href="/2022/03/15/Java%C2%B7JVM%C2%B7JUC(%E4%B8%89)/"/>
      <url>/2022/03/15/Java%C2%B7JVM%C2%B7JUC(%E4%B8%89)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Java·JVM·JUC-三"><a href="#Java·JVM·JUC-三" class="headerlink" title="Java·JVM·JUC(三)"></a>Java·JVM·JUC(三)</h1><h2 id="ThreadLocal-实现原理是什么？"><a href="#ThreadLocal-实现原理是什么？" class="headerlink" title="ThreadLocal 实现原理是什么？"></a>ThreadLocal 实现原理是什么？</h2><p>ThreadLocal 是一个本地线程副本变量工具类，在每个线程中都创建了一个 ThreadLocalMap 对象，简单说 ThreadLocal 就是一种以空间换时间的做法，每个线程可以访问自己内部 ThreadLocalMap 对象内的 value。通过这种方式，<strong>避免资源在多线程间共享</strong>。</p><h3 id="Entry对象中使用WeakReference来保存ThreadLocal，防止出现内存泄露的情况"><a href="#Entry对象中使用WeakReference来保存ThreadLocal，防止出现内存泄露的情况" class="headerlink" title="Entry对象中使用WeakReference来保存ThreadLocal，防止出现内存泄露的情况"></a>Entry对象中使用WeakReference来保存ThreadLocal，防止出现内存泄露的情况</h3><p>这样是为了防止线程里面的ThreadLocal使用完毕了，但是线程还在运行，这时如果这个传递的对象很大，又不能被回收，可能造成OOM</p><h3 id="自定义实现ThreadLocal"><a href="#自定义实现ThreadLocal" class="headerlink" title="自定义实现ThreadLocal"></a>自定义实现ThreadLocal</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Thread, T&gt; values = <span class="keyword">new</span> java.util.WeakHashMap&lt;Thread, T&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        values.put(Thread.currentThread(), value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> values.get(Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可以完成ThreadLocal功能的，但是在性能上却不是最优的。毕竟多线程访问ThreadLocal的map对象会导致并发冲突，用synchronized加锁会导致性能上的损失。</p></li><li><p>因此，JDK7里是将values这个Map对象保存在线程中，这样每个线程去取自己的数据，就不需要加锁保护的</p></li><li><p>```java<br>public class Thread {</p><pre><code>ThreadLocal.ThreadLocalMap threadLocals = null;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 简述 CAS 原理，什么是 ABA 问题，怎么解决？</span><br><span class="line"></span><br><span class="line"> CAS 操作——Compare &amp; Set，或是 Compare &amp; Swap，现在几乎所有的 CPU 指令都支持 CAS 的原子操作。</span><br><span class="line"></span><br><span class="line">&gt; java.util.concurrent.atomic 包下的类大多是使用 CAS 操作来实现的(AtomicInteger,AtomicBoolean,AtomicLong)。</span><br><span class="line">&gt;</span><br><span class="line">&gt; cas 是一种基于锁的操作，而且是乐观锁。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 乐观锁采取了一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加 version 来获取数据，性能较悲观锁有很大的提高。</span><br><span class="line"></span><br><span class="line">AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</span><br><span class="line"></span><br><span class="line">### CAS的原理</span><br><span class="line"></span><br><span class="line">拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个volatile变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</span><br><span class="line"></span><br><span class="line">### ABA 问题：</span><br><span class="line"></span><br><span class="line">比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。从 Java1.5 开始 JDK 的 atomic包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。</span><br><span class="line"></span><br><span class="line">AtomicStampReference在cas的基础上增加了一个标记stamp(== version)</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">//AtomicStampReference:</span><br><span class="line">public boolean compareAndSet(V   expectedReference,</span><br><span class="line">                                 V   newReference,</span><br><span class="line">                                 int expectedStamp,</span><br><span class="line">                                 int newStamp)</span><br></pre></td></tr></table></figure></li></ul><h2 id="简述常见的工厂模式以及单例模式的使用场景"><a href="#简述常见的工厂模式以及单例模式的使用场景" class="headerlink" title="简述常见的工厂模式以及单例模式的使用场景"></a>简述常见的工厂模式以及<a href="https://chankeitin.github.io/2021/11/21/Java%C2%B7JVM%C2%B7JUC(%E4%BA%8C)/">单例模式的使用场景</a></h2><ul><li><p>简单工厂模式</p><ul><li><p>用来生产同一等级结构中的任意产品（对于增加新的产品，需要扩展已有代码）。</p></li><li><p>```java<br>public class CarFactory {  </p><pre><code>// 方法一   public static Car getCar(String car)&#123;     if(car.equals(&quot;五菱&quot;))&#123;            return new WuLing();      &#125;else if(car.equals(&quot;特斯拉&quot;))&#123;          return new Tesla();         &#125;else &#123;         return null;     &#125; &#125; // 方法二 public static Car getWuLing()&#123;    return new WuLing(); &#125;public static Car getTesla()&#123;     return new Tesla();   &#125;&#125;</code></pre><p>public class Consumer { </p><pre><code>public static void main(String[] args) &#123;         // 接口，所有实现类        // Car car=new WuLing();    // Car car2=new Tesla();      // car.name();    // car2.name();       Car car = CarFactory.getCar(&quot;五菱&quot;);        Car car2 = CarFactory.getCar(&quot;特斯拉&quot;);        car.name();     car2.name();&#125;&#125;</code></pre><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- 工厂方法模式</span><br><span class="line"></span><br><span class="line">  - 用来生产同一等级结构中的固定产品（支持增加任意产品）。</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    public interface CarFactory &#123;    </span><br><span class="line">        Car getCar();</span><br><span class="line">    &#125;</span><br><span class="line">    public class TeslaFactory implements CarFactory &#123;  </span><br><span class="line">        public Car getCar() &#123;  </span><br><span class="line">            return new Tesla();</span><br><span class="line">        &#125;&#125;</span><br><span class="line">    public class WuLingFactory implements CarFactory &#123;    </span><br><span class="line">        @Override</span><br><span class="line">        public Car getCar() &#123;  </span><br><span class="line">            return new WuLing();   </span><br><span class="line">        &#125;&#125;</span><br><span class="line">    public class Consumer &#123;</span><br><span class="line">        public static void main(String[] args) &#123;   </span><br><span class="line">            Car car = new WuLingFactory().getCar();  </span><br><span class="line">            Car car1 = new TeslaFactory().getCar();   </span><br><span class="line">            car.name(); </span><br><span class="line">            car1.name(); </span><br><span class="line">        &#125;&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>抽象工厂模式</p><ul><li><p>围绕一个超级工厂创建其他工厂。该超级工厂称为其他工厂的工厂。</p></li><li><p>```java<br>public interface Factory {</p><pre><code>Fridge createFridge();AirConditioner createAirConditioner();Fan createFan();</code></pre><p>}</p><p>public class MediaFactory implements Factory{</p><pre><code>@Overridepublic Fridge createFridge() &#123;    // TODO Auto-generated method stub    return new MediaFridge();&#125;@Overridepublic AirConditioner createAirConditioner() &#123;    // TODO Auto-generated method stub    return new MediaAirConditioner();&#125;@Overridepublic Fan createFan() &#123;    // TODO Auto-generated method stub    return new MediaFan();&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Java 常见锁有哪些？ReetrantLock 是怎么实现的？</span><br><span class="line"></span><br><span class="line">![image-20220315105542953](https://s2.loli.net/2022/03/15/lIKSbhkgnHvcQYq.png)</span><br><span class="line"></span><br><span class="line">### ReetrantLock 是怎么实现的</span><br><span class="line"></span><br><span class="line">AQS:（AbstractQueuedSynchronizer）抽象的[队列](https://so.csdn.net/so/search?q=队列&amp;spm=1001.2101.3001.7020)式同步器。即将暂时获取不到锁的线程加入到队列中。</span><br><span class="line"></span><br><span class="line">**加锁**操作会对**state字段进行+1操作**，这里需要注意到AQS中很多内部变量的修饰符都是采用的[volitale](https://zhuanlan.zhihu.com/p/54327635),然后配合**CAS操作**来保证AQS本身的线程安全(因为AQS自己线程安全,基于它的衍生类才能更好地保证线程安全)。</span><br><span class="line"></span><br><span class="line">这里的state字段就是AQS类中的一个用volitale修饰的int变量，state字段初始化时，值为0。**表示目前没有任何线程持有该锁**。</span><br><span class="line"></span><br><span class="line">**当一个线程每次获得该锁时，值就会在原来的基础上加1，多次获锁就会多次加1**（指同一个线程），这里就是可重入。因为可以同一个线程多次获锁，只是对这个字段的值在原来基础上加1。</span><br><span class="line"></span><br><span class="line">**相反unlock操作也就是解锁操作**，实际是是调用AQS的release操作，而每执行一次这个操作，**就会对state字段在原来的基础上减1**，当state==0的时候就表示当前线程已经完全释放了该锁。那么就会如上文提到的那样去调用“唤醒”动作，去把在“线程等待队列中的线程”叫醒。</span><br><span class="line"></span><br><span class="line">![image-20220315140753378](https://s2.loli.net/2022/03/15/UbvwnGomDKC2LOI.png)</span><br><span class="line"></span><br><span class="line">## String 类能不能被继承？为什么？</span><br><span class="line"></span><br><span class="line">不能被继承，因为String类有final修饰符，而final修饰的类是不能被继承的。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    // 省略...　</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="HashMap-1-7-1-8-的实现区别"><a href="#HashMap-1-7-1-8-的实现区别" class="headerlink" title="HashMap 1.7 / 1.8 的实现区别"></a>HashMap 1.7 / 1.8 的实现区别</h2><h3 id="结构区别："><a href="#结构区别：" class="headerlink" title="结构区别："></a>结构区别：</h3><p><strong>Jdk1.7</strong></p><p><strong>底层数据结构是数组加链表</strong></p><p><img src="https://s2.loli.net/2022/03/15/qlUa1who52mVOgs.png" alt="image-20220315153330924"></p><p><strong>Jdk1.8</strong></p><p><strong>HashMap1.8的底层数据结构是数组+链表+红黑树。</strong></p><p><img src="https://s2.loli.net/2022/03/15/3uqlTOtmYv6dCXP.png" alt="image-20220315153454446"></p><ul><li>一般情况下，以默认容量16为例，阈值等于12就扩容，单条链表能达到长度为8的概率是相当低的，除非Hash攻击或者HashMap容量过大出现某些链表过长导致性能急剧下降的问题，红黑树主要是为了结果这种问题。</li></ul><h3 id="节点区别"><a href="#节点区别" class="headerlink" title="节点区别"></a>节点区别</h3><p><strong>Jdk1.8</strong></p><ul><li>hash是final修饰，也就是说hash值一旦确定，就不会再重新计算hash值了。</li><li>新增了一个TreeNode节点，为了转换为红黑树。</li></ul><p><strong>Jdk1.7</strong></p><ul><li>hash是可变的，因为有rehash的操作。</li></ul><h3 id="Hash算法区别"><a href="#Hash算法区别" class="headerlink" title="Hash算法区别"></a>Hash算法区别</h3><ul><li>1.8计算出来的结果只可能是一个，所以hash值设置为final修饰。</li><li>1.7会先判断这Object是否是String，如果是，则不采用String复写的hashcode方法，处于一个Hash碰撞安全问题的考虑</li></ul><h3 id="对Null的处理"><a href="#对Null的处理" class="headerlink" title="对Null的处理"></a>对Null的处理</h3><ul><li>Jdk1.7中，null是一个特殊的值，单独处理</li><li>Jdk1.8中，null的hash值计算结果为0，其他地方和普通的key没区别。</li></ul><h2 id="初始化的区别"><a href="#初始化的区别" class="headerlink" title="初始化的区别"></a>初始化的区别</h2><p><strong>Jdk1.7：</strong></p><ul><li>table是直接赋值给了一个空数组，在第一次put元素时初始化和计算容量。</li><li>table是单独定义的inflateTable（）初始化方法创建的。</li></ul><p><strong>Jdk1.8</strong></p><ul><li>的table没有赋值，属于懒加载，构造方式时已经计算好了新的容量位置（大于等于给定容量的最小2的次幂）。</li><li>table是resize（）方法创建的。</li></ul><h3 id="扩容的区别"><a href="#扩容的区别" class="headerlink" title="扩容的区别"></a>扩容的区别</h3><p><strong>Jdk1.7：</strong></p><ul><li>头插法，添加前先判断扩容，当前准备插入的位置不为空并且容量大于等于阈值才进行扩容，是<strong>两个条件</strong>！</li><li>扩容后可能会重新计算hash值。</li></ul><h3 id="节点插入"><a href="#节点插入" class="headerlink" title="节点插入"></a>节点插入</h3><p><strong>Jdk1.8：</strong></p><ul><li>尾插法，初始化时,添加节点结束之后和判断树化的时候都会去判断扩容。我们添加节点结束之后只要size大于阈值，就一定会扩容，<strong>是一个条件</strong>。</li><li>由于hash是final修饰，通过e.hash &amp; oldCap==0来判断新插入的位置是否为原位置。</li></ul><p><strong>区别</strong></p><ul><li>jdk1.7无论是resize的转移和新增节点createEntry，都是头插法</li><li>jdk1.8则都是尾插法，为什么这么做呢为了解决多线程的链表死循环问题。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>比较</th><th>HashMap1.7</th><th>HashMap1.8</th></tr></thead><tbody><tr><td>数据结构</td><td>数组+链表</td><td>数组+链表+红黑树</td></tr><tr><td>节点</td><td>Entry</td><td>Node TreeNode</td></tr><tr><td>Hash算法</td><td>较为复杂</td><td>异或hash右移16位</td></tr><tr><td>对Null的处理</td><td>单独写一个putForNull()方法处理</td><td>作为以一个Hash值为0的普通节点处理</td></tr><tr><td>初始化</td><td>赋值给一个空数组，put时初始化</td><td>没有赋值，懒加载，put时初始化</td></tr><tr><td>扩容</td><td>插入前扩容</td><td>插入后，初始化，树化时扩容</td></tr><tr><td>节点插入</td><td>头插法</td><td>尾插法</td></tr></tbody></table><p>题目答案均为转载，题目先后顺序按各大厂总出题次数排列！</p>]]></content>
      
      
      <categories>
          
          <category> 面试技巧 </category>
          
          <category> Java·JVM·JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java·JVM·JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转链表</title>
      <link href="/2022/03/10/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/03/10/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="https://s2.loli.net/2022/03/15/CjhEMW5QGD4lPNu.png" alt="image-20220315163133651"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">reverseLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode now = head;</span><br><span class="line">        <span class="keyword">while</span> (now!= <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//等号  左边指针，右边框</span></span><br><span class="line">            <span class="comment">//暂存</span></span><br><span class="line">            ListNode nextNode = now.next;</span><br><span class="line">            now.next = pre;</span><br><span class="line">            <span class="comment">//为下一次做准备</span></span><br><span class="line">            pre = now;</span><br><span class="line">            now = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试技巧 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RestTemplate请求Formdata格式接口与Json格式接口调用</title>
      <link href="/2022/03/08/RestTemplate%E8%AF%B7%E6%B1%82Formdata%E6%A0%BC%E5%BC%8F%E6%8E%A5%E5%8F%A3%E4%B8%8EJson%E6%A0%BC%E5%BC%8F%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8/"/>
      <url>/2022/03/08/RestTemplate%E8%AF%B7%E6%B1%82Formdata%E6%A0%BC%E5%BC%8F%E6%8E%A5%E5%8F%A3%E4%B8%8EJson%E6%A0%BC%E5%BC%8F%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="RestTemplate请求Formdata格式接口与Json格式接口调用"><a href="#RestTemplate请求Formdata格式接口与Json格式接口调用" class="headerlink" title="RestTemplate请求Formdata格式接口与Json格式接口调用"></a>RestTemplate请求Formdata格式接口与Json格式接口调用</h1><h2 id="依赖前提"><a href="#依赖前提" class="headerlink" title="依赖前提"></a>依赖前提</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--nacos服务注册--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.72<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>调用restTemplate注入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RestTemplate restTemplate;</span><br></pre></td></tr></table></figure><p><strong>关键是请求头的类型和调用时的参数类型</strong></p><h2 id="请求Formdata格式接口"><a href="#请求Formdata格式接口" class="headerlink" title="请求Formdata格式接口"></a>请求Formdata格式接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/formdata&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRestFormdata</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String url = <span class="string">&quot;https://xxxxxxx.cn/xxxxx/xxxx&quot;</span>;</span><br><span class="line">    String studentCode = <span class="string">&quot;2222x55x-1111-1111-0000-xxxxxxxxxxxx@123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">    HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">    MultiValueMap&lt;String, Object&gt; map = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//接口参数</span></span><br><span class="line">    map.add(<span class="string">&quot;studentCode&quot;</span>,studentCode);</span><br><span class="line">    <span class="comment">//头部类型</span></span><br><span class="line">    headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);</span><br><span class="line">    <span class="comment">//构造实体对象</span></span><br><span class="line">    HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; param = <span class="keyword">new</span> HttpEntity&lt;&gt;(map, headers);</span><br><span class="line">    System.out.println(<span class="string">&quot;testRest start&quot;</span>);</span><br><span class="line">    String msg = restTemplate.postForObject(url, param,String.class);</span><br><span class="line">    System.out.println(msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;成功&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="请求Json格式接口"><a href="#请求Json格式接口" class="headerlink" title="请求Json格式接口"></a>请求Json格式接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/json&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRestJson</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String url = <span class="string">&quot;https://xxxxxxx.cn/xxxxx/xxxx&quot;</span>;</span><br><span class="line">    ArrayList&lt;StudentQcpj&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    StudentQcpj studentQcpj = <span class="keyword">new</span> StudentQcpj(<span class="string">&quot;2222x55x-1111-1111-0000-xxxxxxxxxxxx&quot;</span>,</span><br><span class="line">            <span class="string">&quot;4404000&quot;</span>,<span class="string">&quot;11&quot;</span>,<span class="string">&quot;小明&quot;</span>,<span class="string">&quot;女&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    StudentQcpj studentQcpj2 = <span class="keyword">new</span> StudentQcpj(<span class="string">&quot;2222x55x-2222-2222-0000-xxxxxxxxxxxx&quot;</span>,</span><br><span class="line">            <span class="string">&quot;4404000&quot;</span>,<span class="string">&quot;22&quot;</span>,<span class="string">&quot;小红&quot;</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    list.add(studentQcpj);</span><br><span class="line">    list.add(studentQcpj2);</span><br><span class="line">    HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">    <span class="comment">//头部类型</span></span><br><span class="line">    headers.setContentType(MediaType.valueOf(<span class="string">&quot;application/json;UTF-8&quot;</span>));</span><br><span class="line">    <span class="comment">//构造实体对象</span></span><br><span class="line">    HttpEntity&lt;String&gt; param = <span class="keyword">new</span> HttpEntity&lt;&gt;(JSON.toJSONString(list), headers);</span><br><span class="line">    System.out.println(<span class="string">&quot;testRest start&quot;</span>);</span><br><span class="line">    JSONObject msg = restTemplate.postForObject(url, param, JSONObject.class);</span><br><span class="line">    System.out.println(msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;成功&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 后端 </category>
          
          <category> SpringBoot </category>
          
          <category> RestTemplate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> RestTemplate </tag>
            
            <tag> Springcloud-alibaba </tag>
            
            <tag> nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RestTemplate调用第三方接口报错：No instances avaliable for ip</title>
      <link href="/2022/03/06/RestTemplate%E8%B0%83%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8E%A5%E5%8F%A3%E6%8A%A5%E9%94%99%EF%BC%9ANo%20instances%20avaliable%20for%20ip/"/>
      <url>/2022/03/06/RestTemplate%E8%B0%83%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8E%A5%E5%8F%A3%E6%8A%A5%E9%94%99%EF%BC%9ANo%20instances%20avaliable%20for%20ip/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="RestTemplate调用第三方接口报错：No-instances-avaliable-for-ip"><a href="#RestTemplate调用第三方接口报错：No-instances-avaliable-for-ip" class="headerlink" title="RestTemplate调用第三方接口报错：No instances avaliable for ip"></a>RestTemplate调用第三方接口报错：No instances avaliable for ip</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>遇到的坑</strong>： restTemplate 调用外部接口 ,一直报错; No instances avaliable for ip地址</p><h2 id="分析原因"><a href="#分析原因" class="headerlink" title="分析原因"></a>分析原因</h2><p>在启动类的时候添加了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">(RestTemplateBuilder builder)</span></span>&#123;</span><br><span class="line">    RestTemplate restTemplate = builder.build();</span><br><span class="line">    <span class="keyword">return</span> restTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我使用这个bean去调用第三方接口, 重点在这里,<font color='red'> restTemplate加上<strong>负载均衡</strong>注解后,就会去注册中心寻找服务.</font>  因为是第三方的服务,所以当然报找不到实例;</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><h3 id="第三方调用"><a href="#第三方调用" class="headerlink" title="第三方调用"></a>第三方调用</h3><p>重新注入一个restTemplate bean; 修改名称,然后获取这个restTemplate去调用第三方接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(name=&quot;RestTemplate2&quot;)</span> <span class="comment">//不加负载均衡</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplateRemote</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="调用的类里面"><a href="#调用的类里面" class="headerlink" title="调用的类里面"></a>调用的类里面</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;RestTemplate2&quot;)</span></span><br><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testRest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String url = <span class="string">&quot;https://xxxx.xxxx.xxx.cn/xxxxx/student&quot;</span>;</span><br><span class="line">        String studentCode = <span class="string">&quot;0238a55e-2e5c-4866-bf79-xxxxxxxx8888@123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">        HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">        MultiValueMap&lt;String, Object&gt; map = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//接口参数</span></span><br><span class="line">        map.add(<span class="string">&quot;studentCode&quot;</span>,studentCode);</span><br><span class="line">        <span class="comment">//头部类型</span></span><br><span class="line">        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);</span><br><span class="line">        <span class="comment">//构造实体对象</span></span><br><span class="line">        HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; param = <span class="keyword">new</span> HttpEntity&lt;&gt;(map, headers);</span><br><span class="line">        System.out.println(<span class="string">&quot;testRest start&quot;</span>);</span><br><span class="line">        String msg = restTemplate.postForObject(url, param,String.class);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;成功&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="普通调用"><a href="#普通调用" class="headerlink" title="普通调用"></a>普通调用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="meta">@Bean(name=&quot;RestTemplate&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplateRemote</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>同一个nacos实例互相调用</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下单成功&quot;</span>);</span><br><span class="line">        String msg = restTemplate.getForObject(<span class="string">&quot;http://stock-service/stock/reduct&quot;</span>, String.class);</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 后端 </category>
          
          <category> SpringBoot </category>
          
          <category> RestTemplate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> RestTemplate </tag>
            
            <tag> Springcloud-alibaba </tag>
            
            <tag> nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springcloud-alibaba&amp;nacos的RestTemplate使用服务名报异常java.net.UnknownHostException</title>
      <link href="/2022/02/08/RestTemplate%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%90%8D%E6%8A%A5%E5%BC%82%E5%B8%B8java.net.UnknownHostException/"/>
      <url>/2022/02/08/RestTemplate%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%90%8D%E6%8A%A5%E5%BC%82%E5%B8%B8java.net.UnknownHostException/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Springcloud-alibaba-amp-nacos的RestTemplate使用服务名报异常java-net-UnknownHostException"><a href="#Springcloud-alibaba-amp-nacos的RestTemplate使用服务名报异常java-net-UnknownHostException" class="headerlink" title="Springcloud-alibaba&amp;nacos的RestTemplate使用服务名报异常java.net.UnknownHostException"></a>Springcloud-alibaba&amp;nacos的RestTemplate使用服务名报异常java.net.UnknownHostException</h1><blockquote><p>与CSDN<a href="https://blog.csdn.net/ChitinLoveJAVA/article/details/123260176">同步文章</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本地测试，springboot注册了nacos服务，然后一个springboot通过服务名（http://服务名/接口）调用服务，查看nacos控制台服务都已经注册了，但是无论我是否给RestTemplate添加@LoadBalanced注解，都是报UnknownHostException错误</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>在maven <code>pom.xml</code>中添加下面的依赖即可</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="pom依赖"><a href="#pom依赖" class="headerlink" title="pom依赖"></a>pom依赖</h3><p><img src="https://s2.loli.net/2022/03/05/f1CxMcWwnydXei4.png" alt="image-20220305234320833"></p><h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;xx成功&quot;</span>);</span><br><span class="line">        String msg = restTemplate.getForObject(<span class="string">&quot;http://stock-service/stock/reduct&quot;</span>, String.class);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;xx成功&quot;</span> + msg;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="SpringBootApplication"></a>SpringBootApplication</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(xxxApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">(RestTemplateBuilder builder)</span></span>&#123;</span><br><span class="line">        RestTemplate restTemplate = builder.build();</span><br><span class="line">        <span class="keyword">return</span> restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure><h2 id="版本对应"><a href="#版本对应" class="headerlink" title="版本对应"></a>版本对应</h2><p><strong>版本：</strong></p><table><thead><tr><th>SpringCloud-Alibaba</th><th>SpringBoot</th><th>SpringCloud</th></tr></thead><tbody><tr><td>2021.1</td><td>2.4.5</td><td>2020.0.1</td></tr></tbody></table><p><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">官方版本对应地址springcloud-alibaba&amp;springboot&amp;springcloud</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 后端 </category>
          
          <category> SpringBoot </category>
          
          <category> RestTemplate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RestTemplate </tag>
            
            <tag> Springcloud-alibaba </tag>
            
            <tag> nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷歌访问助手导致Chrome使其他梯子无法成功访问网页</title>
      <link href="/2022/01/20/%E8%B0%B7%E6%AD%8C%E8%AE%BF%E9%97%AE%E5%8A%A9%E6%89%8B%E5%AF%BC%E8%87%B4Chrome%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E7%BD%91%E9%A1%B5/"/>
      <url>/2022/01/20/%E8%B0%B7%E6%AD%8C%E8%AE%BF%E9%97%AE%E5%8A%A9%E6%89%8B%E5%AF%BC%E8%87%B4Chrome%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E7%BD%91%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="谷歌访问助手导致Chrome使其他梯子无法成功访问网页"><a href="#谷歌访问助手导致Chrome使其他梯子无法成功访问网页" class="headerlink" title="谷歌访问助手导致Chrome使其他梯子无法成功访问网页"></a>谷歌访问助手导致Chrome使其他梯子无法成功访问网页</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于谷歌访问助手插件卸载后无法代理这个问题，网上的解决方法极少，可以说很难找，特此出一篇文章来总结一下遇到过的困难。我是用的<code>Chrome</code>，两三年前曾经装过此插件，但如今已经用不了了。现在想移除它，用其他代理工具代替，但遇到很多的问题。</p><p>对于这个问题的详细描述:</p><blockquote><p>谷歌访问助手卸载后，使用其他软件代理访问，但在Chrome里面访问谷歌等网站时就会访问不到。要<strong>此插件存在</strong>并且打开了，这时候再使用其他的软件才能访问网站。</p></blockquote><h2 id="问题探寻与解决"><a href="#问题探寻与解决" class="headerlink" title="问题探寻与解决"></a>问题探寻与解决</h2><p>可能你的用户配置文件或者Chrome被破坏了。（个人认为）</p><p>请尝试右击Chrome的快捷方式，然后在目标结尾加一个 –user-data-dir=D:\Chrome 参数 <strong>注意： –前面有个空格</strong> ，这会让你的Chrome新起一个空白的配置文件启动全新的空白Chrome。<br><code>D:\Chrome</code>为你想设置的保存文件的路径</p><p><img src="https://s2.loli.net/2022/02/09/7I5R9EhkUuOnNpm.png" alt="image-20220209171211863"></p><blockquote><p>请注意：若你的Chrome目标路径中包含引号，请在引号末尾空格然后再加上上面的参数。</p></blockquote><p>如果没有问题，你想回到原有的配置，只需要清除快捷方式中的 –user-data-dir=D:\Chrome 参数即可。</p><p>打开以后测试是否开启代理之后能进入。</p><p>另外一个方法就是重装Chrome。配置也是云端账号同步就可以了（本人使用过成功）</p><h2 id="Chrome配置设置"><a href="#Chrome配置设置" class="headerlink" title="Chrome配置设置"></a>Chrome配置设置</h2><p>修改了之后等于是一个全新的Chrome，里面的配置都会消除</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>清除快捷方式中的 –user-data-dir=D:\Chrome 参数回到原来的配置，导出需要的书签、油猴的脚本等。换回新的Chrome重新导入。此方法只保留了书签，对于一些密码、扩展等还是要重新设置和安装。</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><blockquote><p>适合有条件的人</p></blockquote><p>登录chrome账号同步数据，方便快捷。但对于油猴的脚本等扩展里面的东西还是要手动导出。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://github.com/shadowsocks/shadowsocks-windows/issues/2655">chrome 无法使用代理，edge、chrome无痕模式、手机端均正常 #2655</a>.</p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2021/12/01/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/12/01/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><h2 id="Linux的文件系统目录配置"><a href="#Linux的文件系统目录配置" class="headerlink" title="Linux的文件系统目录配置"></a>Linux的文件系统目录配置</h2><blockquote><p>​     /home 每个账号在该目录下都有一个文件夹，进行数据的管理<br>​     /usr 有点像windows的program files和winNT结合的目录，主要包括系统的主要程序、本机端额外安装的软件、图形接口所需要的文档、额外的函数库、共享目录与文件等<br>​    /bin /usr/bin /usr/local/bin 存放执行挡 如可执行的指令等<br>​    /boot 存放linux开机会用到的文件<br>​    /dev 存放linux的任何装置和接口设备文档<br>​    /etc 存放系统设定文档 如账号密码文件、各种服务的起始档等<br>​    /lib /usr/lib /usr/local/lib 系统使用的函数库放置的目录<br>​    /mnt /media 是软盘和光盘预设挂载点的地方<br>​    /opt 主机额外安装软件所摆放的目录<br>​    /proc 该目录是一个虚拟档案系统，他放置的数据都是在内存中，所     以本身不占用任何的硬盘空间<br>​    /root 系统管理员的家目录<br>​    /sbin /usr/sbin /usr/local/sbin 放置一些只有系统管理员才能动用     的执行指令<br>​    /srv 一些服务启动之后，这些服务所需要取用的数据目录<br>​    /tmp 让一般使用者或者正在执行的程序暂时放置档案的地方<br>​    /var 主要针对系统执行过程中，常态性变动档案放置的目录</p></blockquote><h2 id="命令帮助"><a href="#命令帮助" class="headerlink" title="命令帮助"></a>命令帮助</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--help </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">man [命令]</span><br></pre></td></tr></table></figure><h2 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h2><h3 id="根据名称查找-目录下的filename-txt文件。"><a href="#根据名称查找-目录下的filename-txt文件。" class="headerlink" title="根据名称查找/目录下的filename.txt文件。"></a>根据名称查找/目录下的filename.txt文件。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find / -name filename.txt  </span><br></pre></td></tr></table></figure><h3 id="递归查找所有的xml文件"><a href="#递归查找所有的xml文件" class="headerlink" title="递归查找所有的xml文件"></a>递归查找所有的xml文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -name &quot;*.xml&quot; </span><br></pre></td></tr></table></figure><h3 id="递归查找所有文件内容中包含hello-world的xml文件"><a href="#递归查找所有文件内容中包含hello-world的xml文件" class="headerlink" title="递归查找所有文件内容中包含hello world的xml文件"></a>递归查找所有文件内容中包含hello world的xml文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -name &quot;*.xml&quot; |xargs grep &quot;hello world&quot;  </span><br></pre></td></tr></table></figure><h3 id="查找所以有的包含spring的xml文件"><a href="#查找所以有的包含spring的xml文件" class="headerlink" title="查找所以有的包含spring的xml文件"></a>查找所以有的包含spring的xml文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -H &#x27;spring&#x27; *.xml  </span><br></pre></td></tr></table></figure><h3 id="删除文件大小为零的文件"><a href="#删除文件大小为零的文件" class="headerlink" title="删除文件大小为零的文件"></a>删除文件大小为零的文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find ./ -size 0 | xargs rm -f &amp;  </span><br></pre></td></tr></table></figure><h3 id="查找当前目录中的所有jar文件"><a href="#查找当前目录中的所有jar文件" class="headerlink" title="查找当前目录中的所有jar文件"></a>查找当前目录中的所有jar文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l | grep &#x27;.jar&#x27;  </span><br></pre></td></tr></table></figure><h3 id="显示所有以d开头的文件中包含test的行。"><a href="#显示所有以d开头的文件中包含test的行。" class="headerlink" title="显示所有以d开头的文件中包含test的行。"></a>显示所有以d开头的文件中包含test的行。</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &#x27;test&#x27; d*  </span><br></pre></td></tr></table></figure><h3 id="显示在aa，bb，cc文件中匹配test的行。"><a href="#显示在aa，bb，cc文件中匹配test的行。" class="headerlink" title="显示在aa，bb，cc文件中匹配test的行。"></a>显示在aa，bb，cc文件中匹配test的行。</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &#x27;test&#x27; aa bb cc  </span><br></pre></td></tr></table></figure><h3 id="显示所有包含每个字符串至少有5个连续小写字符的字符串的行。"><a href="#显示所有包含每个字符串至少有5个连续小写字符的字符串的行。" class="headerlink" title="显示所有包含每个字符串至少有5个连续小写字符的字符串的行。"></a>显示所有包含每个字符串至少有5个连续小写字符的字符串的行。</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &#x27;[a-z]\&#123;5\&#125;&#x27; aa  </span><br></pre></td></tr></table></figure><h2 id="查看一个程序是否运行"><a href="#查看一个程序是否运行" class="headerlink" title="查看一个程序是否运行"></a>查看一个程序是否运行</h2><p>查看所有有关tomcat的进程</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef|grep tomcat  </span><br></pre></td></tr></table></figure><h2 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h2><p>终止线程号位19979的进程</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kill -9 19979  </span><br></pre></td></tr></table></figure><h2 id="查看文件，包含隐藏文件"><a href="#查看文件，包含隐藏文件" class="headerlink" title="查看文件，包含隐藏文件"></a>查看文件，包含隐藏文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -al </span><br></pre></td></tr></table></figure><h2 id="当前工作目录"><a href="#当前工作目录" class="headerlink" title="当前工作目录"></a>当前工作目录</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pwd </span><br></pre></td></tr></table></figure><h2 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h2><h3 id="复制文件-1"><a href="#复制文件-1" class="headerlink" title="复制文件"></a>复制文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp source dest  </span><br></pre></td></tr></table></figure><h3 id="递归复制整个文件夹"><a href="#递归复制整个文件夹" class="headerlink" title="递归复制整个文件夹"></a>递归复制整个文件夹</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -r sourceFolder targetFolder  </span><br></pre></td></tr></table></figure><h3 id="远程拷贝"><a href="#远程拷贝" class="headerlink" title="远程拷贝"></a>远程拷贝</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp sourecFile romoteUserName@remoteIp:remoteAddr  </span><br></pre></td></tr></table></figure><h2 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir newfolder </span><br></pre></td></tr></table></figure><h2 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h2><h3 id="删除空目录"><a href="#删除空目录" class="headerlink" title="删除空目录"></a>删除空目录</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rmdir deleteEmptyFolder  </span><br></pre></td></tr></table></figure><h3 id="递归删除目录中所有内容"><a href="#递归删除目录中所有内容" class="headerlink" title="递归删除目录中所有内容"></a>递归删除目录中所有内容</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf deleteFile  </span><br></pre></td></tr></table></figure><h2 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv /temp/movefile /targetFolder </span><br></pre></td></tr></table></figure><h2 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv oldNameFile newNameFile </span><br></pre></td></tr></table></figure><h2 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su -username </span><br></pre></td></tr></table></figure><h2 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h2><p>file.java 的权限</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 777 file.java </span><br></pre></td></tr></table></figure><p>r表示读、w表示写、x表示可执行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-rwxrwxrwx， </span><br></pre></td></tr></table></figure><h2 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -czf test.tar.gz /test1 /test2 </span><br></pre></td></tr></table></figure><h2 id="列出压缩文件列表"><a href="#列出压缩文件列表" class="headerlink" title="列出压缩文件列表"></a>列出压缩文件列表</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -tzf test.tar.gz </span><br></pre></td></tr></table></figure><h2 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xvzf test.tar.gz </span><br></pre></td></tr></table></figure><h2 id="查看文件头10行"><a href="#查看文件头10行" class="headerlink" title="查看文件头10行"></a>查看文件头10行</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">head -n 10 example.txt </span><br></pre></td></tr></table></figure><h2 id="查看文件尾10行"><a href="#查看文件尾10行" class="headerlink" title="查看文件尾10行"></a>查看文件尾10行</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -n 10 example.txt </span><br></pre></td></tr></table></figure><h2 id="查看日志类型文件"><a href="#查看日志类型文件" class="headerlink" title="查看日志类型文件"></a>查看日志类型文件</h2><p>这个命令会自动显示新增内容，屏幕只显示10行内容的（可设置）。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -f exmaple.log  </span><br></pre></td></tr></table></figure><h2 id="使用超级管理员身份执行命令"><a href="#使用超级管理员身份执行命令" class="headerlink" title="使用超级管理员身份执行命令"></a>使用超级管理员身份执行命令</h2><p>使用管理员身份删除文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rm a.txt  </span><br></pre></td></tr></table></figure><h2 id="查看端口占用情况"><a href="#查看端口占用情况" class="headerlink" title="查看端口占用情况"></a>查看端口占用情况</h2><p>查看端口8080的使用情况</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -tln | grep 8080  </span><br></pre></td></tr></table></figure><h2 id="查看端口属于哪个程序"><a href="#查看端口属于哪个程序" class="headerlink" title="查看端口属于哪个程序"></a>查看端口属于哪个程序</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsof -i :8080 </span><br></pre></td></tr></table></figure><h2 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h2><p>查看java进程</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps aux|grep java  </span><br></pre></td></tr></table></figure><p>查看所有进程</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps aux  </span><br></pre></td></tr></table></figure><h2 id="以树状图列出目录的内容"><a href="#以树状图列出目录的内容" class="headerlink" title="以树状图列出目录的内容"></a>以树状图列出目录的内容</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tree a </span><br></pre></td></tr></table></figure><h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://file.tgz  </span><br><span class="line">curl http://file.tgz </span><br></pre></td></tr></table></figure><h2 id="网络检测"><a href="#网络检测" class="headerlink" title="网络检测"></a>网络检测</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ping www.baidu.com </span><br></pre></td></tr></table></figure><h2 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh userName@ip </span><br></pre></td></tr></table></figure><h2 id="打印信息"><a href="#打印信息" class="headerlink" title="打印信息"></a>打印信息</h2><p>打印java home环境变量的值</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $JAVA_HOME  </span><br></pre></td></tr></table></figure><h2 id="查看命令"><a href="#查看命令" class="headerlink" title="查看命令"></a>查看命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/filesystems</span><br><span class="line">cat -n :显示文件所有内容，-n表示打印行号</span><br></pre></td></tr></table></figure><h2 id="查看目录的使用情况命令"><a href="#查看目录的使用情况命令" class="headerlink" title="查看目录的使用情况命令"></a>查看目录的使用情况命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">df -h //以G为单位查看</span><br><span class="line">df -m //以M为单位查看</span><br></pre></td></tr></table></figure><h2 id="查看文件或目录大小"><a href="#查看文件或目录大小" class="headerlink" title="查看文件或目录大小"></a>查看文件或目录大小</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">du -sh</span><br></pre></td></tr></table></figure><h2 id="目录的切换命令"><a href="#目录的切换命令" class="headerlink" title="目录的切换命令"></a>目录的切换命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ..</span><br><span class="line">cd ~</span><br><span class="line">cd /home</span><br><span class="line">cd ./home</span><br></pre></td></tr></table></figure><h2 id="打印当前的路径"><a href="#打印当前的路径" class="headerlink" title="打印当前的路径"></a>打印当前的路径</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure><h2 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h2><h3 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">comm -1 file1 file2 比较两个文件的内容只删除 &#x27;file1&#x27; 所包含的内容 </span><br><span class="line">comm -2 file1 file2 比较两个文件的内容只删除 &#x27;file2&#x27; 所包含的内容 </span><br><span class="line">comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 </span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sort file1 file2 排序两个文件的内容 </span><br><span class="line">sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份) </span><br><span class="line">sort file1 file2 | uniq -u 删除交集，留下其他的行 </span><br><span class="line">sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件) </span><br></pre></td></tr></table></figure><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">paste file1 file2 合并两个文件或两栏的内容 </span><br><span class="line">paste -d &#x27;+&#x27; file1 file2 合并两个文件或两栏的内容，中间用&quot;+&quot;区分 </span><br></pre></td></tr></table></figure><h2 id="创建目录-1"><a href="#创建目录-1" class="headerlink" title="创建目录"></a>创建目录</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir (-m 参数可以预设权限 -p参数可以递归的创建目录)</span><br></pre></td></tr></table></figure><h2 id="删除目录-1"><a href="#删除目录-1" class="headerlink" title="删除目录"></a>删除目录</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rmdir（只能删除空目录）</span><br><span class="line">如果连同内容都删除采用 rm -rf 命令</span><br></pre></td></tr></table></figure><h2 id="取文件名"><a href="#取文件名" class="headerlink" title="取文件名"></a>取文件名</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">basename</span><br></pre></td></tr></table></figure><h2 id="取得路径名"><a href="#取得路径名" class="headerlink" title="取得路径名"></a>取得路径名</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dirname</span><br></pre></td></tr></table></figure><h2 id="Linux档的搜索"><a href="#Linux档的搜索" class="headerlink" title="Linux档的搜索"></a>Linux档的搜索</h2><blockquote><p>whereis locate(这两者是直接搜索数据库，速度快) </p><p>find（搜索硬盘，速度较慢，但数据最齐全） </p><p>which（用来搜索执行挡$Path设置的目录）</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">which ls</span><br><span class="line">whereis file  //找出file的位置</span><br><span class="line">locate file   //查找所有目录下的文件</span><br><span class="line">find file     //查看当前目录下的所有文件</span><br></pre></td></tr></table></figure><h2 id="同时显示两个文件的差异"><a href="#同时显示两个文件的差异" class="headerlink" title="同时显示两个文件的差异"></a>同时显示两个文件的差异</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">diff -c file1 file2</span><br><span class="line">diff -y file1 file2  //以并列的方式显示两个文件的差异</span><br></pre></td></tr></table></figure><h2 id="文档链接"><a href="#文档链接" class="headerlink" title="文档链接"></a>文档链接</h2><blockquote><p>软连接：源文件消失，目的文件也消失<br>硬连接： 其中一个修改，另一个也修改，但删除源文件时，目的文件不删除</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">In file1 file2     //建立file1的链接，命名为file2</span><br><span class="line">In -s file1 file2  //建立file1的软连接</span><br></pre></td></tr></table></figure><h2 id="Linux查看CPU运行状态"><a href="#Linux查看CPU运行状态" class="headerlink" title="Linux查看CPU运行状态"></a>Linux查看CPU运行状态</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mpstat            //mpstat 不但能查看所有CPU的平均信息，还能查看指定CPU的信息。</span><br><span class="line"></span><br><span class="line">vmstat            //只能查看所有CPU的平均信息；查看cpu队列信息；</span><br><span class="line">vmstat -n 3       //每隔3秒刷新一次</span><br><span class="line">vmstat 2 3        //每隔2秒刷新一次，共刷新3次</span><br><span class="line"></span><br><span class="line">iostat            //只能查看所有CPU的平均信息。</span><br><span class="line">iostat -c         // -c 选项，该选项的作用是仅显示系统 CPU 的运行情况</span><br><span class="line"></span><br><span class="line">sar               //与mpstat 一样，不但能查看CPU的平均信息，还能查看指定CPU的信息。</span><br><span class="line">sar -u 3 5        //每 3 秒统计一次，统计 5 次</span><br><span class="line"></span><br><span class="line">top               //显示的信息同ps接近，但是top可以了解到CPU消耗，可以根据用户指定的时间来更新显示。</span><br><span class="line"></span><br><span class="line">uptime            //uptime 命令是监控系统性能最常用的一个命令，主要用来统计系统当前的运行状况</span><br></pre></td></tr></table></figure><h3 id="sar-命令的基本格式"><a href="#sar-命令的基本格式" class="headerlink" title="sar 命令的基本格式"></a>sar 命令的基本格式</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sar [options] [-o filename] interval [count]</span><br></pre></td></tr></table></figure><ul><li>-o filename：其中，filename 为文件名，此选项表示将命令结果以二进制格式存放在文件中；</li><li>interval：表示采样间隔时间，该参数必须手动设置；</li><li>count：表示采样次数，是可选参数，其默认值为 1；</li><li>options：为命令行选项，由于 sar 命令提供的选项很多，这里不再一一介绍，仅列举出常用的一些选项及对应的功能，如表 1 所示。</li></ul><table><thead><tr><th>sar</th><th>功能</th></tr></thead><tbody><tr><td>-A</td><td>显示系统所有资源设备（CPU、内存、磁盘）的运行状况。</td></tr><tr><td>-u</td><td>显示系统所有 CPU 在采样时间内的负载状态。</td></tr><tr><td>-P</td><td>显示当前系统中指定 CPU 的使用情况。</td></tr><tr><td>-d</td><td>显示系统所有硬盘设备在采样时间内的使用状态。</td></tr><tr><td>-r</td><td>显示系统内存在采样时间内的使用情况。</td></tr><tr><td>-b</td><td>显示缓冲区在采样时间内的使用情况。</td></tr><tr><td>-v</td><td>显示 inode 节点、文件和其他内核表的统计信息。</td></tr><tr><td>-n</td><td>显示网络运行状态，此选项后可跟 DEV（显示网络接口信息）、EDEV（显示网络错误的统计数据）、SOCK（显示套接字信息）和 FULL（等同于使用 DEV、EDEV和SOCK）等，有关更多的选项，可通过执行 man sar 命令查看。</td></tr><tr><td>-q</td><td>显示运行列表中的进程数、进程大小、系统平均负载等。</td></tr><tr><td>-R</td><td>显示进程在采样时的活动情况。</td></tr><tr><td>-y</td><td>显示终端设备在采样时间的活动情况。</td></tr><tr><td>-w</td><td>显示系统交换活动在采样时间内的状态。</td></tr></tbody></table><h3 id="vmstat-命令的基本格式"><a href="#vmstat-命令的基本格式" class="headerlink" title="vmstat 命令的基本格式"></a>vmstat 命令的基本格式</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vmstat [-a] [刷新延时 刷新次数]</span><br><span class="line">[root@localhost ~]# vmstat [选项] </span><br></pre></td></tr></table></figure><p>-a 的含义是用 inact/active（活跃与否） 来取代 buff/cache 的内存输出信息。</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-fs</td><td>-f：显示从启动到目前为止，系统复制（fork）的程序数，此信息是从 /proc/stat 中的 processes 字段中取得的。 -s：将从启动到目前为止，由一些事件导致的内存变化情况列表说明。</td></tr><tr><td>-S 单位</td><td>令输出的数据显示单位，例如用 K/M 取代 bytes 的容量。</td></tr><tr><td>-d</td><td>列出硬盘有关读写总量的统计表。</td></tr><tr><td>-p 分区设备文件名</td><td>查看硬盘分区的读写情况。</td></tr></tbody></table><h2 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arch 显示机器的处理器架构</span><br><span class="line">uname -m 显示机器的处理器架构</span><br><span class="line">uname -r 显示正在使用的内核版本 </span><br><span class="line">dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI) </span><br><span class="line">hdparm -i /dev/hda 罗列一个磁盘的架构特性 </span><br><span class="line">hdparm -tT /dev/sda 在磁盘上执行测试性读取操作 </span><br><span class="line">cat /proc/cpuinfo 显示CPU info的信息 </span><br><span class="line">cat /proc/interrupts 显示中断 </span><br><span class="line">cat /proc/meminfo 校验内存使用 </span><br><span class="line">cat /proc/swaps 显示哪些swap被使用 </span><br><span class="line">cat /proc/version 显示内核的版本 </span><br><span class="line">cat /proc/net/dev 显示网络适配器及统计 </span><br><span class="line">cat /proc/mounts 显示已加载的文件系统 </span><br><span class="line">lspci -tv 罗列 PCI 设备 </span><br><span class="line">lsusb -tv 显示 USB 设备 </span><br><span class="line">date 显示系统日期 </span><br><span class="line">cal 2007 显示2007年的日历表 </span><br><span class="line">date 041217002007.00 设置日期和时间 - 月日时分年.秒 </span><br><span class="line">clock -w 将时间修改保存到 BIOS </span><br></pre></td></tr></table></figure><h2 id="系统的关机、重启以及登出"><a href="#系统的关机、重启以及登出" class="headerlink" title="系统的关机、重启以及登出"></a><strong>系统的关机、重启以及登出</strong></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shutdown -h now 关闭系统</span><br><span class="line">init 0 关闭系统</span><br><span class="line">telinit 0 关闭系统</span><br><span class="line">shutdown -h hours:minutes &amp; 按预定时间关闭系统 </span><br><span class="line">shutdown -c 取消按预定时间关闭系统 </span><br><span class="line">shutdown -r now 重启</span><br><span class="line">reboot 重启</span><br><span class="line">logout 注销 </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试技巧 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java·JVM·JUC(二)</title>
      <link href="/2021/11/21/Java%C2%B7JVM%C2%B7JUC(%E4%BA%8C)/"/>
      <url>/2021/11/21/Java%C2%B7JVM%C2%B7JUC(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Java·JVM·JUC-二"><a href="#Java·JVM·JUC-二" class="headerlink" title="Java·JVM·JUC(二)"></a>Java·JVM·JUC(二)</h1><h2 id="实现单例设计模式（懒汉，饿汉）"><a href="#实现单例设计模式（懒汉，饿汉）" class="headerlink" title="实现单例设计模式（懒汉，饿汉）"></a>实现单例设计模式（懒汉，饿汉）</h2><h3 id="单例模式的三大特性"><a href="#单例模式的三大特性" class="headerlink" title="单例模式的三大特性"></a>单例模式的三大特性</h3><ul><li>单例类只有一个实例。</li><li>单例类必须自己实例化自己。</li><li>单例类需要向外提供实例。</li></ul><h3 id="饿汉模式-立即加载"><a href="#饿汉模式-立即加载" class="headerlink" title="饿汉模式(立即加载)"></a>饿汉模式(立即加载)</h3><p>立即加载就是使用类的时候已经将对象创建完毕</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将自身实例化对象设置为一个属性，并用static、final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态方法返回该实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉模式-延迟加载"><a href="#懒汉模式-延迟加载" class="headerlink" title="懒汉模式(延迟加载)"></a>懒汉模式(延迟加载)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将自身实例化对象设置为一个属性，并用static修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态方法返回该实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉模式-线程安全"><a href="#懒汉模式-线程安全" class="headerlink" title="懒汉模式-线程安全"></a>懒汉模式-线程安全</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将自身实例化对象设置为一个属性，并用static修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态方法返回该实例，加synchronized关键字实现同步</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DCL双检查锁机制"><a href="#DCL双检查锁机制" class="headerlink" title="DCL双检查锁机制"></a>DCL双检查锁机制</h3><p> 需要用到关键字volatile，防止指令重排。如果不用volatile关键字，就会和线程不安全情形一样，在if判断那会有并发。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123; <span class="comment">//双重检查</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123; <span class="comment">//判断是否实例化</span></span><br><span class="line"><span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance; <span class="comment">//否则直接return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//静态内部类,包含一个静态属性：Singleton</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对外公有的静态方法，直接返回SingletonInstance.INSTANCE</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">INSTANCE; <span class="comment">//属性</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;记得三连~&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="和-equals-的区别？"><a href="#和-equals-的区别？" class="headerlink" title="== 和 equals() 的区别？"></a>== 和 equals() 的区别？</h2><p>== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)</p><p>equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><ul><li><p>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</p></li><li><p>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aa==bb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a==b&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aEQb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池是如何实现的？简述线程池的任务策略"><a href="#线程池是如何实现的？简述线程池的任务策略" class="headerlink" title="线程池是如何实现的？简述线程池的任务策略"></a>线程池是如何实现的？简述线程池的任务策略</h2><h2 id="线程池如何实现"><a href="#线程池如何实现" class="headerlink" title="线程池如何实现"></a>线程池如何实现</h2><p>   假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。</p><p>如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。<br>        一个线程池包括以下四个基本组成部分：</p><ol><li><p>线程池管理器（ThreadPool）：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；</p></li><li><p>工作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；</p></li><li><p>任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等；</p></li><li><p>任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。任务队列的实现可以是一个简单的ArrayDeque 双端队列，其核心方法是对任务的取出与暂存操作，当需要取出一个任务时，必须进行非空判断，可以通过添加锁机制，例如Reetrantlock来实现锁空队列，当任务被暂存时，通过Condition条件唤醒需要取出任务的线程继续执行任务，从而实现类似生产者与消费者之间的平衡关系。</p></li></ol><p><img src="https://i.loli.net/2021/11/21/GtXAJCnyuvlF2W6.png" alt="image-20211121153621127"></p><h4 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h4><p><img src="https://i.loli.net/2021/11/21/ANZ8CmVzBov4OxI.png" alt="image-20211121153128619"></p><h4 id="任务暂存"><a href="#任务暂存" class="headerlink" title="任务暂存"></a>任务暂存</h4><p>阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><p><img src="https://i.loli.net/2021/11/21/7entEsRQjNiH8rY.png" alt="image-20211121153221968"></p><h4 id="任务拒绝"><a href="#任务拒绝" class="headerlink" title="任务拒绝"></a>任务拒绝</h4><p>任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/11/21/9OIn1fYkVixHw4M.png" alt="image-20211121153510975"></p><h4 id="worker工作线程"><a href="#worker工作线程" class="headerlink" title="worker工作线程"></a>worker工作线程</h4><p>线程池的工作线程worker实现了Runnable类</p><p><img src="https://i.loli.net/2021/11/21/aW1hb3ZYKHwyjOV.png" alt="image-20211121153340298"></p><h2 id="简述-Java-的反射机制及其应用场景"><a href="#简述-Java-的反射机制及其应用场景" class="headerlink" title="简述 Java 的反射机制及其应用场景"></a>简述 Java 的反射机制及其应用场景</h2><p> <strong>JAVA反射机制</strong>是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法；这种动态获取的以及动态调用对象的方法的功能称为Java的反射机制。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；</p><p>②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：</p><ol><li><p>将程序内所有 XML 或 Properties 配置文件加载入内存中;</p></li><li><p>Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息;</p></li><li><p>使用反射机制，根据这个字符串获得某个类的Class实例;</p></li><li><p>动态配置实例的属性</p></li></ol><h2 id="简述-Spring-AOP-的原理"><a href="#简述-Spring-AOP-的原理" class="headerlink" title="简述 Spring AOP 的原理"></a>简述 Spring AOP 的原理</h2><p>AOP（Aspect Oriented Programming）是基于切面编程的，可无侵入的在原本功能的切面层添加自定义代码，一般用于日志收集、权限认证等场景。减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</p><ul><li>Jointpoint（连接点）：具体的切面点点抽象概念，可以是在字段、方法上，Spring中具体表现形式是PointCut（切入点），仅作用在方法上。</li><li>Advice（通知）: 在连接点进行的具体操作，如何进行增强处理的，分为前置、后置、异常、最终、环绕五种情况。</li><li>目标对象：被AOP框架进行增强处理的对象，也被称为被增强的对象。</li><li>AOP代理：AOP框架创建的对象，简单的说，代理就是对目标对象的加强。Spring中的AOP代理可以是JDK动态代理，也可以是CGLIB代理。</li><li>Weaving（织入）：将增强处理添加到目标对象中，创建一个被增强的对象的过程</li></ul><p><strong>总结为一句话就是：在目标对象（target object）的某些方法（jointpoint）添加不同种类的操作（通知、增强操处理），最后通过某些方法（weaving、织入操作）实现一个新的代理目标对象。</strong></p><h2 id="JVM-内存是如何对应到操作系统内存的？"><a href="#JVM-内存是如何对应到操作系统内存的？" class="headerlink" title="JVM 内存是如何对应到操作系统内存的？"></a>JVM 内存是如何对应到操作系统内存的？</h2><p>原来jvm的设计的模型其实就是操作系统的模型，基于操作系统的角度，jvm就是个该死的java.exe/javaw.exe，也就是一个应用，而基于class文件来说，jvm就是个操作系统，而jvm的方法区，也就相当于操作系统的硬盘区，所以你知道我为什么喜欢叫他permanent区吗，因为这个单词是永久的意思，也就是永久区，我们的磁盘就是不断电的永久区嘛，是一样的意思啊，多好对应啊。而java栈和操作系统栈是一致的，无论是生长方向还是管理的方式，至于堆嘛，虽然概念上一致目标也一致，分配内存的方式也一直(new,或者malloc等等)，但是由于他们的管理方式不同，jvm是gc回收，而操作系统是程序员手动释放</p><p><img src="https://i.loli.net/2021/11/21/n9fdbgaLrACipMJ.png" alt="image-20211121155136200"></p><h2 id="简述-Spring-bean-的生命周期"><a href="#简述-Spring-bean-的生命周期" class="headerlink" title="简述 Spring bean 的生命周期"></a>简述 Spring bean 的生命周期</h2><p><img src="https://i.loli.net/2021/11/21/DwWfP1SQNVjuple.png" alt="image-20211121155453182"></p><h2 id="Java-中接口和抽象类的区别"><a href="#Java-中接口和抽象类的区别" class="headerlink" title="Java 中接口和抽象类的区别"></a>Java 中接口和抽象类的区别</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ul><li>接口和抽象类都不能被实例化，主要用于被其他类实现和继承。</li><li>接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。</li></ul><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><p><img src="https://i.loli.net/2021/11/21/GYtwqD3MSWxjdps.png" alt="image-20211121160120494"></p><h2 id="String，StringBuffer，StringBuilder-之间有什么区别？"><a href="#String，StringBuffer，StringBuilder-之间有什么区别？" class="headerlink" title="String，StringBuffer，StringBuilder 之间有什么区别？"></a>String，StringBuffer，StringBuilder 之间有什么区别？</h2><ol><li>可变性</li></ol><p>String类中使用字符数组保存字符串，private　final　char　value[]，所以<strong>string对象是不可变的</strong>。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，这<strong>两种对象都是可变的</strong>。</p><ol start="2"><li>线程安全性</li></ol><p>String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。<strong>StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的</strong>。<strong>StringBuilder并没有对方法进行加同步锁，所以是非线程安全的</strong>。</p><ul><li>以下源码中也可以看出就是多了一个synchronized 的区别</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuffer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Appendable</span>, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a string buffer with no characters in it and an</span></span><br><span class="line"><span class="comment">     * initial capacity of 16 characters.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.append(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.delete(start, end);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilder</span> <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">16</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.append(str);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.delete(start, end);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>性能</li></ol><p>每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><h3 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h3><p>如果要操作少量的数据用 ————————-String</p><p>单线程操作字符串缓冲区 下操作大量数据—StringBuilder</p><p>多线程操作字符串缓冲区 下操作大量数据—StringBuffer</p><p>题目答案均为转载，题目先后顺序按各大厂总出题次数排列！</p>]]></content>
      
      
      <categories>
          
          <category> 面试技巧 </category>
          
          <category> Java·JVM·JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java·JVM·JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity -请求的地址栏使用&quot;//&quot;报错</title>
      <link href="/2021/11/12/SpringSecurity%20-%E8%AF%B7%E6%B1%82%E7%9A%84%E5%9C%B0%E5%9D%80%E6%A0%8F%E4%BD%BF%E7%94%A8%E5%8F%8C%E6%96%9C%E6%9D%A0%E6%8A%A5%E9%94%99/"/>
      <url>/2021/11/12/SpringSecurity%20-%E8%AF%B7%E6%B1%82%E7%9A%84%E5%9C%B0%E5%9D%80%E6%A0%8F%E4%BD%BF%E7%94%A8%E5%8F%8C%E6%96%9C%E6%9D%A0%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="SpringSecurity-请求的地址栏使用”-“报错"><a href="#SpringSecurity-请求的地址栏使用”-“报错" class="headerlink" title="SpringSecurity -请求的地址栏使用”//“报错"></a>SpringSecurity -请求的地址栏使用”//“报错</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在使用 spring security 时，请求的地址栏使用 “//”的情况是后台报如下错误：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.security.web.firewall.RequestRejectedException: The request was rejected because the URL contained a potentially malicious String <span class="string">&quot;//&quot;</span></span><br><span class="line">at org.springframework.security.web.firewall.StrictHttpFirewall.rejectedBlacklistedUrls(StrictHttpFirewall.java:<span class="number">369</span>)</span><br><span class="line">at org.springframework.security.web.firewall.StrictHttpFirewall.getFirewalledRequest(StrictHttpFirewall.java:<span class="number">336</span>)</span><br><span class="line">at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:<span class="number">194</span>)</span><br></pre></td></tr></table></figure><h2 id="问题所在"><a href="#问题所在" class="headerlink" title="问题所在"></a>问题所在</h2><p>该错误发生的原因是 <code>SpringSecurity</code>设置了安全防护措施，在 <code>StrictHttpFirewall</code>类中设置了禁用，源码里面如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 因为这个allowUrlEncodedDoubleSlash 没有设置值.默认是false, 故不能识别 双 //</span></span><br><span class="line"><span class="comment"> * 而 FORBIDDEN_DOUBLE_FORWARDSLASH 和 FORBIDDEN_DOUBLE_FORWARDSLASH 是 SpringSecurity源码中设置的全局变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAllowUrlEncodedDoubleSlash</span><span class="params">(<span class="keyword">boolean</span> allowUrlEncodedDoubleSlash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (allowUrlEncodedDoubleSlash) &#123;</span><br><span class="line">            <span class="keyword">this</span>.urlBlacklistsRemoveAll(FORBIDDEN_DOUBLE_FORWARDSLASH);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.urlBlacklistsAddAll(FORBIDDEN_DOUBLE_FORWARDSLASH);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>需要在自己项目中的 <code>SpringSecurity</code>配置类中添加如下配置即可:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置地址栏不能识别 // 的情况</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpFirewall <span class="title">allowUrlEncodedSlashHttpFirewall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">StrictHttpFirewall firewall = <span class="keyword">new</span> StrictHttpFirewall();</span><br><span class="line"><span class="comment">//此处可添加别的规则,目前只设置 允许双 //</span></span><br><span class="line">firewall.setAllowUrlEncodedDoubleSlash(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">return</span> firewall;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 后端 </category>
          
          <category> SpringBoot </category>
          
          <category> SpringSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> SpringSecurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JWT中的ExpiredJwtException</title>
      <link href="/2021/11/11/JWT%E4%B8%AD%E7%9A%84ExpiredJwtException/"/>
      <url>/2021/11/11/JWT%E4%B8%AD%E7%9A%84ExpiredJwtException/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="JWT中的ExpiredJwtException"><a href="#JWT中的ExpiredJwtException" class="headerlink" title="JWT中的ExpiredJwtException"></a>JWT中的ExpiredJwtException</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原本是调用jwtUtil（jwt的工具类），传入一个token，判断是否过期，然而却抛io.jsonwebtoken.ExpiredJwtException异常了，而业务中还需要根据是否过期进行刷新token！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">io.jsonwebtoken.ExpiredJwtException: JWT expired at <span class="number">2021</span>-<span class="number">11</span>-11T14:<span class="number">48</span>:14Z. Current time: <span class="number">2021</span>-<span class="number">11</span>-11T14:<span class="number">48</span>:50Z, a difference of <span class="number">36843</span> milliseconds.  Allowed clock skew: <span class="number">0</span> milliseconds.</span><br><span class="line">at io.jsonwebtoken.impl.DefaultJwtParser.parse(DefaultJwtParser.java:<span class="number">385</span>)</span><br><span class="line">at io.jsonwebtoken.impl.DefaultJwtParser.parse(DefaultJwtParser.java:<span class="number">481</span>)</span><br><span class="line">at io.jsonwebtoken.impl.DefaultJwtParser.parseClaimsJws(DefaultJwtParser.java:<span class="number">541</span>)</span><br><span class="line">at com.smart.util.JwtUtil.parseJwt(JwtUtil.java:<span class="number">63</span>)</span><br><span class="line">at com.smart.util.JwtUtil.isTokenExpired(JwtUtil.java:<span class="number">93</span>)</span><br></pre></td></tr></table></figure><h2 id="问题所在"><a href="#问题所在" class="headerlink" title="问题所在"></a>问题所在</h2><p>根据报错堆栈信息找到了<code>DefaultJwtParser</code>类中，找到了问题的原因</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> allowSkew = <span class="keyword">this</span>.allowedClockSkewMillis &gt; <span class="number">0L</span>;</span><br><span class="line"><span class="keyword">if</span> (claims != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Date now = <span class="keyword">this</span>.clock.now();</span><br><span class="line">    <span class="keyword">long</span> nowTime = now.getTime();</span><br><span class="line">    Date exp = claims.getExpiration();</span><br><span class="line">    String nbfVal;</span><br><span class="line">    SimpleDateFormat sdf;</span><br><span class="line">    <span class="keyword">if</span> (exp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> maxTime = nowTime - <span class="keyword">this</span>.allowedClockSkewMillis;</span><br><span class="line">        Date max = allowSkew ? <span class="keyword">new</span> Date(maxTime) : now;</span><br><span class="line">        <span class="keyword">if</span> (max.after(exp)) &#123;</span><br><span class="line">            sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss&#x27;Z&#x27;&quot;</span>);</span><br><span class="line">            String expVal = sdf.format(exp);</span><br><span class="line">            nbfVal = sdf.format(now);</span><br><span class="line">            <span class="keyword">long</span> differenceMillis = maxTime - exp.getTime();</span><br><span class="line">            String msg = <span class="string">&quot;JWT expired at &quot;</span> + expVal + <span class="string">&quot;. Current time: &quot;</span> + nbfVal + <span class="string">&quot;, a difference of &quot;</span> + differenceMillis + <span class="string">&quot; milliseconds.  Allowed clock skew: &quot;</span> + <span class="keyword">this</span>.allowedClockSkewMillis + <span class="string">&quot; milliseconds.&quot;</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExpiredJwtException((Header)header, claims, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在解析token并发现这个token已经过期了，它作出的反应是<strong>直接抛异常</strong>，除了msg信息，还有claims和header信息；<br>回到我们的工具类中的解析jwt的方法：</p><p><img src="https://i.loli.net/2021/11/11/hTdACrEkw6OmLMz.png" alt="image-20211111173917609"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Claims <span class="title">getClaimsFromToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        Claims claims;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            claims = Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            claims = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> claims;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><blockquote><p>解析token会因为token过期而报异常,需要在异常也获取claims信息</p></blockquote><p>claims = e.getClaims();异常后也能获取token里面的信息</p><p>刷新令牌不能和登录验证使用同一个函数，否则登录验证前端传来的token永远都有数据声明。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span>: chankeitin</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span>: 从令牌中获取数据声明-刷新令牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span>: 2021/11/11</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> io.jsonwebtoken.Claims</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Claims <span class="title">getClaimsFromTokenToRefreshToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        Claims claims;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            claims = Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExpiredJwtException e) &#123;</span><br><span class="line">            <span class="comment">//解析token会因为token过期而报异常,需要在异常也获取claims信息</span></span><br><span class="line">            claims = e.getClaims();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> claims;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 后端 </category>
          
          <category> SpringBoot </category>
          
          <category> SpringSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> SpringSecurity </tag>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-原子操作</title>
      <link href="/2021/11/07/Java-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"/>
      <url>/2021/11/07/Java-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Java-原子操作"><a href="#Java-原子操作" class="headerlink" title="Java-原子操作"></a>Java-原子操作</h1><h2 id="题一"><a href="#题一" class="headerlink" title="题一:"></a>题一:</h2><p>以下多线程对int型变量x的操作，哪个不需要进行同步（  ）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A: x=y;</span><br><span class="line">B: x++;</span><br><span class="line">C: ++x;</span><br><span class="line">D: x=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="答案：C"><a href="#答案：C" class="headerlink" title="答案：C"></a>答案：C</h3><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>A.由于y的值不确定，所以要加锁；</p><p>B,C 两个在多线程情况下是必须要加锁的，因为他们是先被读入寄存器，然后再进行+1操作，如果没有加锁，那么可能会出现数据异常；</p><p>D 原子操作，所以不需要加锁</p><p>  原子性：指该操作不能再继续划分为更小的操作。</p><p>A.由于y的值不确定，所以要加锁；</p><p>B,C 两个在多线程情况下是必须要加锁的，因为他们是先被读入寄存器，然后再进行+1操作，如果没有加锁，那么可能会出现数据异常；</p><p>D 原子操作，所以不需要加锁</p><p>  原子性：指该操作不能再继续划分为更小的操作。</p><blockquote><p>Java中的原子操作包括：   </p><p>​    1、除long和double之外的基本类型的赋值操作</p><p>​    2、所有引用reference的赋值操作</p><p>​    3、java.concurrent.Atomic.* 包中所有类的一切操作</p></blockquote><p>因为有些cpu字长是32位，long和double是64位，操作需要2次。</p><p>在Java中，我们可以通过同步锁或者CAS操作来实现原子操作。</p><h3 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h3><p>CAS是Compare and swap的简称，这个操作是硬件级别的操作，在硬件层面保证了操作的原子性。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。<strong>当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</strong>Java中的<code>sun.misc.Unsafe</code>类提供了<code>compareAndSwapInt</code>和<code>compareAndSwapLong</code>等几个方法实现CAS。</p><p><img src="https://i.loli.net/2021/11/09/RTCPD39Sx1crunw.png" alt="image-20211109103824788"></p><p>举个栗子：整型原子类源码</p><p><img src="https://i.loli.net/2021/11/09/iVqtZDOk5Qwzd6f.png" alt="image-20211109104146274"></p><p>UnSafe类是CAS的核心类由于Java 方法无法直接访问底层，需要通过本地(native)方法来访问，基于该类可以直接操作特额定的内存数据.UnSafe类在于sun.misc包中，其内部方法操作可以向C的指针一样直接操作内存,因为Java中CAS操作的助兴依赖于UNSafe类的方法。</p><ul><li>变量ValueOffset：它是该变量在内存中的偏移地址,因为UnSafe就是根据内存偏移地址获取数据的</li><li>变量value：被volatile修饰,保证了多线程之间的可见性.</li></ul><p><img src="https://i.loli.net/2021/11/09/5wdaY6KkBszo1Hf.png" alt="image-20211109104346043"></p><h3 id="CAS引出的问题"><a href="#CAS引出的问题" class="headerlink" title="CAS引出的问题"></a>CAS引出的问题</h3><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p><strong>问题描述：</strong>当你获得对象当前数据后，在准备修改为新值前，对象的值被其他线程连续修改了两次，而经过两次修改后，对象的值又恢复为旧值，这样当前线程无法正确判断这个对象是否修改过。</p><p><strong>解决办法</strong>：JDK1.5可以利用<code>AtomicStampedReference</code>类来解决这个问题，<code>AtomicStampedReference</code>内部不仅维护了对象值，还维护了一个<strong>时间戳</strong>。当<code>AtomicStampedReference</code>对应的数值被修改时，除了更新数据本身外，还必须要更新时间戳，对象值和时间戳都必须满足期望值，写入才会成功。</p><blockquote><p>原理：乐观锁-版本号</p></blockquote><h4 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h4><p><strong>问题描述：</strong>CAS失败就会一直进行尝试。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p><p><strong>解决办法</strong>：JVM支持处理器提供的pause指令，使得效率会有一定的提升，pause指令有两个作用：</p><ul><li>第一它可以延迟流水线执行指令,使CPU不会消耗过多的执行资源，</li><li>第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</li></ul><h4 id="不能保证多个共享变量的原子操作"><a href="#不能保证多个共享变量的原子操作" class="headerlink" title="不能保证多个共享变量的原子操作"></a>不能保证多个共享变量的原子操作</h4><p><strong>问题描述</strong>：当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。</p><p><strong>解决办法</strong>：从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-整型数值对比</title>
      <link href="/2021/10/30/Java-%E6%95%B4%E5%9E%8B%E6%95%B0%E5%80%BC%E5%AF%B9%E6%AF%94/"/>
      <url>/2021/10/30/Java-%E6%95%B4%E5%9E%8B%E6%95%B0%E5%80%BC%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Java-整型数值对比"><a href="#Java-整型数值对比" class="headerlink" title="Java-整型数值对比"></a>Java-整型数值对比</h1><h2 id="题一"><a href="#题一" class="headerlink" title="题一:"></a>题一:</h2><p>有如下4条语句：()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i01=<span class="number">59</span>;</span><br><span class="line"><span class="keyword">int</span> i02=<span class="number">59</span>;</span><br><span class="line">Integer i03=Integer.valueOf(<span class="number">59</span>);</span><br><span class="line">Integer i04=<span class="keyword">new</span> Integer(<span class="number">59</span>);</span><br></pre></td></tr></table></figure><p>以下输出结果为false的是:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A. System.out.println(i01==i02);</span><br><span class="line">B. System.out.println(i01==i03);</span><br><span class="line">C. System.out.println(i03==i04);</span><br><span class="line">D. System.out.println(i02==i04);</span><br></pre></td></tr></table></figure><h3 id="答案：C"><a href="#答案：C" class="headerlink" title="答案：C"></a>答案：C</h3><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ol><li>无论如何，Integer与new Integer不会相等。不会经历拆箱过程，</li><li>两个都是非new出来的Integer，如果数在-128到127之间，则是true,否则为false<br>java在编译Integer i2 = 128的时候,被翻译成-&gt; Integer i2 = Integer.valueOf(128);而valueOf()函数会对-128到127之间的数进行缓存</li><li>两个都是new出来的,都为false</li><li>int和integer(无论new否)比，都为true，因为会把Integer自动拆箱为int再去比</li></ol><ul><li><strong>Integer valueOf(int i)：</strong>返回一个表示指定的 int 值的 Integer 实例。</li></ul><p>Byte,Short,Integer,Long,Character这5种整型的包装类也只是在对应值小于等于127并且大于等于-128时才可使用常量池，因为他们至占用一个字节(-128~127);</p><p>再者Integer.valueOf方法中也有判断，如果传递的整型变量&gt;= -128并且小于127时会返回IntegerCache类中一个静态数组中的某一个对象， 否则会返回一个新的Integer对象,代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">一些基本数据类型缓冲池的范围</span><br><span class="line"><span class="keyword">boolean</span> values <span class="keyword">true</span> and <span class="keyword">false</span></span><br><span class="line"><span class="keyword">short</span> values between -<span class="number">128</span> and <span class="number">127</span></span><br><span class="line"><span class="keyword">int</span> values between -<span class="number">128</span> and <span class="number">127</span></span><br><span class="line"><span class="keyword">char</span> in the range \u0000 to \u007F</span><br><span class="line">进入对应类源码查看对应XXXCache类的cache范围即可</span><br></pre></td></tr></table></figure><p>所以如果你测试如下代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        Integer a = <span class="number">127</span>;</span><br><span class="line">        Integer b = <span class="number">127</span>;</span><br><span class="line">         </span><br><span class="line">        Integer c = <span class="number">128</span>;</span><br><span class="line">        Integer d = <span class="number">128</span>;</span><br><span class="line">         </span><br><span class="line">        System.out.println(a == b);</span><br><span class="line">        System.out.println(c == d);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结合自动封装、常量池以及Integer.valueOf方法就不难得出，答案时true和false；</p><p>再看本题</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i01=<span class="number">59</span>;</span><br><span class="line"><span class="keyword">int</span> i02=<span class="number">59</span>;</span><br><span class="line">Integer i03=Integer.valueOf(<span class="number">59</span>);</span><br><span class="line">Integer i04=<span class="keyword">new</span> Integer(<span class="number">59</span>);</span><br></pre></td></tr></table></figure><p>第一行：由于59在-128~127范围之内，所以在自动装箱的时候，会返回IntegerCache[59 - (-128)];</p><p>第三行：同第一行</p><p>第四行：因为有new关键字，所以在heap中开辟了一块新内存放置值为59的Integer对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(i01==i02);<span class="comment">//正确</span></span><br><span class="line">System.out.println(i01==i03);<span class="comment">//正确，都指向IntegerCache[59-(-128)]对象</span></span><br><span class="line">System.out.println(i03==i04);<span class="comment">//错误，引用指向的对象地址不同</span></span><br><span class="line">System.out.println(i02==i04);<span class="comment">//正确</span></span><br></pre></td></tr></table></figure><h2 id="题二"><a href="#题二" class="headerlink" title="题二:"></a>题二:</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">12</span>;</span><br><span class="line">Integer j = <span class="keyword">new</span> Integer(<span class="number">12</span>);</span><br><span class="line">j.equals (i) ;</span><br><span class="line">i == j</span><br></pre></td></tr></table></figure><p>jdk1.5之后，下列 java 程序输出结果为______。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A: <span class="keyword">true</span>,<span class="keyword">false</span></span><br><span class="line">B: <span class="keyword">true</span>,<span class="keyword">true</span></span><br><span class="line">C: <span class="keyword">false</span>,<span class="keyword">true</span></span><br><span class="line">D: <span class="keyword">false</span>,<span class="keyword">false</span></span><br><span class="line">E: 对于不同的环境结果不同</span><br><span class="line">F: 程序无法执行</span><br></pre></td></tr></table></figure><h3 id="答案：B"><a href="#答案：B" class="headerlink" title="答案：B"></a>答案：B</h3><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><h3 id="①比较的是值"><a href="#①比较的是值" class="headerlink" title="①比较的是值"></a>①比较的是值</h3><h4 id="一、基本数据类型与引用数据类型进行比较时，引用数据类型会进行拆箱，然后与基本数据类型进行值的比较"><a href="#一、基本数据类型与引用数据类型进行比较时，引用数据类型会进行拆箱，然后与基本数据类型进行值的比较" class="headerlink" title="一、基本数据类型与引用数据类型进行比较时，引用数据类型会进行拆箱，然后与基本数据类型进行值的比较"></a>一、基本数据类型与引用数据类型进行比较时，引用数据类型会进行拆箱，然后与基本数据类型进行值的比较</h4><p>举例：<br>int i = 12;<br>Integer j = new Integer(12);<br>i == j 返回的是true</p><h4 id="二、引用数据类型与基本数据类型进行比较（equals方法），基本数据类型会进行自动装箱，与引用数据类型进行比较，Object中的equals方法比较的是地址，但是Integer类已经重写了equals方法，只要两个对象的值相同，则可视为同一对象，具体看API文档，所以这归根到底也是值的比较！"><a href="#二、引用数据类型与基本数据类型进行比较（equals方法），基本数据类型会进行自动装箱，与引用数据类型进行比较，Object中的equals方法比较的是地址，但是Integer类已经重写了equals方法，只要两个对象的值相同，则可视为同一对象，具体看API文档，所以这归根到底也是值的比较！" class="headerlink" title="二、引用数据类型与基本数据类型进行比较（equals方法），基本数据类型会进行自动装箱，与引用数据类型进行比较，Object中的equals方法比较的是地址，但是Integer类已经重写了equals方法，只要两个对象的值相同，则可视为同一对象，具体看API文档，所以这归根到底也是值的比较！"></a>二、引用数据类型与基本数据类型进行比较（equals方法），基本数据类型会进行自动装箱，与引用数据类型进行比较，Object中的equals方法比较的是地址，但是Integer类已经重写了equals方法，只要两个对象的值相同，则可视为同一对象，具体看API文档，所以这归根到底也是值的比较！</h4><p>举例：<br>int i = 12;<br>Integer j = new Integer(12);<br>j.equals(i) 返回的是true</p><h3 id="②比较的是地址"><a href="#②比较的是地址" class="headerlink" title="②比较的是地址"></a>②比较的是地址</h3><h4 id="一、如果引用数据类型是这样-Integer-i-12-直接从常量池取对象，这是如果数值是在-128与127之间，则视为同一对象，否则视为不同对象"><a href="#一、如果引用数据类型是这样-Integer-i-12-直接从常量池取对象，这是如果数值是在-128与127之间，则视为同一对象，否则视为不同对象" class="headerlink" title="一、如果引用数据类型是这样 Integer i = 12;直接从常量池取对象，这是如果数值是在-128与127之间，则视为同一对象，否则视为不同对象"></a>一、如果引用数据类型是这样 Integer i = 12;直接从常量池取对象，这是如果数值是在-128与127之间，则视为同一对象，否则视为不同对象</h4><p>举例：<br>Integer i = 12; Integer j = 12; i == j 返回的是true<br>Integer i = 128; Integer j = 128; i == j 返回的是false</p><h4 id="二、如果引用数据类型是直接new的话，不管值是否相同，这时两个对象都是不相同的，因为都会各自在堆内存中开辟一块空间"><a href="#二、如果引用数据类型是直接new的话，不管值是否相同，这时两个对象都是不相同的，因为都会各自在堆内存中开辟一块空间" class="headerlink" title="二、如果引用数据类型是直接new的话，不管值是否相同，这时两个对象都是不相同的，因为都会各自在堆内存中开辟一块空间"></a>二、如果引用数据类型是直接new的话，不管值是否相同，这时两个对象都是不相同的，因为都会各自在堆内存中开辟一块空间</h4><p>举例：<br>Integer i =new Integer(12);<br>Integer j = new Integer(12);<br>i == j 这时返回的是false<br>三、从常量池取对象跟new出来的对象也是不同的<br>举例：<br>Integer i = 12;<br>Integer j = new Integer(12)<br>i == j 这时返回的是false，因为第二个语句其实已经是new了两个对象了！！！</p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java·JVM·JUC(一)</title>
      <link href="/2021/10/30/Java%C2%B7JVM%C2%B7JUC(%E4%B8%80)/"/>
      <url>/2021/10/30/Java%C2%B7JVM%C2%B7JUC(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Java·JVM·JUC-一"><a href="#Java·JVM·JUC-一" class="headerlink" title="Java·JVM·JUC(一)"></a>Java·JVM·JUC(一)</h1><h2 id="Java-中垃圾回收机制中如何判断对象需要回收？常见的-GC-回收算法有哪些？"><a href="#Java-中垃圾回收机制中如何判断对象需要回收？常见的-GC-回收算法有哪些？" class="headerlink" title="Java 中垃圾回收机制中如何判断对象需要回收？常见的 GC 回收算法有哪些？"></a>Java 中垃圾回收机制中如何判断对象需要回收？常见的 GC 回收算法有哪些？</h2><h3 id="如何判断对象需要回收"><a href="#如何判断对象需要回收" class="headerlink" title="如何判断对象需要回收"></a>如何判断对象需要回收</h3><p>一般有两种方法来判断：</p><ul><li><strong>引用计数器法</strong>：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</li><li><strong>可达性分析算法</strong>：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</li></ul><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><ul><li>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</li></ul><p><img src="https://i.loli.net/2021/10/26/7yxgmv3YnMkqCa4.png" alt="image-20211026154904653"></p><ul><li>复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</li></ul><p><img src="https://i.loli.net/2021/10/26/Nr8SpaUs6Bm5woM.png" alt="image-20211026154857764"></p><ul><li>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</li></ul><p><img src="https://i.loli.net/2021/10/30/WiR7Tx4sboPQDMa.png" alt="image-20211026154839186"></p><ul><li>分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</li></ul><p><img src="https://i.loli.net/2021/10/26/ZtiwMGqsPa3lTSD.png" alt="image-20211026154831011"></p><h2 id="HashMap-与-ConcurrentHashMap-的实现原理是怎样的？ConcurrentHashMap-是如何保证线程安全的？"><a href="#HashMap-与-ConcurrentHashMap-的实现原理是怎样的？ConcurrentHashMap-是如何保证线程安全的？" class="headerlink" title="HashMap 与 ConcurrentHashMap 的实现原理是怎样的？ConcurrentHashMap 是如何保证线程安全的？"></a>HashMap 与 ConcurrentHashMap 的实现原理是怎样的？ConcurrentHashMap 是如何保证线程安全的？</h2><ol><li>HashMap不支持并发操作，没有同步方法，ConcurrentHashMap支持并发操作，通过继承 ReentrantLock（JDK1.7重入锁）/CAS和synchronized(JDK1.8内置锁)来进行加锁（分段锁），每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</li><li>JDK1.8之前HashMap的结构为数组+链表，JDK1.8之后HashMap的结构为数组+链表+红黑树；JDK1.8之前ConcurrentHashMap的结构为segment数组+数组+链表，JDK1.8之后ConcurrentHashMap的结构为数组+链表+红黑树。</li></ol><p>如下一些方式可以获得线程安全的HashMap：</p><ul><li>Collections.synchronizedMap</li><li>HashTable</li><li>ConcurrentHashMap</li></ul><h2 id="Synchronized-关键字底层是如何实现的？它与-Lock-相比优缺点分别是什么？"><a href="#Synchronized-关键字底层是如何实现的？它与-Lock-相比优缺点分别是什么？" class="headerlink" title="Synchronized 关键字底层是如何实现的？它与 Lock 相比优缺点分别是什么？"></a>Synchronized 关键字底层是如何实现的？它与 Lock 相比优缺点分别是什么？</h2><p>Synchronized关键字<strong>底层是使用monitor对象锁实现的</strong>，每一个对象关联一个monitor对象，而monitor对象可以看成是一个对象锁，它采用互斥的方式让同一时刻至多只有一个线程能持有对象锁，其他线程再想获取这个对 象锁时会被阻塞住，这样就能保证拥有锁的线程可以安全的执行临界区的代码。</p><p>Lock是一个接口，而synchronized是Java中的关键字，是内置的语言实现；Synchronized既可以加在方法上，也可以加在特定的代码块上，而Lock需要显示地指定起始位置和终止位置。</p><h3 id="Synchronized相比于Lock，它的优点是："><a href="#Synchronized相比于Lock，它的优点是：" class="headerlink" title="Synchronized相比于Lock，它的优点是："></a>Synchronized相比于Lock，它的优点是：</h3><p>Synchronized不需要用户手动去释放锁，当synchronized方法或者代码块执行完毕后，系统会自动让线程释放锁的占用，无论中途是否遇到异常都能自动释放；而Lock需要用户手动去释放，一般写在finally块中避免执行中途遇到异常无法正常释放锁。</p><p>缺点是：</p><ul><li><p>Lock可以被中断或设置超时等待，可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待锁的线程会一直等下去，不能响应中断。</p></li><li><p>Lock可以设置公平锁，而synchronized只能是非公平实现(公平锁通过在锁竞争前判断自己是否是头节点来实现)。</p></li><li><p>Lock可以支持多个条件变量(Condition)，而synchronized只支持一个条件变量，所有的等待都在同一个waitset中。</p></li></ul><h2 id="JMM-中内存模型是怎样的？什么是指令序列重排序？"><a href="#JMM-中内存模型是怎样的？什么是指令序列重排序？" class="headerlink" title="JMM 中内存模型是怎样的？什么是指令序列重排序？"></a>JMM 中内存模型是怎样的？什么是指令序列重排序？</h2><p>Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</p><p><img src="https://i.loli.net/2021/10/26/7YQpVa9behBRUDL.png" alt="image-20211026232307826"></p><p>各部分的特点和作用如下：</p><p><img src="https://i.loli.net/2021/10/26/TJXBxrSsi38IqFh.png" alt="image-20211026232330804"></p><h3 id="什么是重排序"><a href="#什么是重排序" class="headerlink" title="什么是重排序"></a>什么是重排序</h3><ul><li>假设我们写了一个 Java 程序，包含一系列的语句，我们会默认期望这些语句的实际运行顺序和写的代码顺序一致。</li><li>但实际上，编译器、JVM 或者 CPU 都有可能出于优化等目的，对于实际指令执行的顺序进行调整，这就是重排序。</li></ul><p><img src="https://i.loli.net/2021/10/30/K7ToZctWJSers9V.png" alt="image-20211030131544832"></p><h2 id="简述-ArrayList-与-LinkedList-的底层实现以及常见操作的时间复杂度"><a href="#简述-ArrayList-与-LinkedList-的底层实现以及常见操作的时间复杂度" class="headerlink" title="简述 ArrayList 与 LinkedList 的底层实现以及常见操作的时间复杂度"></a>简述 ArrayList 与 LinkedList 的底层实现以及常见操作的时间复杂度</h2><ul><li><p><strong>数据结构实现</strong>：ArrayList 是<strong>动态数组</strong>的数据结构实现，而 LinkedList 是<strong>双向链表</strong>的数据结构实现。</p></li><li><p><strong>随机访问效率</strong>：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</p></li><li><p><strong>增加和删除效率</strong>：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</p></li><li><p><strong>内存空间占用</strong>：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</p></li><li><p><strong>线程安全</strong>：ArrayList 和 LinkedList 都是不同步的，也就是<strong>不保证线程安全</strong>；</p></li></ul><h2 id="简述-BIO-NIO-AIO-的区别"><a href="#简述-BIO-NIO-AIO-的区别" class="headerlink" title="简述 BIO, NIO, AIO 的区别"></a>简述 BIO, NIO, AIO 的区别</h2><p><strong>BIO</strong>：线程发起IO请求，不管内核是否准备好IO操作，从发起请求起，线程一直阻塞，直到操作完成。</p><ul><li>同步并阻塞，服务器实现模式为<strong>一个连接一个线程</strong>，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</li></ul><p><strong>NIO</strong>：线程发起IO请求，立即返回；内核在做好IO操作的准备之后，通过调用注册的回调函数通知线程做IO操作，线程开始阻塞，直到操作完成。</p><ul><li>同步非阻塞，服务器实现模式为<strong>一个请求一个线程</strong>，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。</li></ul><p><strong>AIO</strong>：线程发起IO请求，立即返回；内存做好IO操作的准备之后，做IO操作，直到操作完成或者失败，通过调用注册的回调函数通知线程做IO操作完成或者失败。</p><ul><li>异步非阻塞，服务器实现模式为<strong>一个有效请求一个线程</strong>，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。<br>适用场景分析</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</li><li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</li><li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</li></ul><h2 id="Java-类的加载流程是怎样的？什么是双亲委派机制？"><a href="#Java-类的加载流程是怎样的？什么是双亲委派机制？" class="headerlink" title="Java 类的加载流程是怎样的？什么是双亲委派机制？"></a>Java 类的加载流程是怎样的？什么是双亲委派机制？</h2><h3 id="类的加载流程"><a href="#类的加载流程" class="headerlink" title="类的加载流程"></a>类的加载流程</h3><p>虚拟机把描述类的数据从Class文件<strong>加载</strong>到内存，并对数据进行<strong>校验</strong>，<strong>解析</strong>和<strong>初始化</strong>，最终形成可以被虚拟机直接使用的java类型。</p><h3 id="类的加载原理"><a href="#类的加载原理" class="headerlink" title="类的加载原理"></a>类的加载原理</h3><p>在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。</p><p>类装载方式，有两种 ：</p><ol><li><p>隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中，</p></li><li><p>显式装载， 通过class.forname()等方法，显式加载需要的类</p></li></ol><p>Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。</p><h3 id="双亲委派模型？"><a href="#双亲委派模型？" class="headerlink" title="双亲委派模型？"></a>双亲委派模型？</h3><p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p><p><img src="https://i.loli.net/2021/10/30/4urHVPsEmNnhyFZ.png" alt="image-20211030133559926"></p><p>类加载器分类：</p><ul><li>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；</li><li>其他类加载器：</li><li>扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</li><li>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</li></ul><p><strong>双亲委派模型</strong>：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p><blockquote><p>当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。</p></blockquote><h2 id="volatile-关键字解决了什么问题，它的实现原理是什么？"><a href="#volatile-关键字解决了什么问题，它的实现原理是什么？" class="headerlink" title="volatile 关键字解决了什么问题，它的实现原理是什么？"></a>volatile 关键字解决了什么问题，它的实现原理是什么？</h2><p>Java提供了volatile关键字来保证<strong>可见性、有序性。但不保证原子性</strong>。</p><p>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p><p>2）禁止进行指令重排序。 </p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>第一：使用volatile关键字会<strong>强制将修改的值立即写入主存</strong>；</p><p>第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量的<strong>缓存行无效</strong>（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p><p>第三：由于线程1的工作内存中缓存变量的缓存行无效，所以线程1再次读取变量的值时会去主存读取。</p><h2 id="简述-Synchronized，Volatile，可重入锁的不同使用场景及优缺点"><a href="#简述-Synchronized，Volatile，可重入锁的不同使用场景及优缺点" class="headerlink" title="简述 Synchronized，Volatile，可重入锁的不同使用场景及优缺点"></a>简述 Synchronized，Volatile，可重入锁的不同使用场景及优缺点</h2><h3 id="synchronized的三种应用方式"><a href="#synchronized的三种应用方式" class="headerlink" title="synchronized的三种应用方式"></a>synchronized的三种应用方式</h3><ul><li>修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁：修饰在普通实例方法前，当多个线程操作1个实例可以实现线程安全。但多个线程操作多个实例对象，导致锁不同，无法实现线程安全。锁的是整个实例，当被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法</li><li>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁：修饰在静态方法前，锁的是当前类的Class对象，通过class对象锁可以控制静态成员的并发操作。</li><li>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li></ul><h3 id="synchronized和ReentrantLock-的区别"><a href="#synchronized和ReentrantLock-的区别" class="headerlink" title="synchronized和ReentrantLock 的区别"></a>synchronized和ReentrantLock 的区别</h3><p>二者均是可重入锁</p><ul><li>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</li><li>synchronized均是由JVM虚拟机在字节码底层实现的，而ReentrantLock是可以在代码中通过接口API调用各种方法，灵活性和可操作性更强。</li><li>ReentrantLock 比 synchronized 增加了一些高级功能：</li><li>通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情</li><li>ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁</li><li>synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程</li></ul><h3 id="synchronized-关键字和-volatile-关键字的区别"><a href="#synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="synchronized 关键字和 volatile 关键字的区别"></a>synchronized 关键字和 volatile 关键字的区别</h3><ul><li>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。</li><li>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞</li><li>volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。</li><li>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。</li></ul><p>题目答案均为转载，题目先后顺序按各大厂总出题次数排列！</p>]]></content>
      
      
      <categories>
          
          <category> 面试技巧 </category>
          
          <category> Java·JVM·JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java·JVM·JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议(四)</title>
      <link href="/2021/10/26/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE(%E5%9B%9B)/"/>
      <url>/2021/10/26/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE(%E5%9B%9B)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="网络协议-四"><a href="#网络协议-四" class="headerlink" title="网络协议(四)"></a>网络协议(四)</h1><h2 id="简述-HTTP-的-keepalive-的原理和使用场景"><a href="#简述-HTTP-的-keepalive-的原理和使用场景" class="headerlink" title="简述 HTTP 的 keepalive 的原理和使用场景"></a>简述 HTTP 的 keepalive 的原理和使用场景</h2><p>当使用 Keep-Alive 模式时，Keep-Alive 功能使客户端到服务器端的连接持续有效。</p><ol><li>HTTP1.0 KeepAlive支持的数据交互流程如下：</li></ol><blockquote><p>a)Client发出request，其中该request的HTTP版本号为1.0。同时在request中包含一个header：”Connection： keep-alive”。</p><p>b)Web Server收到request中的HTTP协议为1.0及”Connection： keep-alive”就认为是一个长连接请求，其将在response的header中也增加”Connection： keep-alive”。同时不会关闭已建立的tcp连接。</p><p>c)Client收到Web Server的response中包含”Connection： keep-alive”，就认为是一个长连接，不close tcp连接。并用该tcp连接再发送request。（跳转到a)）</p></blockquote><ol start="2"><li>HTTP1.1 KeepAlive支持的数据交互流程如下：</li></ol><blockquote><p>a)Client发出request，其中该request的HTTP版本号为1.1。</p><p>b)Web Server收到request中的HTTP协议为1.1就认为是一个长连接请求，其将在response的header中也增加”Connection： keep-alive”。同时不会关闭已建立的tcp连接。</p><p>c)Client收到Web Server的response中包含”Connection： keep-alive”，就认为是一个长连接，不close tcp连接。并用该tcp连接再发送request。（跳转到a)）</p></blockquote><h2 id="简述在四层和七层网络协议中负载均衡的原理"><a href="#简述在四层和七层网络协议中负载均衡的原理" class="headerlink" title="简述在四层和七层网络协议中负载均衡的原理"></a>简述在四层和七层网络协议中负载均衡的原理</h2><p><strong>二层负载</strong>均衡会通过一个虚拟 MAC 地址接收请求，然后再分配到真实的 MAC 地址；</p><p><strong>三层负载</strong>均衡会通过一个虚拟 IP 地址接收请求，然后再分配到真实的 IP 地址；</p><p><strong>四层</strong>通过虚拟 IP + 端口接收请求，然后再分配到真实的服务器；</p><p><strong>七层</strong>通过虚拟的 URL 或主机名接收请求，然后再分配到真实的服务器。</p><p>所谓的四到七层负载均衡，就是在对后台的服务器进行负载均衡时，依据四层的信息或七层的信息来决定怎么样转发流量。</p><p>比如四层的负载均衡，就是通过发布三层的 IP 地址（VIP），然后加四层的端口号，来决定哪些流量需要做负载均衡， 对需要处理的流量进行 NAT 处理，转发至后台服务器，并记录下这个 TCP 或者 UDP 的流量是由哪台服务器处理的， 后续这个连接的所有流量都同样转发到同一台服务器处理。</p><p>七层的负载均衡，就是在四层的基础上（没有四层是绝对不可能有七层的），再考虑应用层的特征， 比如同一个 Web 服务器的负载均衡，除了根据 VIP 加 80 端口辨别是否需要处理的流量， 还可根据七层的 URL、浏览器类别、语言来决定是否要进行负载均衡。</p><h2 id="简述-TCP-半连接发生场景"><a href="#简述-TCP-半连接发生场景" class="headerlink" title="简述 TCP 半连接发生场景"></a>简述 TCP 半连接发生场景</h2><blockquote><p>发生在TCP三次握手中<br>如果A向B发起链接，B也按照正常情况响应了，但是A不进行三次握手，这就是半连接。<br><strong>半连接攻击：</strong>半连接，会造成B分配的内存资源就一直这么耗着，直到资源耗尽。（SYN攻击）</p></blockquote><h2 id="什么是-SYN-flood，如何防止这类攻击？"><a href="#什么是-SYN-flood，如何防止这类攻击？" class="headerlink" title="什么是 SYN flood，如何防止这类攻击？"></a>什么是 SYN flood，如何防止这类攻击？</h2><p>SYN Flood顾名思义就是用洪水一样的SYN报文进行攻击。</p><p>在连接超时之前，服务器会一直等待ACK报文，此时该连接状态为半开放连接（也被称为半连接）。半连接会占用服务器的连接数，当连接数被占满时，服务器就无法提供正常的服务了。</p><ol><li>TCP首包丢弃:<br>该算法利用了TCP/IP协议的重传特性，来自某个源IP的第一个syn包到达时被直接丢弃并记录状态(五元组)，在该源IP的第2个syn包到达时进行验证，然后放行。</li></ol><p>当防御设备接到一个IP地址的SYN报文后:</p><ul><li>接受到syn报文      -&gt; 简单比对该IP是否存在于白名单中:   存在则转发到后端，否则进行第2步</li><li>不存在于白名单中 -&gt; 检查是否是该IP在一定时间段内的首次SYN报文： 不是则进行第3步，是则进行第5步</li><li>不是首次SYN报文 -&gt; 检查是否重传报文： 是重传则转发并加入白名单，不是则丢弃并加入黑名单</li><li>是首次SYN报文    -&gt;  丢弃并等待一段时间以试图接受该IP的SYN重传报文，等待超时则判定为攻击报文加入黑名单。</li></ul><ol start="2"><li>cookie源认证<br>原理是syn报文首先由DDOS防护系统来响应syn_ack。带上特定的sequence number （记为cookie）。真实的客户端会返回一个ack 并且Acknowledgment number 为cookie+1。 而伪造的客户端，将不会作出响应。这样我们就可以知道那些IP对应的客户端是真实的，将真实客户端IP加入白名单。下次访问直接通过，而其他伪造的syn报文就被拦截。</li></ol><h2 id="简述-HTTP-报文头部的组成结构"><a href="#简述-HTTP-报文头部的组成结构" class="headerlink" title="简述 HTTP 报文头部的组成结构"></a>简述 HTTP 报文头部的组成结构</h2><p><strong>1、开始行</strong><br>在请求报文称为请求行，在响应报文称为状态行。<br><strong>2、首部行</strong><br>用来说明浏览器、服务器、或报文主体的一些信息。<br><strong>3、实体主体</strong><br>请求报文一般不会有这个字段，而响应报文一般有，但也可以没有。</p><p><img src="https://i.loli.net/2021/10/25/mGz5WCKqVQvatTo.png" alt="image-20211025103309930"></p><h2 id="为什么需要序列化？有什么序列化的方式？"><a href="#为什么需要序列化？有什么序列化的方式？" class="headerlink" title="为什么需要序列化？有什么序列化的方式？"></a>为什么需要序列化？有什么序列化的方式？</h2><p><strong>对象的序列化是指通过某种方法把对象以字节序列的形式保存起来。反之通过字节序列得到原对象就是反序列化</strong>。</p><ol><li>描述数据的传输格式，这样可以方便自己组织数据传输格式，以至于避免一些麻烦及错误</li><li>如果是跨平台的序列化，则发送方序列化后，接收方可以用任何其支持的平台反序列化成相应的版本，比如 Java序列化后</li></ol><h3 id="序列化的方式"><a href="#序列化的方式" class="headerlink" title="序列化的方式"></a>序列化的方式</h3><p>Java原生序列化:只要对象实现了Serializable接口，该对象就可以进行序列化</p><ol><li><strong>Java原生序列化方式</strong>，主要由ObjectInputStream和ObjectOutputStream实现，他们可以直接装饰文件I/O（RandomAccessFile）或者网络I/O（Socket），来实现将<a href="https://cloud.tencent.com/product/cos?from=10680">对象存储</a>到文件或者在网络中传输。不过，还有几点需要注意：</li></ol><ul><li>序列化对象需实现<strong>Serialization</strong>接口</li><li>static属性不能被序列化，序列化保存对象的状态，static属于类状态</li><li>transient修饰的不能被序列化</li><li>版本号serialVersionUID<ul><li>版本号一致，新增字段不影响反序列化对象</li><li>版本号不一致，影响反序列化对象，将报错</li></ul></li></ul><ol start="2"><li><p><strong>JSON</strong>是一种轻量级的数据交换格式。如<a href="https://cloud.tencent.com/product/crs?from=10680">Redis</a>存储对象时，使用JSON格式，使数据支持跨平台、可读性也更强。</p></li><li><p><strong>XML</strong>是一种很常见的数据保存方式。SOAP是基于XML为序列化和反序列化协议的结构化消息传递协议。</p></li><li><p><strong>Kryo</strong>是一个快速有效的Java二进制对象图序列化框架。主要有序列化反序列化更高效、序列化之后字节数据更小、更易用等特点。</p></li></ol><h2 id="TCP-如何实现数据有序性？"><a href="#TCP-如何实现数据有序性？" class="headerlink" title="TCP 如何实现数据有序性？"></a>TCP 如何实现数据有序性？</h2><ol><li><p>主机每次发送数据时，TCP就给每个数据包分配一个序列号并且在一个特定的时间内等待接收主机对分配的这个序列号进行确认</p></li><li><p>如果发送主机在一个特定时间内没有收到接收主机的确认，则发送主机会重传此数据包。</p></li><li><p>接收主机利用序列号对接收的数据进行确认，以便检测对方发送的数据是否有丢失或者乱序等</p></li><li><p>接收主机一旦收到已经顺序化的数据，它就将这些数据按正确的顺序重组成数据流并传递到高层进行处理。</p></li></ol><h2 id="简述-HTTP-短链接与长链接的区别"><a href="#简述-HTTP-短链接与长链接的区别" class="headerlink" title="简述 HTTP 短链接与长链接的区别"></a>简述 HTTP 短链接与长链接的区别</h2><p><strong>短连接</strong></p><blockquote><p>连接-&gt;传输数据-&gt;关闭连接<br>比如HTTP是无状态的的短链接，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。<br>因为连接后接收了数据就断开了，所以每次数据接受处理不会有联系。 这也是HTTP协议无状态的原因之一。</p></blockquote><p><strong>长连接</strong></p><blockquote><p>连接-&gt;传输数据-&gt;保持连接 -&gt; 传输数据-&gt; ………..-&gt;直到一方关闭连接，多是客户端关闭连接。<br>长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。</p></blockquote><p><strong>什么时候用长连接，短连接？</strong></p><blockquote><p>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，<br>这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都<br>不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果<br>用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。</p><p>而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网<br>站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成<br>千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频<br>繁操作情况下需用短连好。</p></blockquote><h2 id="简述-iPv4-和-iPv6-的区别"><a href="#简述-iPv4-和-iPv6-的区别" class="headerlink" title="简述 iPv4 和 iPv6 的区别"></a>简述 iPv4 和 iPv6 的区别</h2><p><strong>1.地址类型。</strong>IPv4具有三种不同类型的地址：多播，广播和单播。IPv6还具有三种不同类型的地址：任意广播，单播和多播。</p><p><strong>2.数据包大小。</strong>对于IPv4，最小数据包大小为576字节。对于IPv6，最小数据包大小为1208字节。</p><p><strong>3.header区域字段数。</strong>IPv4具有12个标头字段，而IPv6支持8个标头字段。</p><p><strong>4.可选字段。</strong>IPv4具有可选字段，而IPv6没有。但是，IPv6具有扩展header，可以在将来扩展协议而不会影响主包结构。</p><p><strong>5.配置。</strong>在IPv4中，新装的系统必须配置好才能与其他系统通信。在IPv6中，配置是可选的，它允许根据所需功能进行选择。</p><p><strong>6.安全性。</strong>在IPv4中，安全性主要取决于网站和应用程序。它不是针对安全性而开发的IP协议。而IPv6集成了Internet协议安全标准（IPSec）。IPv6的网络安全不像IPv4是可选项，IPv6里的网络安全项是强制性的。</p><p><strong>7.与移动设备的兼容性。</strong>IPv4不适合移动网络，因为正如我们前面提到的，它使用点分十进制表示法，而IPv6使用冒号，是移动设备的更好选择。</p><p><strong>8.主要功能。</strong>IPv6允许直接寻址，因为存在大量可能的地址。但是，IPv4已经广泛传播并得到许多设备的支持，这使其更易于使用。</p><p>题目答案均为转载，题目先后顺序按各大厂总出题次数排列！</p>]]></content>
      
      
      <categories>
          
          <category> 面试技巧 </category>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议(三)</title>
      <link href="/2021/10/24/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE(%E4%B8%89)/"/>
      <url>/2021/10/24/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE(%E4%B8%89)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="网络协议-三"><a href="#网络协议-三" class="headerlink" title="网络协议(三)"></a>网络协议(三)</h1><h2 id="从系统层面上，UDP-如何保证尽量可靠？"><a href="#从系统层面上，UDP-如何保证尽量可靠？" class="headerlink" title="从系统层面上，UDP 如何保证尽量可靠？"></a>从系统层面上，UDP 如何保证尽量可靠？</h2><p>  传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。</p><ul><li>实现确认机制、重传机制、窗口确认机制。</li><li>如果你不利用linux协议栈以及上层socket机制，自己通过抓包和发包的方式去实现可靠性传输，那么必须实现如下功能：</li><li>发送：包的分片、包确认、包的重发</li><li>接收：包的调序、包的序号确认</li><li>目前有如下开源程序利用udp实现了可靠的数据传输。分别为RUDP、RTP、UDT。</li></ul><h2 id="简述-JWT-的原理和校验机制"><a href="#简述-JWT-的原理和校验机制" class="headerlink" title="简述 JWT 的原理和校验机制"></a>简述 JWT 的原理和校验机制</h2><p>JWT： JSON Web token 用于json对象在各方之间安全的传输信息，它是安全可被信任的，因为它是数字签名的。JWT是目前最流行的跨域身份验证解决方案</p><p>JWT工作原理：</p><ol><li>应用或客户端向授权服务器请求授权</li><li>当授权被许可后，授权服务器返回一个access token给应用</li><li>客户端存储token，并且在随后的每一次请求中都带着它</li><li>服务器校验token并返回数据</li></ol><h2 id="HTTP-的方法有哪些？"><a href="#HTTP-的方法有哪些？" class="headerlink" title="HTTP 的方法有哪些？"></a>HTTP 的方法有哪些？</h2><ol><li><p>GET方法：获取资源</p></li><li><p>POST方法：传输实体主题</p></li><li><p>PUT方法：传输文件</p></li><li><p>HEAD方法：获取报文首部</p></li><li><p>DELETE方法：删除文件</p></li><li><p>OPTIONS方法：询问支持的方法</p></li></ol><h2 id="TCP-长连接和短连接有那么不同的使用场景？"><a href="#TCP-长连接和短连接有那么不同的使用场景？" class="headerlink" title="TCP 长连接和短连接有那么不同的使用场景？"></a>TCP 长连接和短连接有那么不同的使用场景？</h2><p>数据库的连接用<strong>长连接</strong>， 如果用短连接频繁的通信会造成 socket 错误，而且频繁的 socket创建也是对资源的浪费。网络游戏应用都是长连接</p><p>WEB 网站的 http 服务一般都用<strong>短链接</strong></p><h2 id="什么是-ARP-协议？简述其使用场景"><a href="#什么是-ARP-协议？简述其使用场景" class="headerlink" title="什么是 ARP 协议？简述其使用场景"></a>什么是 ARP 协议？简述其使用场景</h2><p>地址解析协议 <strong>ARP</strong>:知道IP地址请求硬件地址(MAC）</p><p>反向地址转换协议 <strong>RARP</strong>：将局域网中某个主机的物理地址转换为IP地址</p><h3 id="ARP使用场景"><a href="#ARP使用场景" class="headerlink" title="ARP使用场景"></a>ARP使用场景</h3><p>1、发送方是主机H1，要把IP数据报发送到另一个网络上的另一个主机H2.这时H1发送ARP请求分组（在网1上广播），找到目的主句H2的硬件地址；<br>2、发送方是主机H1，要把IP数据报发送到另一个网络上的另一个主机H2.这时H1发送ARP请求分组（在网1上广播），找到网1的一个路由器R1，剩下的工作由路由器R1来完成；<br>3、发送方是路由器R1，要把IP数据报发送到R1连接在同一个网络（网2 ）上的主机H3。这时R1发送ARP请求分组（在网2上广播），找到目的主机H3的硬件地址；<br>4、发送方是路由器R1，要把IP数据报发送到网3上的一个主机H4。这时R1发送ARP请求分组（在网2上广播），找到连接在网2上的一个路由器R2的硬件地址，剩下的工作由路由器R2来完成。<br>反向地址转换协议RARP：将局域网中某个主机的物理地址转换为IP地址</p><h2 id="简述-RPC-的调用过程"><a href="#简述-RPC-的调用过程" class="headerlink" title="简述 RPC 的调用过程"></a>简述 RPC 的调用过程</h2><p><img src="https://i.loli.net/2021/10/24/4AhtEZu8kdYRF2y.png" alt="image-20211024114038289"></p><ol><li><p>调用者（客户端Client）以本地调用的方式发起调用；</p></li><li><p>Client stub（客户端存根）收到调用后，负责将被调用的方法名、参数等打包编码成特定格式的能进行网络传输的消息体；</p></li><li><p>Client stub将消息体通过网络发送给服务端；</p></li><li><p>Server stub（服务端存根）收到通过网络接收到消息后按照相应格式进行拆包解码，获取方法名和参数；</p></li><li><p>Server stub根据方法名和参数进行本地调用；</p></li><li><p>被调用者（Server）本地调用执行后将结果返回给server stub；</p></li><li><p>Server stub将返回值打包编码成消息，并通过网络发送给客户端；</p></li><li><p>Client stub收到消息后，进行拆包解码，返回给Client；</p></li><li><p>Client得到本次RPC调用的最终结果。</p></li></ol><h2 id="TCP-中-SYN-攻击是什么？如何防止？"><a href="#TCP-中-SYN-攻击是什么？如何防止？" class="headerlink" title="TCP 中 SYN 攻击是什么？如何防止？"></a>TCP 中 SYN 攻击是什么？如何防止？</h2><p>SYN攻击属于<strong>DoS</strong>攻击的一种，它利用<strong>TCP协议</strong>缺陷，通过发送大量的<strong>半连接</strong>请求，耗费<strong>CPU</strong>和内存资源。</p><p>SYN攻击通过故意不完成建立连接所需要的三次握手过程，造成连接一方的资源耗尽。</p><p>造成TCP连接的资源消耗，其中包括：数据包信息、条件状态、序列号等。</p><h3 id="如何防止SYN-攻击"><a href="#如何防止SYN-攻击" class="headerlink" title="如何防止SYN 攻击"></a>如何防止SYN 攻击</h3><p>1、具有SYN proxy（SYN代理）功能的防火墙</p><p>   每秒通过指定对象（目标地址和端口、仅目标地址或仅源地址）的SYN片段数的阀值，当来自相同源地址或发往相同目标地址的SYN片段数达到一定阀值时，防火墙开始截断连接请求和代理回复SYN/ACK片段，当防火墙代理半连接的队列被填满，防火墙拒绝来自相安全同区域所有地址的新SYN片段。<br>  缺点：当攻流量较大时，连接出现较大延迟，网络负载高，很多时候成为整个网络瓶颈    </p><p>2、加快淘汰无效SYN请求，通过降低tcp_syn_retries实现；加大队列长度，长度和tcp_max_syn_backing相关，但不完全由它决定。</p><p>  缺点：在高强度攻击面前这两个不能根本解决问题，更有效的是tcp_syncookies。</p><p>3、SYN Cookie，给每一个请求连接的IP地址分配一个Cookie，若短时间内收到某个连续的SYN报文，就认定受到攻击，再来就丢弃。</p><p>  原理：服务器收到SYN报文，返回SYN+ACK包时，不分配一个专门的数据区，而是根据这个SYN包计算出一个cookie值，在收到TCP_ACK时，服务器对比cookie对比检查合法性，再分配专门的数据区处理连接。</p><h2 id="简述-TCP-的报文头部结构"><a href="#简述-TCP-的报文头部结构" class="headerlink" title="简述 TCP 的报文头部结构"></a>简述 TCP 的报文头部结构</h2><p><img src="https://i.loli.net/2021/10/24/NEZvBaW7KPLbCFm.png" alt="image-20211024115019173"></p><h2 id="TCP的拥塞控制具体是怎么实现的？UDP有拥塞控制吗？"><a href="#TCP的拥塞控制具体是怎么实现的？UDP有拥塞控制吗？" class="headerlink" title="TCP的拥塞控制具体是怎么实现的？UDP有拥塞控制吗？"></a>TCP的拥塞控制具体是怎么实现的？UDP有拥塞控制吗？</h2><p>拥塞控制：TCP模块为了防止过多的数据注入网络，使网络中的路由器或链路不致于过载。以此提高网络利用率，降低丢包率，并抱证网络资源对每条数据流的公平性而采取的控制手段。拥塞控制包含四部分内容：慢启动、拥塞避免、快速重传、快速恢复。</p><ul><li>慢启动：  网络传输刚开始时，并不知道网络的实际情况，所以采取一种试探的方式控制数据的发送速率。慢启动阶段，数据的发送速率以指数方式增长，即就是拥塞窗口的增长，每次都是收到确认报文段数量的2倍。可以看出慢启动并不慢，拥塞窗口增长的速度很快。所以，为其设置了一个慢启动门限，当达到门限时，就进入到拥塞避免阶段。</li><li>拥塞避免： 当拥塞窗口的大小采用慢启动方式增长到慢启动门限时，就进入拥塞避免阶段，拥塞避免阶段不再以指数形式增长拥塞窗口，而是每经过一个往返时间RTT就将发送方的拥塞窗口+1， 使其增长速度减缓。按照线性方式增长。如果发生网络拥塞，比如丢包时，就将慢启动门限设为原来的一半，然后将拥塞窗口设置为1，开始执行慢启动算法。（较低的起点，指数级增长）。</li><li>快速重传： 假设发送方发送的报文段分别为： M1,M2,M3,M4,M5,M6 , 当接收方收到M1和M2后，M3报文段丢失，接着收到的M4，M5，M6都不做处理，而是没接收到一个报文段就对M2重复确认，发送方接收到重复的三次确认报文段，就对其后的报文段进行重新发送，而不需要等待超时时间到达。当快速重传后，立即进入到快速恢复阶段。</li><li>快速恢复：将慢启动门限设置为原来的一半，然后将拥塞窗口设置为现在的慢启动门限值，不再执行慢启动算法，而是直接进入拥塞避免阶段。使发送窗口成线性方式增大。</li></ul><p><img src="https://i.loli.net/2021/10/24/Wrl7I2XvadHoghD.png" alt="image-20211024115427867"></p><ul><li>流量控制（滑动窗口协议）TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。【滑动窗口技术存在于数据链路层和传输层。两者有不同的协议，但基本原理相同。区别是一个是发送帧，一个是发送字节数据。接收方的接受窗口告诉发送方本端tcp接受缓冲区还能容纳多少字节，发送方的发送窗口就可以控制发送数据的速度。】</li></ul><p>UDP没有流量控制和拥塞控制，所以在网络拥塞时不会是源主机发送速率降低（对实时通信很有用，比如QQ电话，视频会议等）</p><h2 id="什么是中间人攻击？如何防止攻击？"><a href="#什么是中间人攻击？如何防止攻击？" class="headerlink" title="什么是中间人攻击？如何防止攻击？"></a>什么是中间人攻击？如何防止攻击？</h2><h3 id="MITM-中间人攻击"><a href="#MITM-中间人攻击" class="headerlink" title="MITM 中间人攻击"></a>MITM 中间人攻击</h3><p>攻击者可以将自己植入到彼此正在通信的两方之间，开展窃听、甚至是攻击活动。</p><p><strong>离线中间人攻击</strong>:某中间人成功截获了您发送的消息，对其进行了读取和重新打包操作，然后将新的内容发回给您、或原始收件人。而当此人在不知情的情况下回复时，该中间人便可继续截获并阅读原本通信双方互发的信息。由于双方并非面对面通信，因此信息即使被截获和窃取，他们都不得而知。</p><p><strong>在线中间人攻击</strong>:您用笔记本电脑连接上了某个咖啡馆的免费公共Wi-Fi，并试图访问某个银行的网站。</p><h3 id="防止中间人攻击"><a href="#防止中间人攻击" class="headerlink" title="防止中间人攻击"></a>防止中间人攻击</h3><ul><li><p>使用HTTPS：确保您只访问那些使用着HTTPS的网站。如前所述，HTTPS提供了额外的安全保护层。在此，您可以考虑下载并安装Electronic Frontier Foundation的HTTPS Everywhere浏览器扩展程序。它是Google Chrome浏览器最好的隐私扩展程序之一。</p></li><li><p>不要忽略警告：如果您的浏览器提示，您正在访问的网站存在着安全问题，那么就请引起足够的重视。毕竟安全证书警告可以帮您直观地判定，您的登录凭据是否会被攻击者截获。</p></li><li><p>不要使用公共Wi-Fi：如果您无法避免使用公共Wi-Fi，那么请下载并安装安全防护，为连接增加安全性。同时，在使用公共Wi-Fi连接时，请留意浏览器的安全警告。如果警告的数量突然猛增，那么很可能就表明某个漏洞遭到了中间人攻击。</p></li><li><p>运行并更新防病毒软件：除了此外，也请考虑使用诸如Malwarebytes Premium之类的其他安全工具。</p></li></ul><h2 id="简述什么是-XSS-攻击以及-CSRF-攻击？"><a href="#简述什么是-XSS-攻击以及-CSRF-攻击？" class="headerlink" title="简述什么是 XSS 攻击以及 CSRF 攻击？"></a>简述什么是 XSS 攻击以及 CSRF 攻击？</h2><p><strong>XSS</strong>，即 Cross Site Script，中译是跨站脚本攻击；是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。</p><p>XSS攻击可以分为3类：反射型（非持久型）、存储型（持久型）、基于DOM。</p><p><strong>CSRF</strong>，即 Cross Site Request Forgery，中译是跨站请求伪造，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。</p><p>通常情况下，CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。</p><h2 id="如何防止传输内容被篡改？"><a href="#如何防止传输内容被篡改？" class="headerlink" title="如何防止传输内容被篡改？"></a>如何防止传输内容被篡改？</h2><h3 id="1-设置客户端IP黑-白名单"><a href="#1-设置客户端IP黑-白名单" class="headerlink" title="1.设置客户端IP黑/白名单"></a>1.设置客户端IP黑/白名单</h3><p>1.1.客户端所有请求，请求到代理服务器(nginx)，代理服务器维护黑/白名单的ip，决定是否转发请求。</p><p>1.2.项目创建一个filter，拦截所有请求，在filter的方法中，通过request信息匹配ip黑/白名单，和url的拦截规则，决定是否合法。</p><p>优点：简单粗暴。</p><p>缺点：需要客户端的IP固定。</p><p>应用场景：并发量小的场景。比如系统的后台管理服务，客服需要人工审批和通过涉及到钱财的业务，就可以使用这种简单粗暴的方式，防止账号泄露，接口泄露等等。</p><h3 id="2-请求参数Sign签名"><a href="#2-请求参数Sign签名" class="headerlink" title="2.请求参数Sign签名"></a>2.请求参数Sign签名</h3><p>2.1前端发起http请求，对参数排序，然后使用 参数与私钥拼接，在进行md5加密 等方式，生成一个签名出来，一起发给服务端，服务端这边获取到参数，签名，再使用自己的私钥进行同样方式的加密生成签名，比对签名是否一致。一致则认为合法，不一致则不合法。<strong>但是无法防止重复请求攻击！</strong></p><p>2.2针对上面方法升级，可以缓存每次请求的md5值，或者给每个请求添加uuid+随机数这样一个代表请求序号的标识。然后请求到服务端时，服务端想办法缓存起来起来这个标识，每次请求过来时，判断是否已经请求过。<strong>但是缓存怎么实现，如何维护？而且并发量高的话，每个请求过来都先查缓存，是否影响性能。</strong></p><p>2.3在请求的参数中和签名结果里，加入时间戳这个参数，业务服务器一方面比较签名结果，一方面根据时间戳，来认证请求的合法性，比如允许请求的时间戳与服务器当前时间，存在20秒的误差等自定义规则。超过20秒的合法请求，服务器也不处理，防止恶意的重复请求。</p><p>2.4时间戳+md51 时间差120s以上代表重复请求，md5写缓存，缓存时长120s（大于等于上面的值就行），判断如果有md5代表重复请求。</p><h3 id="3-请求方式换成Https"><a href="#3-请求方式换成Https" class="headerlink" title="3.请求方式换成Https"></a>3.请求方式换成Https</h3><h2 id="如何设计-API-接口使其实现幂等性？"><a href="#如何设计-API-接口使其实现幂等性？" class="headerlink" title="如何设计 API 接口使其实现幂等性？"></a>如何设计 API 接口使其实现幂等性？</h2><p><strong>所谓幂等，就是任意多次执行所产生的影响均与一次执行的影响相同。</strong></p><p><img src="https://i.loli.net/2021/10/24/Mfs1iRGut2BWYQZ.png" alt="image-20211024160432704"></p><ul><li><p>唯一主键索引实现幂等性</p></li><li><p>乐观锁实现幂等性</p></li><li><p>悲观锁实现幂等性</p></li><li><p>Token 令牌如何实现幂等性</p></li></ul><h2 id="简述-BGP-协议和-OSPF-协议的区别"><a href="#简述-BGP-协议和-OSPF-协议的区别" class="headerlink" title="简述 BGP 协议和 OSPF 协议的区别"></a>简述 BGP 协议和 OSPF 协议的区别</h2><ol><li>类型不同</li></ol><p>OSPF是无类别链路状态路由协议，属于IGP，工作也在一个AS内；</p><p>BGP是无类别路径矢量路由协议，属于EGP，工作在AS间</p><ol start="2"><li>作用不同</li></ol><p>OSPF是用来发现、计算路由的；</p><p>BGP是用来传递、控制路由的</p><h2 id="HTTP-是无状态的吗？需要保持状态的场景应该怎么做？"><a href="#HTTP-是无状态的吗？需要保持状态的场景应该怎么做？" class="headerlink" title="HTTP 是无状态的吗？需要保持状态的场景应该怎么做？"></a>HTTP 是无状态的吗？需要保持状态的场景应该怎么做？</h2><p>HTTP 是一种不保存状态，即无状态（stateless）协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。</p><ol><li><p>基于Session实现的会话保持</p><p>在会话开始时（客户端第一次像服务器发送http请求），服务器将会话状态保存起来（本机内存或数据库中），然后分配一个会话标识（SessionId）给客户端，这个会话标识一般保存在客户端Cookie中，以后每次浏览器发送http请求都会带上Cookie中的SessionId到服务器，服务器拿到会话标识就可以把之前存储在服务器端的状态信息与会话联系起来，实现会话保持（如果遇到浏览器禁用Cookie的情况，则可以通过url重写的方式将会话标识放在url的参数里，也可实现会话保持）.</p></li><li><p>基于Cookie实现的会话保持<br>基于Cookie实现会话保持与上述基于Session实现会话保持的最主要区别是前者完全将会话状态信息存储在浏览器Cookie中，这样一来每次浏览器发送</p></li></ol><h2 id="简述-TCP-协议的延迟-ACK-和累计应答"><a href="#简述-TCP-协议的延迟-ACK-和累计应答" class="headerlink" title="简述 TCP 协议的延迟 ACK 和累计应答"></a>简述 TCP 协议的延迟 ACK 和累计应答</h2><p>在收到数据以后并不立即返回确认应答，延迟一会，等待缓冲区中数据被处理，那么剩余的缓冲区就会大些——这是<strong>延迟应答</strong>。</p><p>那么所有的包都可以延迟应答么? 肯定也不是;</p><ul><li>数量限制: 每隔N个包就应答一次;</li><li>时间限制: 超过最大延迟时间就应答一次; 一般N取2, 超时时间取200ms;</li></ul><p>**捎带应答:**在延迟应答的基础上, 我们发现, 很多情况下, 客户端服务器在应用层也是 “一发一收” 的. 意味着客户端给服务器说了”How are you”, 服务器也会给客户端回一个 “Fine, thank you”;那么这个时候ACK就可以搭顺风车, 和服务器回应的 “Fine, thank you” 一起回给客户端。</p><h2 id="SSL握手流程为什么要使用非对称秘钥？"><a href="#SSL握手流程为什么要使用非对称秘钥？" class="headerlink" title="SSL握手流程为什么要使用非对称秘钥？"></a>SSL握手流程为什么要使用非对称秘钥？</h2><p><img src="https://i.loli.net/2021/10/24/47MHDzUfeZ3dItm.png" alt="image-20211024171449089"></p><h2 id="简述-WebSocket-是如何进行传输的"><a href="#简述-WebSocket-是如何进行传输的" class="headerlink" title="简述 WebSocket 是如何进行传输的"></a>简述 WebSocket 是如何进行传输的</h2><ul><li><p>浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，</p></li><li><p>连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。</p></li><li><p>当你获取 Web Socket 连接后，你可以通过 send() 方法来向服务器发送数据，</p></li><li><p>并通过 onmessage 事件来接收服务器返回的数据。</p></li></ul><h2 id="traceroute-有什么作用？"><a href="#traceroute-有什么作用？" class="headerlink" title="traceroute 有什么作用？"></a>traceroute 有什么作用？</h2><p>traceroute是诊断网络问题时常用的工具。</p><p>可以通过traceroute进行初步的检测，定位网络包在是在哪个节点丢失的，之后才可以进行针对性的处理。</p><h2 id="如何解决-TCP-传输丢包问题？"><a href="#如何解决-TCP-传输丢包问题？" class="headerlink" title="如何解决 TCP 传输丢包问题？"></a>如何解决 TCP 传输丢包问题？</h2><ol><li><p>数据分片：发送端对数据进行分片，接受端要对数据进行重组，由TCP确定分片的大小并控制分片和重组</p></li><li><p>到达确认：接收端接收到分片数据时，根据分片数据序号向发送端发送一个确认</p></li><li><p>超时重发：发送方在发送分片时设置超时定时器，如果在定时器超时之后没有收到相应的确认，重发分片数据</p></li><li><p>滑动窗口：TCP连接的每一方的接受缓冲空间大小固定，接收端只允许另一端发送接收端缓冲区所能接纳的数据，TCP在滑动窗口的基础上提供流量控制，防止较快主机致使较慢主机的缓冲区溢出</p></li><li><p>失序处理：作为IP数据报来传输的TCP分片到达时可能会失序，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层;</p></li><li><p>重复处理：作为IP数据报来传输的TCP分片会发生重复，TCP的接收端必须丢弃重复的数据;</p></li><li><p>数据校验：TCP将保持它首部和数据的检验和，这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到分片的检验或有差错，TCP将丢弃这个分片，并不确认收到此报文段导致对端超时并重发</p></li></ol><p>题目答案均为转载，题目先后顺序按各大厂总出题次数排列！</p>]]></content>
      
      
      <categories>
          
          <category> 面试技巧 </category>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议(二)</title>
      <link href="/2021/10/21/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE(%E4%BA%8C)/"/>
      <url>/2021/10/21/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="网络协议-二"><a href="#网络协议-二" class="headerlink" title="网络协议(二)"></a>网络协议(二)</h1><h2 id="DNS-查询服务器的基本流程是什么？DNS-劫持是什么？"><a href="#DNS-查询服务器的基本流程是什么？DNS-劫持是什么？" class="headerlink" title="DNS 查询服务器的基本流程是什么？DNS 劫持是什么？"></a>DNS 查询服务器的基本流程是什么？DNS 劫持是什么？</h2><p>DNS（Domain Names System），域名系统，是互联网一项服务，是进行域名和与之相对应的 IP 地址进行转换的服务器</p><p><img src="https://i.loli.net/2021/10/18/rfNsjWglJD7uFyI.png" alt="image-20211018173310316"></p><p>DNS 查询的方式有两种：</p><ul><li>递归查询：如果 A 请求 B，那么 B 作为请求的接收者一定要给 A 想要的答案</li></ul><p><img src="https://i.loli.net/2021/10/18/CiKrWdfMXzqeNBk.png" alt="image-20211018173402644"></p><ul><li>迭代查询：如果接收者 B 没有请求者 A 所需要的准确内容，接收者 B 将告诉请求者 A，如何去获得这个内容，但是自己并不去发出请求</li></ul><p><img src="https://i.loli.net/2021/10/18/uB7Jc1H9Qy6rVE4.png" alt="image-20211018173424792"></p><h3 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h3><p>解析域名的过程如下：</p><ul><li><p>首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表</p></li><li><p>若没有命中，则继续搜索操作系统的 DNS 缓存</p></li><li><p>若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果</p></li><li><p>若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询</p></li><li><p>首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器</p><ul><li>本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址</li><li>本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址</li><li>本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来</li></ul></li><li><p>操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起</p></li><li><p>至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起</p></li></ul><h3 id="什么是DNS劫持"><a href="#什么是DNS劫持" class="headerlink" title="什么是DNS劫持?"></a>什么是DNS劫持?</h3><p>DNS劫持又称域名劫持，是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能反应或访问的是假网址。</p><h3 id="预防DNS劫持"><a href="#预防DNS劫持" class="headerlink" title="预防DNS劫持?"></a>预防DNS劫持?</h3><p>修改默认的路由器登陆账号与密码</p><h2 id="Cookie-和-Session-的关系和区别是什么？"><a href="#Cookie-和-Session-的关系和区别是什么？" class="headerlink" title="Cookie 和 Session 的关系和区别是什么？"></a>Cookie 和 Session 的关系和区别是什么？</h2><p>(1)cookie数据存放在客户的浏览器上，session数据放在服务器上<br>(2)cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,如果主要考虑到安全应当使用session<br>(3)session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用COOKIE<br>(4)单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能3K。<br>(5)所以：将登陆信息等重要信息存放为SESSION;其他信息如果需要保留，可以放在COOKIE中</p><h2 id="简述-HTTPS-的加密与认证过程"><a href="#简述-HTTPS-的加密与认证过程" class="headerlink" title="简述 HTTPS 的加密与认证过程"></a>简述 HTTPS 的加密与认证过程</h2><h3 id="https加密过程"><a href="#https加密过程" class="headerlink" title="https加密过程"></a>https加密过程</h3><p><img src="https://i.loli.net/2021/10/18/4nuAhs5byHQapPL.png" alt="image-20211018185523161"></p><h3 id="服务端证书通过CA机构签名认证的过程如下"><a href="#服务端证书通过CA机构签名认证的过程如下" class="headerlink" title="服务端证书通过CA机构签名认证的过程如下"></a>服务端证书通过CA机构签名认证的过程如下</h3><p><img src="https://i.loli.net/2021/10/18/gozbp1Knc7fUra5.png" alt="image-20211018185655146"></p><h2 id="RestFul-是什么？RestFul-请求的-URL-有什么特点？"><a href="#RestFul-是什么？RestFul-请求的-URL-有什么特点？" class="headerlink" title="RestFul 是什么？RestFul 请求的 URL 有什么特点？"></a>RestFul 是什么？RestFul 请求的 URL 有什么特点？</h2><p>REST（Resource Representational State Transfer【表现层状态转化】）。如果一个架构符合REST原则，就称为RESTful架构，是一种<strong>面向资源的软件架构风格</strong></p><p>REST最大的几个特点为：资源、统一接口、URI和无状态。</p><p>资源：网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。资源总要通过某种载体反应其内容，文本可以用txt格式表现，也可以用HTML格式、XML格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现；JSON是现在最常用的资源表示格式。</p><blockquote><p>网络上的实体！</p></blockquote><p>统一接口：数据的元操作，即CRUD(create, read, update和delete,即数据的增删查改)操作，分别对应于HTTP方法：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源，这样就统一了数据操作的接口，仅通过HTTP方法，就可以完成对数据的所有增删查改工作。</p><blockquote><p>通过HTTP方法来确定并完成对实体的操作！</p></blockquote><p>URI：可以用一个URI（Universal Resource Identifier，统一资源定位符）指向资源，即每个URI都对应一个特定的资源。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或识别符。一般的，每个资源至少有一个URI与之对应，最典型的URI即URL。</p><blockquote><p>通过URI来识别不同的资源（实体）！</p></blockquote><p>无状态：所有的资源，都可以通过URI定位，而且这个定位与其他资源无关，也不会因为其他资源的变化而改变。<br>WebSocket是有状态的</p><blockquote><p>通过URI对资源（实体）操作时，无状态，没有上下文的影响！</p></blockquote><p>Resultful特点：<br>1.使用URL描述资源<br>2.使用HTTP方法描述行为。使用HTTP状态码来表示不同的结果<br>3.使用json交互数据，传统模式使用的是键值对形式<br>4.RESTful只是一种风格，并不是强制的标准。</p><h2 id="RestFul-与-RPC-的区别是什么？RestFul-的优点在哪里？"><a href="#RestFul-与-RPC-的区别是什么？RestFul-的优点在哪里？" class="headerlink" title="RestFul 与 RPC 的区别是什么？RestFul 的优点在哪里？"></a>RestFul 与 RPC 的区别是什么？RestFul 的优点在哪里？</h2><h3 id="RESTFUL-与RPC的区别"><a href="#RESTFUL-与RPC的区别" class="headerlink" title="RESTFUL 与RPC的区别"></a>RESTFUL 与RPC的区别</h3><p>1.restfull和rpc都是client/server模式的，都是在 Server端 把一个个函数封装成接口暴露出去</p><p>2.restful使用http协议实现，而rpc则不一定使用http，一般比较常用的是tcp， RPC 可以获得更好的性能（省去了 HTTP 报头等一系列东西）,TCP更加高效，而HTTP在实际应用中更加的灵活。</p><p>3.从使用上来说：Http接口只关注服务提供方（服务端），对于客户端怎么调用，调用方式怎样并不关心；而RPC服务则需要客户端接口与服务端保持一致，服务端提供一个方法，客户端通过接口直接发起调用。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><h4 id="RPC的优势："><a href="#RPC的优势：" class="headerlink" title="RPC的优势："></a>RPC的优势：</h4><ol><li>是查找的精确性，快速性，短路径，和确定性，因为属于内网查询，独立的注册中心，所以查找的速度更快。</li><li>而且由于做了精简和优化，删去了RESTful方式里面很多多余的信息，比如Header，而且做了压缩和序列化，通过二进制方式传输，传输的内容更少，传输的速度也更快。</li><li>环节和流程更少，因为RESTful需要经过路由，负载均衡，网关，防火墙和一系列的身份识别和校验，就像大楼内来了个不认识的人，楼管大叔肯定要查你的身份证等等信息核实你的信息。 而且RPC就省去了这些环节，就像你天天出来进去，楼管大妈早就对你很熟了，不需要每次核实你的信息，RPC省去了很多环节。</li></ol><h4 id="RESTful的优势："><a href="#RESTful的优势：" class="headerlink" title="RESTful的优势："></a>RESTful的优势：</h4><ol><li>通用性更好，RESTful可以供任何接入互联网的终端调用，各种平台，各种终端都可以用RESTful传输和交换数据，而且有一套标准和规范的传输格式，所以格式更加标准化和通用化。</li><li>安全性更高，因为属于连接外围和内网的通道，所以会经过一些列的安全和身份校验。</li><li>移植性更好，从一个服务器迁移到另一个服务器，从一个节点迁移到另一个节点，从一个架构移植到另一种架构，都可以轻松完成。</li></ol><ul><li><p>RPC的应用场景：当你的框架和语言种类也比较多，内部之间调用量非常大的时候，RPC是最佳的选择。RPC更多是内网之间的数据传输，一般是部署在服务层的分布式系统里面，或者微服务系统。有服务治理，服务限流、服务降级、服务熔断、服务监控等等，类似于大楼里面配了治安处，物业处、后勤处、监控中心等。</p></li><li><p>RESTful的应用场景：数据更多是公网上的传输，比如服务端API供 IOS、Android、PC等客户端调用， API供第三方合作方调用等 。</p></li></ul><h2 id="TCP-挥手时出现大量-CLOSE-WAIT-或-TIME-WAIT-怎么解决？"><a href="#TCP-挥手时出现大量-CLOSE-WAIT-或-TIME-WAIT-怎么解决？" class="headerlink" title="TCP 挥手时出现大量 CLOSE_WAIT 或 TIME_WAIT 怎么解决？"></a>TCP 挥手时出现大量 CLOSE_WAIT 或 TIME_WAIT 怎么解决？</h2><h3 id="TIME-WAIT状态"><a href="#TIME-WAIT状态" class="headerlink" title="TIME_WAIT状态"></a>TIME_WAIT状态</h3><p>主动断开方处于TIME_WAIT状态时，源端口无法使用<br> 端口最大数是65535，因此如果频繁主动断开TCP连接，将很快耗尽端口号。一旦达到了上限，则新的请求就无法被处理，接着就是大量Too Many Open Files异常，然后tomcat、nginx、apache崩溃<br>如何解决TIME_WAIT问题</p><h4 id="解决TIME-WAIT大量出现"><a href="#解决TIME-WAIT大量出现" class="headerlink" title="解决TIME_WAIT大量出现"></a>解决TIME_WAIT大量出现</h4><p>最核心的思想，就是打开系统的TIME_WAIT<strong>重用和快速回收</strong></p><p>net.ipv4.tcp_tw_recycle = 1表示开启TCP连接中TIME_WAIT sockets的快速回收，默认为0,表示关闭<br>net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME_WAIT sockets重新用于新的TCP连接，默认为0，表示关闭</p><h3 id="CLOSE-WAIT状态"><a href="#CLOSE-WAIT状态" class="headerlink" title="CLOSE_WAIT状态"></a>CLOSE_WAIT状态</h3><p>如果出现了CLOSE_WAIT<strong>过多</strong>的状态</p><p>1.在对方关闭连接后，自身程序里没有检测 -（被动方的角度）</p><p>2.本身忘了需要关闭连接，于是整个资源就一直被程序占用着。-（主动方的角度）</p><h4 id="如何解决CLOSE-WAIT问题"><a href="#如何解决CLOSE-WAIT问题" class="headerlink" title="如何解决CLOSE_WAIT问题"></a>如何解决CLOSE_WAIT问题</h4><p>关闭正在运行的程序<br>尽快修改程序bug,然后测试提交到线上服务器</p><h2 id="什么是跨域，什么情况下会发生跨域请求？"><a href="#什么是跨域，什么情况下会发生跨域请求？" class="headerlink" title="什么是跨域，什么情况下会发生跨域请求？"></a>什么是跨域，什么情况下会发生跨域请求？</h2><p>跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器施加的安全限制。</p><p>同源策略：所谓同源是指：协议，域名，端口均相同。即便两个不同的域名指向同一个ip地址，也非同源。</p><blockquote><p><a href="http://www.123.com/index.html%E8%B0%83%E7%94%A8">http://www.123.com/index.html调用</a> <a href="http://www.123.com/server.php">http://www.123.com/server.php</a> （非跨域）<br><a href="http://www.123.com/index.html">http://www.123.com/index.html</a> 调用 <a href="http://www.456.com/server.php">http://www.456.com/server.php</a> （主域名不同:123/456，跨域）<br><a href="http://abc.123.com/index.html">http://abc.123.com/index.html</a> 调用 <a href="http://def.123.com/server.php">http://def.123.com/server.php</a> （子域名不同:abc/def，跨域）<br><a href="http://www.123.com:8080/index.html">http://www.123.com:8080/index.html</a> 调用 <a href="http://www.123.com:8081/server.php">http://www.123.com:8081/server.php</a> （端口不同:8080/8081，跨域）<br><a href="http://www.123.com/index.html">http://www.123.com/index.html</a> 调用 <a href="https://www.123.com/server.php">https://www.123.com/server.php</a> （协议不同:http/https，跨域）<br>请注意：localhost和127.0.0.1虽然都指向本机，但也属于跨域。</p></blockquote><h2 id="简述对称与非对称加密的概念"><a href="#简述对称与非对称加密的概念" class="headerlink" title="简述对称与非对称加密的概念"></a>简述对称与非对称加密的概念</h2><p><strong>对称加密</strong>是最快速、最简单的一种加密方式，加密（encryption）与解密（decryption）用的是同样的密钥（secret key)</p><blockquote><p>常见的对称加密有DES、三 重DES、AES等</p></blockquote><p>非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥（public key）和私钥（private key)</p><ul><li>只能私钥加密公钥解密,或者公钥加密私钥解密;</li><li>一方保留密钥,一方公开密钥;不能同时公开,具体公开哪方需要根据实际情况来决定</li></ul><blockquote><p>非对称加密算法常见有:RSA算法(3个人名简写)和diffie - hellman算法(迪菲·赫尔曼算法)</p></blockquote><h2 id="HTTP-中-GET-和-POST-区别"><a href="#HTTP-中-GET-和-POST-区别" class="headerlink" title="HTTP 中 GET 和 POST 区别"></a>HTTP 中 GET 和 POST 区别</h2><p>1、GET 方法：从指定的资源请求数据。</p><p>请注意，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：</p><p>例如：<a href="https://www.xxxx.com/xxx.asp">https://www.xxxx.com/xxx.asp</a>? name1=value1&amp;name2=value2  </p><p>而需要注意的是：GET方法是可见的，而POST方法是在HTTP消息主体中发出的，具有不可见性。下面是一些GET的注释：</p><ul><li><p>请求可被缓存。</p></li><li><p>请求保留在浏览器历史记录中。</p></li><li><p>请求可被收藏为书签。</p></li><li><p>请求不应在处理敏感数据时使用</p></li><li><p>请求有长度限制</p></li><li><p>请求只应当用于取回数据</p></li><li><p>GET—&gt;application/x-www-form-urlencoded 。</p></li><li><p>GET—-&gt;只允许 ASCII 字符。</p></li></ul><p>2、POST 方法：向指定的资源提交要被处理的数据</p><p>  请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：</p><p>GET方法是可见的，而POST方法是在HTTP消息主体中发出的，具有不可见性。下面是一些 POST的注释：</p><ul><li><p>请求不会被缓存</p></li><li><p>请求不会保留在浏览器历史记录中</p></li><li><p>不能被收藏为书签</p></li><li><p>请求对数据长度没有要求</p></li><li><p>POST—&gt;application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 </p></li><li><p>POST—&gt; 没有限制。也允许二进制数据。</p></li></ul><h2 id="TCP-的-keepalive-了解吗？说一说它和-HTTP-的-keepalive-的区别？"><a href="#TCP-的-keepalive-了解吗？说一说它和-HTTP-的-keepalive-的区别？" class="headerlink" title="TCP 的 keepalive 了解吗？说一说它和 HTTP 的 keepalive 的区别？"></a>TCP 的 keepalive 了解吗？说一说它和 HTTP 的 keepalive 的区别？</h2><h3 id="TCP-Keepalive"><a href="#TCP-Keepalive" class="headerlink" title="TCP Keepalive"></a>TCP Keepalive</h3><p>链接建立之后，如果应用程序或者上层协议一直不发送数据，或者隔很长时间才发送一次数据，当链接很久没有数据报文传输时如何去确定对方还在线，到底是掉线了还是确实没有数据传输，链接还需不需要保持，这种情况在TCP协议设计中是需要考虑到的。</p><p>TCP协议通过一种巧妙的方式去解决这个问题，当超过一段时间之后，TCP自动发送一个数据为空的报文给对方，如果对方回应了这个报文，说明对方还在线，链接可以继续保持，如果对方没有报文返回，并且重试了多次之后则认为链接丢失，没有必要保持链接。</p><h3 id="TCP-Keepalive-HTTP-Keep-Alive-的关系"><a href="#TCP-Keepalive-HTTP-Keep-Alive-的关系" class="headerlink" title="TCP Keepalive HTTP Keep-Alive 的关系"></a>TCP Keepalive HTTP Keep-Alive 的关系</h3><p><strong>HTTP协议的Keep-Alive意图在于TCP连接复用，同一个连接上串行方式传递请求-响应数据；TCP的Keepalive机制意图在于探测连接的对端是否存活。</strong></p><p><img src="https://i.loli.net/2021/10/21/c8iT39hYKEu5JI4.png" alt="image-20211021104327114"></p><h2 id="简述常见的-HTTP-状态码的含义（301，304，401，403）"><a href="#简述常见的-HTTP-状态码的含义（301，304，401，403）" class="headerlink" title="简述常见的 HTTP 状态码的含义（301，304，401，403）"></a>简述常见的 HTTP 状态码的含义（301，304，401，403）</h2><p>200 OK ：服务器成功返回用户请求的数据。</p><p>201 CREATED ：用户新建或修改数据成功。</p><p>202 Accepted： 请求已被接受，但尚未处理。</p><p>301 Moved Permanently： 永久重定向。</p><p>304 Not Modified： 请求资源与本地缓存相同，未修改。</p><p>307/302 Temporary Redirect：临时重定向。不会从POST变成GET。</p><p>400 INVALID REQUEST ：用户发出的请求有错误。</p><p>401 Unauthorized ：用户没有权限。</p><p>403 Forbidden ：访问被禁止。</p><p>404 NOT FOUND ：请求针对的是不存在的记录。</p><p>406 Not Acceptable ：用户请求的的格式不正确。</p><p>500 INTERNAL SERVER ERROR ：服务器发生错误。</p><p>503 Service Unavailable：服务器暂时处于超负荷或正在进行停机维护，现在无法处理请求。</p><h2 id="简述-TCP-的-TIME-WAIT-和-CLOSE-WAIT"><a href="#简述-TCP-的-TIME-WAIT-和-CLOSE-WAIT" class="headerlink" title="简述 TCP 的 TIME_WAIT 和 CLOSE_WAIT"></a>简述 TCP 的 TIME_WAIT 和 CLOSE_WAIT</h2><p><strong>TIME_WAIT-主动关闭</strong></p><ul><li>TIME_WAIT 是主动关闭链接时形成的，等待2MSL时间，约4分钟。主要是防止最后一个ACK丢失。  由于TIME_WAIT 的时间会非常长，因此server端应尽量减少主动关闭连接</li></ul><p><strong>CLOSE_WAIT-被动关闭</strong></p><ul><li>CLOSE_WAIT是被动关闭连接是形成的。根据TCP状态机，服务器端收到客户端发送的FIN，则按照TCP实现发送ACK，因此进入CLOSE_WAIT状态。但如果服务器端不执行close()，就不能由CLOSE_WAIT迁移到LAST_ACK，则系统中会存在很多CLOSE_WAIT状态的连接。此时，可能是系统忙于处理读、写操作，而未将已收到FIN的连接，进行close。此时，recv/read已收到FIN的连接socket，会返回0。</li></ul><h2 id="简述-TCP-滑动窗口以及重传机制"><a href="#简述-TCP-滑动窗口以及重传机制" class="headerlink" title="简述 TCP 滑动窗口以及重传机制"></a>简述 TCP 滑动窗口以及重传机制</h2><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p><p>通常窗口的大小是由接收方的决定的。</p><p>发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。不是完全相等，接收窗口的大小是<strong>约等于</strong>发送窗口的大小的</p><h3 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h3><p><img src="https://i.loli.net/2021/10/21/L9vi6aKeN1mHX8k.png" alt="image-20211021164258042"></p><p>当某一段报文丢失了，图中（1001 - 2000）数据段丢失了，接受方没有接收到该数据段，则会一直的给发送方发送ACK（下一个是1001），如果发送端主机连续收到同样一个（下一个1001），就会将对应的数据（1001 - 2000）重新发送。<br>这时候如果接收端收到1001之后，再次返回的就是ACK（8001）了。之前的（2001 - 8000）都接收到了接受缓存区。<br>这种机制被称为“高速重发机制”（快速重传）</p><h2 id="简述-DDOS-攻击原理，如何防范它？"><a href="#简述-DDOS-攻击原理，如何防范它？" class="headerlink" title="简述 DDOS 攻击原理，如何防范它？"></a>简述 DDOS 攻击原理，如何防范它？</h2><p>整个过程可分为：</p><ol><li>扫描大量主机以寻找可入侵主机目标；</li><li>有安全漏洞的主机并获取控制权；</li><li>入侵主机中安装攻击程序；</li><li>用己入侵主机继续进行扫描和入侵。</li></ol><h4 id="DDoS攻击防御方法"><a href="#DDoS攻击防御方法" class="headerlink" title="DDoS攻击防御方法"></a><strong>DDoS攻击防御方法</strong></h4><p><strong>1. 过滤不必要的服务和端口：</strong>可以使用Inexpress、Express、Forwarding等工具来过滤不必要的服务和端口，即在路由器上过滤假IP。比如Cisco公司的CEF(Cisco Express Forwarding)可以针对封包Source IP和Routing Table做比较，并加以过滤。只开放服务端口成为目前很多服务器的流行做法，例如WWW服务器那么只开放80而将其他所有端口关闭或在防火墙上做阻止策略。</p><p><strong>2. 异常流量的清洗过滤：</strong>通过DDOS硬件防火墙对异常流量的清洗过滤，通过数据包的规则过滤、数据流指纹检测过滤、及数据包内容定制过滤等顶尖技术能准确判断外来访问流量是否正常，进一步将异常流量禁止过滤。单台负载每秒可防御800-927万个syn攻击包。</p><p><strong>3. 分布式集群防御：</strong>这是目前网络安全界防御大规模DDOS攻击的最有效办法。分布式集群防御的特点是在每个节点服务器配置多个IP地址（负载均衡），并且每个节点能承受不低于10G的DDOS攻击，如一个节点受攻击无法提供服务，系统将会根据优先级设置自动切换另一个节点，并将攻击者的数据包全部返回发送点，使攻击源成为瘫痪状态，从更为深度的安全防护角度去影响企业的安全执行决策。</p><p><strong>4. 高防智能DNS解析：</strong>高智能DNS解析系统与DDOS防御系统的完美结合，为企业提供对抗新兴安全威胁的超级检测功能。它颠覆了传统一个域名对应一个镜像的做法，智能根据用户的上网路线将DNS解析请求解析到用户所属网络的服务器。同时智能DNS解析系统还有宕机检测功能，随时可将瘫痪的服务器IP智能更换成正常服务器IP，为企业的网络保持一个永不宕机的服务状态。</p><p><strong>5.带宽资源要充足：</strong>带宽直接决定了抗DDOS攻击的能力，至少要选择100M带宽的，越多越好。</p><p><strong>6.服务器的硬件配置：</strong>在带宽以及流量有充分保障的前提下，服务器的硬件配置必须得跟上。当然，主要的因素还是CPU和内存</p><p><strong>7.搭建CDN：</strong>将内容缓存在终端用户附近</p><h2 id="简述-OSI-七层模型，TCP，IP-属于哪一层？"><a href="#简述-OSI-七层模型，TCP，IP-属于哪一层？" class="headerlink" title="简述 OSI 七层模型，TCP，IP 属于哪一层？"></a>简述 OSI 七层模型，TCP，IP 属于哪一层？</h2><p><strong>TCP，IP 属于传输层</strong></p><table><thead><tr><th>OSI七层模型</th><th>TCP/IP模型</th><th>功能</th><th>TCP/IP协议族</th></tr></thead><tbody><tr><td>应用层</td><td>应用层</td><td>直接向用户提供服务，完成用户希望完成的各种网络操作</td><td>HTTP，FTP，TFTP，DNS，Telnet，SMTP</td></tr><tr><td>表示层</td><td>进行数据编解码，数据加解密和格式转换</td><td>没有协议</td><td></td></tr><tr><td>会话层</td><td>解除或建立与别的节点的联系，组织和协调两个会话进程之间的通信，并对数据交换进行管理</td><td>没有协议</td><td></td></tr><tr><td>传输层</td><td>传输层</td><td>向两台主机中进程之间的通信提供通用的数据传输服务，实现端到端连接</td><td>TCP，UDP</td></tr><tr><td>网络层</td><td>网络层</td><td>为分组交换网上的不同主机提供通信服务，也就是进行IP选址和路由选择</td><td>IP，ICMP，RIP，IGMP</td></tr><tr><td>数据链路层</td><td>数据链路层</td><td>在物理层提供的比特流基础上，通过差错控制、流量控制的方法，将由差错的物理线路变为无差错的、能可靠传输数据帧的数据链路</td><td>SLIP，CSLIP，PPP，ARP，RARP，</td></tr><tr><td>物理层</td><td>物理层</td><td>利用传输介质为数据链路层提供物理连接，实现相邻计算机节点之间比特流的透明传输</td><td>IEEE802.1 A，IEEE802.2到IEEE802.11</td></tr></tbody></table><p>题目答案均为转载，题目先后顺序按各大厂总出题次数排列！</p>]]></content>
      
      
      <categories>
          
          <category> 面试技巧 </category>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议(一)</title>
      <link href="/2021/10/18/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE(%E4%B8%80)/"/>
      <url>/2021/10/18/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="网络协议-一"><a href="#网络协议-一" class="headerlink" title="网络协议(一)"></a>网络协议(一)</h1><h2 id="简述-TCP-三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？"><a href="#简述-TCP-三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？" class="headerlink" title="简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？"></a>简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？</h2><p><img src="https://i.loli.net/2021/10/18/GDsdkzVbKlrFgpZ.png" alt="image-20211018110043768"></p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ul><li><p>第一次握手</p><p>客户端给服务器发送一个SYN段(在 TCP 标头中 SYN 位字段为 1 的 TCP/IP 数据包), 该段中也包含客户端的初始序列号(Sequence number (Seq)= J)。</p><blockquote><p>SYN是同步的缩写，SYN 段是发送到另一台计算机的 TCP 数据包，请求在它们之间建立连接</p></blockquote><p>SYN = j , Seq = k</p></li><li><p>第二次握手<br>服务器返回客户端 SYN +ACK 段(在 TCP 标头中SYN和ACK位字段都为 1 的 TCP/IP 数据包)， 该段中包含服务器的初始序列号(Sequence number(Seq) = K)；同时使 Acknowledgment number = J + 1来表示确认已收到客户端的 SYN段(Sequence number = J)。</p><blockquote><p>ACK 是“确认”的缩写。 ACK 数据包是任何确认收到一条消息或一系列数据包的 TCP 数据包</p></blockquote><p>SYN  = j, Seq =y, ACK= k+1</p></li><li><p>第三次握手<br>客户端给服务器响应一个ACK段(在 TCP 标头中 ACK 位字段为 1 的 TCP/IP 数据包), 该段中使 Acknowledgment number = K + 1来表示确认已收到服务器的 SYN段(Sequence number(Seq) = K)。</p><p>ACK= y+1</p></li></ul><h3 id="为什么三次？"><a href="#为什么三次？" class="headerlink" title="为什么三次？"></a>为什么三次？</h3><ol><li><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p></li><li><p>换个易于理解的视角来看为什么要 3 次握手。</p><p>客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。</p></li></ol><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="https://i.loli.net/2021/10/18/R5pbFzeuPY3NWhZ.png" alt="image-20211018111059274"></p><ul><li>客户端发送一个 FIN 段，并包含一个希望接收者看到的自己当前的序列号 K. 同时还包含一个 ACK 表示确认对方最近一次发过来的数据。</li><li>服务端将 K 值加 1 作为 ACK 序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。</li><li>服务端发起自己的 FIN 段，ACK=K+1, Seq=L。</li><li>客户端确认。进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。ACK=L+1。</li></ul><h3 id="为什么关闭连接却是四次挥手"><a href="#为什么关闭连接却是四次挥手" class="headerlink" title="为什么关闭连接却是四次挥手?"></a>为什么关闭连接却是四次挥手?</h3><ol><li><p>TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令<strong>告知对方，我要关闭连接</strong>了。</p></li><li><p><strong>这时对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，也就是说，服务端收到客户端的 FIN 标志，知道客户端想要断开这次连接了，但是，我服务端，我还想发数据呢？我等到发送完了所有的数据后，会发送一个 FIN 段来关闭此方向上的连接。接收方发送 ACK确认关闭连接。</strong></p><p>注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解“上层的意志”。</p></li><li><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是<strong>为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</strong></p></li><li><p>因为服务端在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。而<strong>关闭连接时，当收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据</strong>，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方 ACK 和 FIN 一般都会分开发。</p></li></ol><h2 id="HTTP-与-HTTPS-有哪些区别？"><a href="#HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="HTTP 与 HTTPS 有哪些区别？"></a>HTTP 与 HTTPS 有哪些区别？</h2><p>1、HTTPS  协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(以前的网易官网是http，而网易邮箱是 https 。)</p><p>2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。</p><p>3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>4、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)</p><p>注意：</p><p>(1) 采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问。这套证书其实就是一对公钥和私钥。</p><p>(2) 互联网有太多的服务需要使用证书来验证身份，以至于客户端（操作系统或浏览器等）无法内置所有证书，需要通过服务端将证书发送给客户端。</p><p>(3) 客户端内置的是 CA 的根证书(Root Certificate)，HTTPS 协议中服务器会发送证书链（Certificate Chain）给客户端。</p><p><strong>数据传输的机密性</strong>:包含自己支持的非对成加密的密钥交换算法 ( 一般是<a href="https://baike.baidu.com/item/RSA/210678">RSA</a>)，数据签名摘要算法 ( 一般是<a href="https://baike.baidu.com/item/SHA/9533316">SHA</a>或者<a href="https://baike.baidu.com/item/MD5/212708">MD5</a>) ，加密传输数据的对称加密算法 ( 一般是<a href="https://baike.baidu.com/item/DES/210508">DES</a>)，以及加密密钥的长度。<br>非对称加密公钥和私钥的使用方法：(1) 公钥加密私钥解密。(2) 私钥做数字签名，公钥验证。</p><h2 id="从输入-URL-到展现页面的全过程"><a href="#从输入-URL-到展现页面的全过程" class="headerlink" title="从输入 URL 到展现页面的全过程"></a>从输入 URL 到展现页面的全过程</h2><ol><li><p>输入url地址</p></li><li><p>应用层进行DNS解析</p></li><li><p>应用层生成HTTP请求报文</p></li><li><p>传输层建立TCP连接</p></li><li><p>网络层使用IP协议来选择路线</p></li><li><p>数据链路层实现网络相邻节点间可靠的数据通信</p></li><li><p>物理层传输数据</p></li><li><p>服务器处理反向传输</p></li><li><p>服务器返回一个 HTTP 响应</p></li><li><p>浏览器渲染</p></li></ol><h2 id="TCP-与-UDP-在网络协议中的哪一层，他们之间有什么区别？"><a href="#TCP-与-UDP-在网络协议中的哪一层，他们之间有什么区别？" class="headerlink" title="TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？"></a>TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？</h2><p>TCP与UDP都在<span style='color:red'>传输层</span></p><p><strong>用户数据报协议 UDP（User Datagram Protocol）</strong></p><p>是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</p><p><strong>传输控制协议 TCP（Transmission Control Protocol）</strong></p><p>是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</p><h2 id="TCP-怎么保证可靠传输？"><a href="#TCP-怎么保证可靠传输？" class="headerlink" title="TCP 怎么保证可靠传输？"></a>TCP 怎么保证可靠传输？</h2><p>TCP主要提供了检验和、序列号/确认应答、超时重传、最大消息长度、滑动窗口控制等方法实现了可靠性传输。</p><ul><li><strong>校验和：</strong></li></ul><p>发送的数据包的二进制相加然后取反，<strong>目的是检测数据在传输过程中的任何变化</strong>。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。 </p><ul><li><strong>确认应答+序列号（累计确认+seq）：</strong></li></ul><p>接收方收到报文就会确认（累积确认：对所有按序接收的数据的确认）</p><p>TCP给发送的<strong>每一个包进行编号</strong>，接收方<strong>对数据包进行排序</strong>，把有序数据传送给应用层。 </p><ul><li><strong>超时重传：</strong></li></ul><p>当TCP<strong>发出一个段后，它启动一个定时器</strong>，<strong>等待目的端确认收到这个报文段</strong>。<strong>如果不能及时收到一个确认，将重发这个报文段</strong>。 </p><ul><li><strong>流量控制：</strong></li></ul><p><strong>TCP连接的每一方都有固定大小的缓冲空间</strong>，TCP的<strong>接收端只允许发送端发送接收端缓冲区能接纳的数据</strong>。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。</p><p><strong>接收方有即时窗口（滑动窗口），随ACK报文发送</strong></p><ul><li><strong>拥塞控制：</strong></li></ul><p>当网络拥塞时，减少数据的发送。</p><p><strong>发送方有拥塞窗口，发送数据前比对接收方发过来的即使窗口，取小</strong></p><h2 id="简述-HTTP-1-0，1-1，2-0-的主要区别"><a href="#简述-HTTP-1-0，1-1，2-0-的主要区别" class="headerlink" title="简述 HTTP 1.0，1.1，2.0 的主要区别"></a>简述 HTTP 1.0，1.1，2.0 的主要区别</h2><p>HTTP1.0与HTTP 1.1的主要区别</p><ol><li>长连接</li><li>节约带宽</li><li>HOST域</li></ol><ul><li><p><strong>缓存处理：</strong>在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</p></li><li><p><strong>带宽优化及网络连接的使用：</strong>HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p></li><li><p><strong>错误通知的管理：</strong>在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p></li><li><p><strong>Host头处理：</strong>在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p></li><li><p><strong>长连接：</strong>HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p><h2 id="HTTP-1-x与HTTP-2区别"><a href="#HTTP-1-x与HTTP-2区别" class="headerlink" title="HTTP / 1.x与HTTP / 2区别"></a>HTTP / 1.x与HTTP / 2区别</h2></li></ul><p>HTTP1.1与HTTP 2.0的主要区别</p><ol><li>多路复用</li><li>二进制分帧</li><li>首部压缩</li><li>服务器推送</li></ol><ul><li><p><strong>服务端推送：</strong>它引入了服务器推送的概念，其中服务器预计客户端将需要的资源，并在客户端发出请求之前将其推送。客户端保留拒绝服务器推送的权限；但是，在大多数情况下，此功能可大大提高流程效率。</p></li><li><p><strong>多路复用</strong>：该概念交错了请求和响应，而没有行头阻塞，并且通过单个TCP连接来完成。</p></li><li><p><strong>新的二进制格式：</strong>它是一种二进制协议，即仅以0和1形式的二进制命令通过网络传输。二进制成帧层将消息划分为多个帧，这些帧根据其类型（数据或报头）进行分离。此功能在安全性，压缩和多路复用方面大大提高了效率。</p></li><li><p><strong>header压缩：</strong>HTTP / 2使用HPACK标头压缩算法，该算法可抵御像CRIME这样的攻击，并利用静态霍夫曼编码。</p></li></ul><h2 id="TCP-中常见的拥塞控制算法有哪些？"><a href="#TCP-中常见的拥塞控制算法有哪些？" class="headerlink" title="TCP 中常见的拥塞控制算法有哪些？"></a>TCP 中常见的拥塞控制算法有哪些？</h2><p>拥塞控制主要是四个算法：1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复。</p><p><img src="https://i.loli.net/2021/10/18/aY8qfFDEJAoVSMm.png" alt="image-20211018121313295"></p><h3 id="1-慢启动算法-Slow-Start"><a href="#1-慢启动算法-Slow-Start" class="headerlink" title="1.慢启动算法 - Slow Start"></a>1.慢启动算法 - Slow Start</h3><p>在 TCP 连接刚建立时，一点一点提速，先试探网络的状况，避免扰乱了网络通道的秩序。<br>慢启动是指一开始向网络注入的报文段少，并不是指拥塞窗口 cwnd 增长速度慢。</p><ul><li><strong>慢启动算法：</strong></li></ul><ol><li><p>连接建好的开始先初始化拥塞窗口的 cwnd 大小为 1，表明可以传送一个 MSS 大小的数据。</p></li><li><p>每当收到一个 ACK，cwnd 大小加 1，呈线性上升。</p></li><li><p>每当过了一个往返延迟时间 RTT(Round-Trip TIme),cwnd 大小直接翻倍，乘以 2，呈指数上升。</p></li><li><p>还有一个 ssthresh(slow start threshold)，是一个上限(阈值)，当 cwnd &gt;= ssthresh 时就会进入“拥塞避免算法”。</p><p><img src="https://i.loli.net/2021/10/18/pVGdt38BfCUkh57.png" alt="image-20211018121346465"></p></li></ol><h3 id="2-拥塞避免算法-Congestion-Avoidance"><a href="#2-拥塞避免算法-Congestion-Avoidance" class="headerlink" title="2. 拥塞避免算法- Congestion Avoidance"></a>2. 拥塞避免算法- Congestion Avoidance</h3><p>当窗口大小 cwnd &gt;= 慢启动的阈值后，就会进入拥塞避免算法。<br>拥塞避免 不能完全避免拥塞，而是指在拥塞避免阶段将拥塞窗口控制为线性增长，避免窗口增长过快导致窗口拥塞。缓慢的增加调整到最佳状态，使网络比较不容易出现拥塞。</p><ul><li><strong>拥塞避免算法：</strong></li></ul><ol><li>收到一个 ACK，则 cwnd = cwnd + 1/cwnd</li><li>每当经过了一个往返延迟时间 RTT，cwnd 大小加 1。</li></ol><h3 id="3-拥塞状态时的算法"><a href="#3-拥塞状态时的算法" class="headerlink" title="3.拥塞状态时的算法"></a>3.拥塞状态时的算法</h3><p>TCP 拥塞控制默认认为网络丢包是由于网络拥塞导致的，所以一般的 TCP 拥塞控制算法以丢包为网络进入拥塞状态的信号。对于丢包有两种判断方式，<strong>一种是超时重传 RTO(Retransmission Timeout)超时，另一个是收到三个重复确认 ACK</strong>。</p><ul><li><strong>超时重传 RTO(Retransmission Timeout)超时，TCP 会重传数据包。TCP 认为这种情况比较糟糕，反应也比较激烈：</strong></li></ul><ol><li>由于发生丢包，将慢启动阈值(ssthresh)设置为当前 cwnd 的一半，即 ssthresh = cwnd / 2</li><li>cwnd 重置为 1</li><li>进入慢启动过程</li></ol><p>早期的 TCP Tahoe 算法就是使用上述处理方法，由于一丢包就一切重来，导致 cwnd 又重置为 1，十分不利于网络数据的稳定传递。<br>所以，TCP Reno 算法进行了优化。当收到三个重复确认 ACK 时，TCP 开启快速重传 Fast Retransmit 算法，而不用等到 RTO 超时再进行重传</p><ul><li><strong>三个重复确认 ACK：</strong></li></ul><ol><li>cwnd 大小缩减为当前的一半。</li><li>ssthresh 设置为缩小后的 cwnd 大小</li><li>进入快速恢复算法 Fast Recovery。</li></ol><p><img src="https://i.loli.net/2021/10/18/3IQ96BPRySJpXzv.png" alt="image-20211018121405441"></p><h3 id="4-快速恢复算法-Fast-Recovery"><a href="#4-快速恢复算法-Fast-Recovery" class="headerlink" title="4.快速恢复算法 - Fast Recovery"></a>4.快速恢复算法 - Fast Recovery</h3><p>TCP Tahoe 是早期的算法，所以没有快速恢复算法，而 Reno 算法有。在进入快速恢复之前，cwnd 和 ssthresh 已经被改为原有的 cwnd 的一半。</p><ol><li>cwnd = cwnd + 3 MSS，加 3 MSS 的原因是收到 3 个重复的 ACK。</li><li>重传 DACKs 指定数据包。</li><li>如果再收到 DACKs，那么 cwnd 大小增加 1。</li><li>如果收到新的 ACK，表明重传的包成功了，退出快速恢复算法。将 cwnd 设置为 ssthresh，然后进入拥塞避免算法。</li></ol><h2 id="什么是-TCP-粘包和拆包？"><a href="#什么是-TCP-粘包和拆包？" class="headerlink" title="什么是 TCP 粘包和拆包？"></a>什么是 TCP 粘包和拆包？</h2><p>假设 Client 向 Server 连续发送了两个数据包，用 packet1 和 packet2 来表示，那么服务端收到的数据可以分为三种情况，现列举如下：</p><p>第一种情况，接收端正常收到两个数据包，即没有发生拆包和粘包的现象。</p><p><img src="https://i.loli.net/2021/10/18/zoRirExaU2FysJM.png" alt="image-20211018112224687"></p><p>第二种情况，接收端只收到一个数据包，但是这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。</p><p><img src="https://i.loli.net/2021/10/18/H6k3laKcndSpg58.png" alt="image-20211018112231807"></p><p>第三种情况，这种情况有两种表现形式，如下图。接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。</p><p><img src="https://i.loli.net/2021/10/18/aXHKL9B3hVo5vts.png" alt="image-20211018112240880"></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h2 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h2><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><h2 id="计网七层模型"><a href="#计网七层模型" class="headerlink" title="计网七层模型"></a>计网七层模型</h2><table><thead><tr><th>OSI七层模型</th><th>TCP/IP模型</th><th>功能</th><th>TCP/IP协议族</th></tr></thead><tbody><tr><td>应用层</td><td>应用层</td><td>直接向用户提供服务，完成用户希望完成的各种网络操作</td><td>HTTP，FTP，TFTP，DNS，Telnet，SMTP</td></tr><tr><td>表示层</td><td>进行数据编解码，数据加解密和格式转换</td><td>没有协议</td><td></td></tr><tr><td>会话层</td><td>解除或建立与别的节点的联系，组织和协调两个会话进程之间的通信，并对数据交换进行管理</td><td>没有协议</td><td></td></tr><tr><td>传输层</td><td>传输层</td><td>向两台主机中进程之间的通信提供通用的数据传输服务，实现端到端连接</td><td>TCP，UDP</td></tr><tr><td>网络层</td><td>网络层</td><td>为分组交换网上的不同主机提供通信服务，也就是进行IP选址和路由选择</td><td>IP，ICMP，RIP，IGMP</td></tr><tr><td>数据链路层</td><td>数据链路层</td><td>在物理层提供的比特流基础上，通过差错控制、流量控制的方法，将由差错的物理线路变为无差错的、能可靠传输数据帧的数据链路</td><td>SLIP，CSLIP，PPP，ARP，RARP，</td></tr><tr><td>物理层</td><td>物理层</td><td>利用传输介质为数据链路层提供物理连接，实现相邻计算机节点之间比特流的透明传输</td><td>IEEE802.1 A，IEEE802.2到IEEE802.11</td></tr></tbody></table><h2 id="UDP-、TCP-首部格式"><a href="#UDP-、TCP-首部格式" class="headerlink" title="UDP 、TCP 首部格式"></a>UDP 、TCP 首部格式</h2><h3 id="TCP协议首部格式"><a href="#TCP协议首部格式" class="headerlink" title="TCP协议首部格式"></a>TCP协议首部格式</h3><p><img src="https://i.loli.net/2021/10/18/2oIwAzLHYu4x7XQ.png" alt="image-20211018103946071"></p><p>TCP 首部格式比 UDP 复杂。</p><p><strong>序号：</strong>用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p><p><strong>确认号：</strong>期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p><p><strong>数据偏移：</strong>指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p><p><strong>控制位：</strong>八位从左到右分别是 CWR，ECE，URG，ACK，PSH，RST，SYN，FIN。</p><p><strong>CWR：</strong>CWR 标志与后面的 ECE 标志都用于 IP 首部的 ECN 字段，ECE 标志为 1 时，则通知对方已将拥塞窗口缩小；</p><p><strong>ECE：</strong>若其值为 1 则会通知对方，从对方到这边的网络有阻塞。在收到数据包的 IP 首部中 ECN 为 1 时将 TCP 首部中的 ECE 设为 1；</p><p><strong>URG：</strong>该位设为 1，表示包中有需要紧急处理的数据，对于需要紧急处理的数据，与后面的紧急指针有关；</p><p><strong>ACK：</strong>该位设为 1，确认应答的字段有效，TCP规定除了最初建立连接时的 SYN 包之外该位必须设为 1；</p><p><strong>PSH：</strong>该位设为 1，表示需要将收到的数据立刻传给上层应用协议，若设为 0，则先将数据进行缓存；</p><p><strong>RST：</strong>该位设为 1，表示 TCP 连接出现异常必须强制断开连接；</p><p><strong>SYN：</strong>用于建立连接，该位设为 1，表示希望建立连接，并在其序列号的字段进行序列号初值设定；</p><p><strong>FIN：</strong>该位设为 1，表示今后不再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位置为 1 的 TCP 段。</p><p>每个主机又对对方的 FIN 包进行确认应答之后可以断开连接。不过，主机收到 FIN 设置为 1 的 TCP 段之后不必马上回复一个 FIN 包，而是可以等到缓冲区中的所有数据都因为已成功发送而被自动删除之后再发 FIN 包；</p><p><strong>窗口：</strong>窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p><h3 id="UDP协议首部格式"><a href="#UDP协议首部格式" class="headerlink" title="UDP协议首部格式"></a>UDP协议首部格式</h3><p><img src="https://i.loli.net/2021/10/18/8bTXnoSEcUJ91Vm.png" alt="image-20211018104116091"></p><p>UDP首部有8个字节，由4个字段构成，每个字段都是两个字节，<br>1.源端口号： 可有可无，需要对方回信时选用，不需要时全部置0。<br>2.目的端口号：必须有，在终点交付报文的时候需要用到。<br>3.长度：UDP的数据报的长度（包括首部和数据）其最小值为8字节（只有首部）。<br>4.校验和：检测UDP数据报在传输中是否有错，有错则丢弃。<br>该字段是可选的，当源主机不想计算校验和，则直接令该字段全为0。<br>当传输层从IP层收到UDP数据报时，就根据首部中的目的端口，把UDP数据报通过相应的端口，上交给应用进程。<br>如果接收方UDP发现收到的报文中的目的端口号不正确（不存在对应端口号的应用进程0,），就丢弃该报文，并由ICMP发送“端口不可达”差错报文给对方。</p><h2 id="为什么常说-TCP-有粘包和拆包的问题而不说-UDP-？"><a href="#为什么常说-TCP-有粘包和拆包的问题而不说-UDP-？" class="headerlink" title="为什么常说 TCP 有粘包和拆包的问题而不说 UDP ？"></a>为什么常说 TCP 有粘包和拆包的问题而不说 UDP ？</h2><p>UDP 是基于报文发送的，UDP首部采用了 16bit 来指示 UDP 数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。</p><p>而 TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 并没有把这些数据块区分边界，仅仅是一连串没有结构的字节流；另外从 TCP 的帧结构也可以看出，在 TCP 的首部没有表示数据长度的字段，基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。</p><h2 id="为什么会发生-TCP-粘包、拆包？"><a href="#为什么会发生-TCP-粘包、拆包？" class="headerlink" title="为什么会发生 TCP 粘包、拆包？"></a>为什么会发生 TCP 粘包、拆包？</h2><ul><li>要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。</li><li>待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。</li><li>要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。</li><li>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。</li></ul><h2 id="粘包、拆包解决办法"><a href="#粘包、拆包解决办法" class="headerlink" title="粘包、拆包解决办法"></a>粘包、拆包解决办法</h2><p>由于 TCP 本身是面向字节流的，无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，归纳如下：</p><ul><li><strong>消息定长：</strong>发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</li><li><strong>设置消息边界：</strong>服务端从网络流中按消息边界分离出消息内容。在包尾增加回车换行符进行分割，例如 FTP 协议。</li><li><strong>将消息分为消息头和消息体：</strong>消息头中包含表示消息总长度（或者消息体长度）的字段。</li><li>更复杂的应用层协议比如 Netty 中实现的一些协议都对粘包、拆包做了很好的处理。</li></ul><h2 id="TCP-滑动窗口"><a href="#TCP-滑动窗口" class="headerlink" title="TCP 滑动窗口"></a>TCP 滑动窗口</h2><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p><p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p><p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p><p><img src="https://i.loli.net/2021/10/18/8gMoY4xip93WjtD.png" alt="image-20211018121614865"></p><p>题目答案均为转载，题目先后顺序按各大厂总出题次数排列！</p>]]></content>
      
      
      <categories>
          
          <category> 面试技巧 </category>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Steam流</title>
      <link href="/2021/10/01/Java-steam%E6%B5%81/"/>
      <url>/2021/10/01/Java-steam%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Java-Steam流"><a href="#Java-Steam流" class="headerlink" title="Java Steam流"></a>Java Steam流</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。</p><p>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。</p><p>首先要澄清的是 java8 中的 Stream 与 I/O 流 InputStream 和 OutputStream 是完全不同的概念。<br>Stream 机制是针对集合迭代器的增强。</p><h2 id="创建对象流的三种方式"><a href="#创建对象流的三种方式" class="headerlink" title="创建对象流的三种方式"></a>创建对象流的三种方式</h2><p>由集合对象创建流。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = list.stream();</span><br></pre></td></tr></table></figure><p>数组创建流。通过静态方法 <strong>Arrays.stream()</strong> 将数组转化为流</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream stream = Arrays.stream(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure><p>通过静态方法 <strong>Stream.of()</strong> ，但是底层其实还是调用 <code>Arrays.stream()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>注意：<br>还有两种比较特殊的流</p><ul><li>空流：<strong>Stream.empty()</strong></li><li>无限流：<strong>Stream.generate()</strong> 和 **Stream.iterate()**。可以配合 <strong>limit()</strong> 使用可以限制一下数量</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接受一个 Supplier 作为参数</span></span><br><span class="line">Stream.generate(Math::random).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">// 初始值是 0，新值是前一个元素值 + 2</span></span><br><span class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="流处理的特性"><a href="#流处理的特性" class="headerlink" title="流处理的特性"></a>流处理的特性</h2><ol><li><p>不存储数据</p></li><li><p>不会改变数据源</p></li><li><p>不可以重复使用</p><p>重复利用会抛出一个 <strong>IllegalStateException</strong> 的异常：</p><p><span style='color:red;'>java.lang.IllegalStateException: stream has already been operated upon or closed</span></p></li></ol><p>源数据流经管道，最后输出结果数据。</p><p><img src="https://i.loli.net/2021/10/01/uB6e9AvspgfDzNi.png" alt="image-20211001142843051"></p><h2 id="操作类型"><a href="#操作类型" class="headerlink" title="操作类型"></a>操作类型</h2><p>Stream 的所有操作连起来组合成了管道，管道有两种操作：<br>第一种，中间操作（intermediate）。调用中间操作方法返回的是一个新的流对象。中间操作不会输出值。<br>第二种，终值操作（terminal）。在调用该方法后，将执行之前所有的中间操作，并返回结果。</p><p><span style='background:yellow;color:red'>通过连续执行多个操作倒便就组成了 Stream 中的执行管道（pipeline）。需要注意的是这些管道被添加后并不会真正执行，只有等到调用终值操作之后才会执行。</span></p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ul><li>forEach：该方法用于对 Stream 中的每个元素进行迭代操作。</li><li>map：该方法用于将每个元素映射到对应的结果上。</li><li>filter：该方法用于过滤满足条件的元素。</li><li>limit(n)：获取前n个元素</li><li>skip(n)：跳过前n元素，配合limit(n)可实现分页</li><li>sorted()：自然排序，流中元素需实现Comparable接口</li><li>sorted(Comparator com)：定制排序，自定义Comparator排序器</li><li>distinct：通过流中元素的 <code>hashCode() 和 equals()</code> 去除重复元素</li><li>peek：逐个执行-中间操作</li><li>forEach()：遍历操作-终值操作</li><li>allMatch全部符合该条件返回true</li><li>noneMatch全部不符合该断言返回true</li><li>anyMatch 任意一个元素符合该断言返回true</li><li>allMatch全部符合该条件返回true</li><li>noneMatch全部不符合该断言返回true</li><li>anyMatch 任意一个元素符合该断言返回true</li><li>findFirst：返回流中第一个元素</li><li>findAny：返回流中的任意元素</li><li>count：返回流中元素的总个数</li><li>max：返回流中元素最大值</li><li>min：返回流中元素最小值</li></ul><ul><li>limit skip distinct sorted 都是有状态操作，这些操作只有拿到前面处理后的所有元素之后才能继续下去。</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><h4 id="Apply实体类"><a href="#Apply实体类" class="headerlink" title="Apply实体类"></a>Apply实体类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer appleId;   <span class="comment">//苹果编号</span></span><br><span class="line">        <span class="keyword">private</span> String appleName;  <span class="comment">//苹果类型</span></span><br><span class="line">        <span class="keyword">private</span> String location;   <span class="comment">//苹果产地</span></span><br><span class="line">        <span class="keyword">private</span> Integer weight;    <span class="comment">//苹果重量</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(Integer appleId, String appleName, String location, Integer weight)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.appleId = appleId;</span><br><span class="line">            <span class="keyword">this</span>.appleName = appleName;</span><br><span class="line">            <span class="keyword">this</span>.location = location;</span><br><span class="line">            <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//get set省略</span></span><br></pre></td></tr></table></figure><h4 id="流实现举例"><a href="#流实现举例" class="headerlink" title="流实现举例"></a>流实现举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Apple&gt; collect = list.stream().filter(apple -&gt; apple.weight &gt; <span class="number">5</span>).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        System.out.println(collect);</span><br><span class="line">        <span class="comment">//[Apple&#123;appleId=4, appleName=&#x27;红苹果&#x27;, location=&#x27;海南&#x27;, weight=8&#125;, Apple&#123;appleId=5, appleName=&#x27;青苹果&#x27;, location=&#x27;广东&#x27;, weight=10&#125;]</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; names = list.stream().map(apple -&gt; apple.appleName).collect(Collectors.toList());</span><br><span class="line">        System.out.println(names);</span><br><span class="line">        <span class="comment">//[红苹果, 红苹果, 红苹果, 红苹果, 青苹果, 青苹果]</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; distinctName = names.stream().distinct().collect(Collectors.toList());</span><br><span class="line">        System.out.println(distinctName);</span><br><span class="line">        <span class="comment">//[红苹果, 青苹果]</span></span><br><span class="line"></span><br><span class="line">        list.stream().limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">        <span class="comment">//Apple&#123;appleId=1, appleName=&#x27;红苹果&#x27;, location=&#x27;广东&#x27;, weight=5&#125;</span></span><br><span class="line">        <span class="comment">//Apple&#123;appleId=2, appleName=&#x27;红苹果&#x27;, location=&#x27;广东&#x27;, weight=5&#125;</span></span><br><span class="line">        <span class="comment">//Apple&#123;appleId=3, appleName=&#x27;红苹果&#x27;, location=&#x27;海南&#x27;, weight=4&#125;</span></span><br><span class="line"></span><br><span class="line">        list.stream().filter(apple -&gt; apple.getAppleName().equals(<span class="string">&quot;青苹果&quot;</span>))</span><br><span class="line">                .peek(apple -&gt; System.out.println(<span class="string">&quot;苹果筛选1：&quot;</span>+ apple))</span><br><span class="line">                .filter(apple -&gt; apple.getWeight()&gt;<span class="number">5</span>)</span><br><span class="line">                .peek(apple -&gt; System.out.println(<span class="string">&quot;苹果筛选2：&quot;</span>+ apple))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="comment">//苹果筛选1：Apple&#123;appleId=5, appleName=&#x27;青苹果&#x27;, location=&#x27;广东&#x27;, weight=10&#125;</span></span><br><span class="line">        <span class="comment">//苹果筛选2：Apple&#123;appleId=5, appleName=&#x27;青苹果&#x27;, location=&#x27;广东&#x27;, weight=10&#125;</span></span><br><span class="line">        <span class="comment">//苹果筛选1：Apple&#123;appleId=6, appleName=&#x27;青苹果&#x27;, location=&#x27;海南&#x27;, weight=5&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> count = list.parallelStream().filter(apple -&gt; apple.getLocation().equals(<span class="string">&quot;广东&quot;</span>)).count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">        Stream.iterate(<span class="number">0</span>,x-&gt;x+<span class="number">2</span>).limit(<span class="number">10</span>).collect(Collectors.toList()).forEach(System.out::print);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//024681012141618</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">        String merge = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining());</span><br><span class="line">        System.out.println(merge);</span><br><span class="line">        <span class="comment">//Collectors.joining合并  abcbcefgabcdjkl</span></span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">9</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>);</span><br><span class="line">        IntSummaryStatistics stats = numbers.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line">        System.out.println(<span class="string">&quot;列表中最大的数 : &quot;</span> + stats.getMax());</span><br><span class="line">        System.out.println(<span class="string">&quot;列表中最小的数 : &quot;</span> + stats.getMin());</span><br><span class="line">        System.out.println(<span class="string">&quot;所有数之和 : &quot;</span> + stats.getSum());</span><br><span class="line">        System.out.println(<span class="string">&quot;平均数 : &quot;</span> + stats.getAverage());</span><br><span class="line">        <span class="comment">//统计</span></span><br><span class="line"><span class="comment">//        列表中最大的数 : 10</span></span><br><span class="line"><span class="comment">//        列表中最小的数 : 3</span></span><br><span class="line"><span class="comment">//        所有数之和 : 69</span></span><br><span class="line"><span class="comment">//        平均数 : 6.2727272727272725</span></span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stringStream = strings.stream().flatMap(s -&gt; &#123;</span><br><span class="line"><span class="comment">//            将字符串以,分割后得到一个字符串数组</span></span><br><span class="line">            String[] split = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="comment">//            然后将每个字符串数组对应流返回，flatMap会自动把返回的所有流连接成一个流</span></span><br><span class="line">            Stream&lt;String&gt; stream = Arrays.stream(split).filter(x -&gt; !x.isEmpty());</span><br><span class="line">            <span class="keyword">return</span> stream;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(stringStream.collect(Collectors.toList()));</span><br><span class="line">        <span class="comment">//[abc, bc, efg, abcd, jkl]</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>此集合非彼集合-Arrays.asList()</title>
      <link href="/2021/09/24/%E6%AD%A4%E9%9B%86%E5%90%88%E9%9D%9E%E5%BD%BC%E9%9B%86%E5%90%88-Arrays.asList()/"/>
      <url>/2021/09/24/%E6%AD%A4%E9%9B%86%E5%90%88%E9%9D%9E%E5%BD%BC%E9%9B%86%E5%90%88-Arrays.asList()/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="此集合非彼集合-Arrays-asList"><a href="#此集合非彼集合-Arrays-asList" class="headerlink" title="此集合非彼集合-Arrays.asList()"></a>此集合非彼集合-Arrays.asList()</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天使用Arrays.asList();方法和两个数组arr1.removeAll(arr2);查交集</p><p>但出现<span style='color:red;'>java.lang.UnsupportedOperationException</span></p><p>报错代码（例）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] array = &#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>&#125;;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(array);</span><br><span class="line">        list.add(<span class="string">&quot;6&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="问题所在"><a href="#问题所在" class="headerlink" title="问题所在"></a>问题所在</h2><p>查阅资料，发生问题的原因如下：</p><p> <strong>Arrays的asList方法返回的是Arrays的内部类ArrayList，它并不是java.util.ArrayList</strong>，只不过它们的父类都是AbstractList。</p><p>可以看到Arrays的内部类ArrayList并没有重写add和remove方法，所以当我调用Arrays的内部类ArrayList的add方法时实际上是集成父类AbstractList的add方法。<br>AbstractList的add方法抛出java.lang.UnsupportedOperationException异常</p><p>而<strong>java.util.ArrayList的add方法重写了父类的方法，所以不会报错。</strong></p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>重新建一个数组即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] array = &#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>&#125;;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(array);</span><br><span class="line">        List arrList = <span class="keyword">new</span> ArrayList(list);</span><br><span class="line">        arrList.add(<span class="string">&quot;6&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue跨域代理配置 与 浏览器跨域配置</title>
      <link href="/2021/09/05/vue%E8%B7%A8%E5%9F%9F%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE%E4%B8%8E%20%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%A8%E5%9F%9F%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/09/05/vue%E8%B7%A8%E5%9F%9F%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE%E4%B8%8E%20%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%A8%E5%9F%9F%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="vue跨域代理配置与-浏览器跨域配置"><a href="#vue跨域代理配置与-浏览器跨域配置" class="headerlink" title="vue跨域代理配置与 浏览器跨域配置"></a>vue跨域代理配置与 浏览器跨域配置</h1><h2 id="浏览器报错信息如下"><a href="#浏览器报错信息如下" class="headerlink" title="浏览器报错信息如下"></a>浏览器报错信息如下</h2><p><img src="https://i.loli.net/2021/08/31/mxnHs8G9TrkPdNA.png" alt="跨域报错信息"></p><h2 id="方法一（适用于开发）"><a href="#方法一（适用于开发）" class="headerlink" title="方法一（适用于开发）"></a>方法一（适用于开发）</h2><p>vue.config.js 增加 <strong>disableHostCheck: true</strong></p><blockquote><p>disableHostCheck: true</p></blockquote><p>谷歌为例</p><p>创建快捷方式-&gt;右键属性-&gt;在 <strong>目标</strong>位置后面加上  </p><blockquote><p>–disable-web-security –user-data-dir=D:\MyChromeDevUserData </p></blockquote><p>user-data-dir 中 MyChromeDevUserData 是自己创建的文件夹</p><p><img src="https://i.loli.net/2021/08/31/y8KxTSJn6CeqIOv.png" alt="chrome跨域配置"></p><h2 id="方法2（推荐"><a href="#方法2（推荐" class="headerlink" title="方法2（推荐)"></a>方法2（推荐)</h2><p>在vue.config.js中配置代理</p><p>pathRewrite —- 在项目中找到<code>/api</code>(前)开头的URL，并替换为<code>/api</code>(后）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">port</span>: <span class="number">8200</span>, <span class="comment">// 此处修改你想要的端口号</span></span><br><span class="line">        <span class="attr">proxy</span>: &#123;  <span class="comment">//配置跨域</span></span><br><span class="line">            <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">              <span class="attr">target</span>: <span class="string">&#x27;http://xx.xx.xx.xxx:8100/&#x27;</span>,</span><br><span class="line">              <span class="attr">changOrigin</span>: <span class="literal">true</span>,  <span class="comment">//允许跨域</span></span><br><span class="line">              <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;/api&#x27;</span> </span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在配置统一的url js文件中，把<strong>baseURL改成地址前缀（关键）</strong></p><p>重点：<strong>baseURL: “/“</strong></p><p>若把baseURL写成改成vue的启动地址，则在<strong>window的nginix上没问题</strong>。但部署在Linux服务器上会出现找不到axios请求后台地址失败</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> request = axios.create(&#123;</span><br><span class="line">  <span class="comment">// 根据不同的环境设置baseURL，最终发送请求时的URL为: baseURL + 发送请求时写的URL</span></span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">  <span class="attr">withCredentials</span>: <span class="literal">true</span>, <span class="comment">// 允许携带cookie</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">20000</span> <span class="comment">// 请求超时, 20秒</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经过NGINX反向代理，后端服务器获取不了真实IP</title>
      <link href="/2021/09/01/%E7%BB%8F%E8%BF%87NGINX%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%8C%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8E%B7%E5%8F%96%E4%B8%8D%E4%BA%86%E7%9C%9F%E5%AE%9EIP/"/>
      <url>/2021/09/01/%E7%BB%8F%E8%BF%87NGINX%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%8C%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8E%B7%E5%8F%96%E4%B8%8D%E4%BA%86%E7%9C%9F%E5%AE%9EIP/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="经过NGINX反向代理，后端服务器获取不了真实IP"><a href="#经过NGINX反向代理，后端服务器获取不了真实IP" class="headerlink" title="经过NGINX反向代理，后端服务器获取不了真实IP"></a>经过NGINX反向代理，后端服务器获取不了真实IP</h1><p><strong>原因：</strong>通过了Apache，Squid，nginx等反向代理软件就不能获取到客户端的真实IP地址了。经过代理以后，由于在客户端和服务之间增加了中间层，因此服务器无法直接拿到客户端的IP(拿到的是中间层的ip)，服务器端应用也无法直接通过转发请求的地址返回给客户端。但是在转发请求的HTTP头信息中，增加了x-forwarded-for信息。用以跟踪原有的客户端IP地址和原来客户端请求的服务器地址。</p><p><strong>解决</strong>：在NGINX反向代理服务器上进行修改</p><p>在nginx配置文件中</p><p>每一个location上加上以下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxy_set_header Host $http_host;</span><br><span class="line">proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">proxy_set_header X-Forwarded-Proto $scheme;</span><br></pre></td></tr></table></figure><p>重启nginx即可</p><h2 id="springboot获取ip"><a href="#springboot获取ip" class="headerlink" title="springboot获取ip"></a><strong>springboot获取ip</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取登录用户的IP地址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getIp</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (request == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    String ip = request.getHeader(<span class="string">&quot;X-Requested-For&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (Strings.isEmpty(ip) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">        ip = request.getHeader(<span class="string">&quot;X-Forwarded-For&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Strings.isEmpty(ip) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">        ip = request.getHeader(<span class="string">&quot;Proxy-Client-IP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Strings.isEmpty(ip) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">        ip = request.getHeader(<span class="string">&quot;WL-Proxy-Client-IP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Strings.isEmpty(ip) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">        ip = request.getHeader(<span class="string">&quot;HTTP_CLIENT_IP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Strings.isEmpty(ip) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">        ip = request.getHeader(<span class="string">&quot;HTTP_X_FORWARDED_FOR&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Strings.isEmpty(ip) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">        ip = request.getRemoteAddr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;0:0:0:0:0:0:0:1&quot;</span>.equals(ip))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLocalHost</span><span class="params">(String ip)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;127.0.0.1&quot;</span>.equals(ip) || <span class="string">&quot;localhost&quot;</span>.equals(ip);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析ip地址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ipAddress</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getIpSource</span><span class="params">(String ipAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">&quot;http://opendata.baidu.com/api.php?query=&quot;</span> + ipAddress + <span class="string">&quot;&amp;co=&amp;resource_id=6006&amp;oe=utf8&quot;</span>);</span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(url.openConnection().getInputStream(), <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        StringBuffer result = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            result.append(line);</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close();</span><br><span class="line">        Map map = JSON.parseObject(result.toString(), Map.class);</span><br><span class="line">        List&lt;Map&lt;String, String&gt;&gt; data = (List) map.get(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> data.get(<span class="number">0</span>).get(<span class="string">&quot;location&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 后端 </category>
          
          <category> SpringBoot </category>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker部署springboot项目</title>
      <link href="/2021/08/30/docker%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/"/>
      <url>/2021/08/30/docker%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="docker部署springboot项目"><a href="#docker部署springboot项目" class="headerlink" title="docker部署springboot项目"></a>docker部署springboot项目</h1><ol><li><p>编写dockerfile文件和打包maven项目</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java8</span><br><span class="line"><span class="keyword">MAINTAINER</span> chenqitian</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> overseas-study-0.0.1-SNAPSHOT.jar overseas-app.jar</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [java,-jar]</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8100</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [overseas-app.jar]</span></span><br></pre></td></tr></table></figure><p><strong>FROM-</strong>–指定哪个镜像作为新镜像的基础镜像</p><p><strong>MAINTAINER</strong>—-指明该镜像的作者信息</p><p><strong>ADD</strong>—将主机的文件复制到镜像中</p><p><strong>EXPOSE</strong>—暴露镜像的端口供主机做映射</p><p><strong>CMD</strong>—容器启动时需要执行的命令</p><p><img src="https://i.loli.net/2021/08/30/snmpPWb1fzhrTIg.png"></p></li><li><p>上传服务器</p><p>使用xftp，把dockerfile文件和jar包上传到服务器</p></li><li><p>打包成镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t [镜像名]</span><br></pre></td></tr></table></figure><p>docker images查看所安装的镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure></li><li><p>运行构建的镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8100:8100 [镜像名]</span><br></pre></td></tr></table></figure></li><li><p>完成</p><p>浏览器访问  xx.xx.xx.xx:8100即可</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 后端 </category>
          
          <category> SpringBoot </category>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx+docker部署vue-cil项目</title>
      <link href="/2021/08/27/Nginx+docker%E9%83%A8%E7%BD%B2vue-cil%E9%A1%B9%E7%9B%AE/"/>
      <url>/2021/08/27/Nginx+docker%E9%83%A8%E7%BD%B2vue-cil%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Nginx-docker部署vue-cil项目"><a href="#Nginx-docker部署vue-cil项目" class="headerlink" title="Nginx+docker部署vue-cil项目"></a>Nginx+docker部署vue-cil项目</h1><ol><li><p>编写dockerfile文件</p><p><strong>FROM-</strong>–指定哪个镜像作为新镜像的基础镜像</p><p><strong>MAINTAINER</strong>—-指明该镜像的作者信息</p><p><strong>COPY</strong>—将主机的文件复制到镜像内</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">MAINTAINER</span> chenqitian</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> dist/ /usr/share/nginx/html/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> default.conf /etc/nginx/conf.d/default.conf</span></span><br></pre></td></tr></table></figure></li><li><p>打包vue-cil项目</p><p>cmd中输入以下命令，打包生成dist文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure></li><li><p>修改nginx配置文件<code>default.conf </code></p></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       8200;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   /usr/share/nginx/html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">try_files $uri $uri/ @router;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">location @router &#123;</span><br><span class="line">            rewrite ^.*$ /index.html last;</span><br><span class="line">        &#125;</span><br><span class="line">location ^~ /api &#123;</span><br><span class="line">            proxy_pass   http://47.106.128.108:8100;</span><br><span class="line">            add_header Access-Control-Allow-Methods *;</span><br><span class="line">            add_header Access-Control-Max-Age 3600;</span><br><span class="line">            add_header Access-Control-Allow-Credentials true;</span><br><span class="line">            add_header Access-Control-Allow-Origin $http_origin;</span><br><span class="line">            add_header Access-Control-Allow-Headers $http_access_control_request_headers;</span><br><span class="line">            if ($request_method = OPTIONS ) &#123;</span><br><span class="line">                return 200;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>3.上传到服务器</p><p>​    使用xftp，把dockerfile文件和default.conf上传到服务器</p><p>4.打包成镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t [镜像名]</span><br></pre></td></tr></table></figure><p>5.docker images查看所安装的镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>6.运行构建的镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8200:8200 [镜像名]</span><br></pre></td></tr></table></figure><p>7.完成</p><p>​    浏览器访问  xx.xx.xx.xx:8200即可</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">查看docker进程 -a（全部，包括不正常的）</span><br><span class="line">docker ps -a</span><br><span class="line">删除容器</span><br><span class="line">docker rm [容器id]</span><br><span class="line">删除镜像</span><br><span class="line">docker rmi [镜像id]</span><br><span class="line">查看镜像</span><br><span class="line">docker images</span><br><span class="line">进入容器</span><br><span class="line">docker <span class="built_in">exec</span> -it [容器id] /bin/bash</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
          <category> docker </category>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> nginx </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows配置Nginx部署vue-cil项目</title>
      <link href="/2021/08/25/windows+Nginx%E9%83%A8%E7%BD%B2vue-cil%E9%A1%B9%E7%9B%AE/"/>
      <url>/2021/08/25/windows+Nginx%E9%83%A8%E7%BD%B2vue-cil%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Windows配置Nginx部署vue-cil项目"><a href="#Windows配置Nginx部署vue-cil项目" class="headerlink" title="Windows配置Nginx部署vue-cil项目"></a>Windows配置Nginx部署vue-cil项目</h1><ol><li>nginx下载</li></ol><p><a href="https://nginx.org/en/download.html">nginx下载地址</a></p><ol start="2"><li>打包vue-cil项目</li></ol><p>cmd中输入以下命令，打包生成dist文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><ol start="3"><li>.修改nginx配置文件<code>nginx/conf/nginx.conf </code> </li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       8200;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">try_files $uri $uri/ @router;</span><br><span class="line">        &#125;</span><br><span class="line">location @router &#123;</span><br><span class="line">rewrite ^.*$ /index.html last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ^~ /api &#123;</span><br><span class="line">            proxy_pass   http://xx.xx.xxx.xxx:8100;</span><br><span class="line">            add_header Access-Control-Allow-Methods *;</span><br><span class="line">            add_header Access-Control-Max-Age 3600;</span><br><span class="line">            add_header Access-Control-Allow-Credentials true;</span><br><span class="line">            add_header Access-Control-Allow-Origin $http_origin;</span><br><span class="line">            add_header Access-Control-Allow-Headers $http_access_control_request_headers;</span><br><span class="line">            if ($request_method = OPTIONS ) &#123;</span><br><span class="line">                return 200;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li><p>把打包好的dist放入<code>nginx/html</code>文件夹中</p></li><li><p>CMD启动nginx</p></li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start nginx</span><br></pre></td></tr></table></figure><ol start="6"><li>访问localhost:8200成功</li></ol><h2 id="nginx常用命令"><a href="#nginx常用命令" class="headerlink" title="nginx常用命令"></a>nginx常用命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">查看帮助信息</span><br><span class="line">nginx -h</span><br><span class="line"></span><br><span class="line">查看nginx版本(小写字母v)</span><br><span class="line">nginx -v</span><br><span class="line"></span><br><span class="line">除版本信息外还显示配置参数信息(大写字母V)</span><br><span class="line">nginx -V</span><br><span class="line"></span><br><span class="line">启动nginx</span><br><span class="line">start nginx</span><br><span class="line"></span><br><span class="line">指定配置文件启动nginx</span><br><span class="line">start nginx -c filename</span><br><span class="line"></span><br><span class="line">关闭nginx，完整有序的停止nginx，保存相关信息</span><br><span class="line">nginx -s quit</span><br><span class="line"></span><br><span class="line">关闭nginx，快速停止nginx，可能并不保存相关信息</span><br><span class="line">nginx -s stop</span><br><span class="line"></span><br><span class="line">重新载入nginx，当配置信息修改需要重新加载配置是使用</span><br><span class="line">nginx -s reload</span><br><span class="line"></span><br><span class="line">重新打开日志文件</span><br><span class="line">nginx -s reopen</span><br><span class="line"></span><br><span class="line">测试nginx配置文件是否正确</span><br><span class="line">nginx -t -c filename</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 前端 </category>
          
          <category> windows </category>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> vue </tag>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swagger3整合oauth2 认证token</title>
      <link href="/2021/08/24/swagger3%E6%95%B4%E5%90%88oauth2%20%E8%AE%A4%E8%AF%81token/"/>
      <url>/2021/08/24/swagger3%E6%95%B4%E5%90%88oauth2%20%E8%AE%A4%E8%AF%81token/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="swagger3整合oauth2-认证token"><a href="#swagger3整合oauth2-认证token" class="headerlink" title="swagger3整合oauth2 认证token"></a>swagger3整合oauth2 认证token</h1><h2 id="引入swagger3依赖"><a href="#引入swagger3依赖" class="headerlink" title="引入swagger3依赖"></a>引入swagger3依赖</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--Swagger3 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.0</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="swagger配置文件编写"><a href="#swagger配置文件编写" class="headerlink" title="swagger配置文件编写"></a>swagger配置文件编写</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">createRestApi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.OAS_30)</span><br><span class="line">                .enable(enable)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .groupName(<span class="string">&quot;xx项目接口&quot;</span>)</span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">//配置要扫描接口的方式</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.os&quot;</span>))</span><br><span class="line">                .build()</span><br><span class="line"></span><br><span class="line">                .securitySchemes(securitySchemes())</span><br><span class="line">                .securityContexts(securityContexts());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证的安全上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;SecurityScheme&gt; <span class="title">securitySchemes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;SecurityScheme&gt; securitySchemes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        securitySchemes.add(<span class="keyword">new</span> ApiKey(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;header&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> securitySchemes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权信息全局应用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;SecurityContext&gt; <span class="title">securityContexts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;SecurityContext&gt; securityContexts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        securityContexts.add(SecurityContext.builder()</span><br><span class="line">                .securityReferences(defaultAuth())</span><br><span class="line">                .forPaths(PathSelectors.any()).build());</span><br><span class="line">        <span class="keyword">return</span> securityContexts;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;SecurityReference&gt; <span class="title">defaultAuth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AuthorizationScope authorizationScope = <span class="keyword">new</span> AuthorizationScope(<span class="string">&quot;global&quot;</span>, <span class="string">&quot;accessEverything&quot;</span>);</span><br><span class="line">        AuthorizationScope[] authorizationScopes = <span class="keyword">new</span> AuthorizationScope[<span class="number">1</span>];</span><br><span class="line">        authorizationScopes[<span class="number">0</span>] = authorizationScope;</span><br><span class="line">        List&lt;SecurityReference&gt; securityReferences = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        securityReferences.add(<span class="keyword">new</span> SecurityReference(<span class="string">&quot;Authorization&quot;</span>, authorizationScopes));</span><br><span class="line">        <span class="keyword">return</span> securityReferences;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>请求头：Authorization</p><h2 id="swagger中的效果展示"><a href="#swagger中的效果展示" class="headerlink" title="swagger中的效果展示"></a>swagger中的效果展示</h2><p><img src="https://i.loli.net/2021/08/22/FQEVo2rBAiHRk1J.png" alt="image-20210630123347451"></p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 后端 </category>
          
          <category> SpringBoot </category>
          
          <category> SpringSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> SpringSecurity </tag>
            
            <tag> token </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot启动报错（webSecurity匿名问题）</title>
      <link href="/2021/08/22/springboot%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99%EF%BC%88webSecurity%E5%8C%BF%E5%90%8D%E9%97%AE%E9%A2%98%EF%BC%89/"/>
      <url>/2021/08/22/springboot%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99%EF%BC%88webSecurity%E5%8C%BF%E5%90%8D%E9%97%AE%E9%A2%98%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="springboot启动报错（webSecurity匿名问题）"><a href="#springboot启动报错（webSecurity匿名问题）" class="headerlink" title="springboot启动报错（webSecurity匿名问题）"></a>springboot启动报错（webSecurity匿名问题）</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘springSecurityFilterChain’ defined in <span class="class"><span class="keyword">class</span> <span class="title">path</span> <span class="title">resource</span> [<span class="title">org</span>/<span class="title">springframework</span>/<span class="title">security</span>/<span class="title">config</span>/<span class="title">annotation</span>/<span class="title">web</span>/<span class="title">configuration</span>/<span class="title">WebSecurityConfiguration</span>.<span class="title">class</span>]: <span class="title">Bean</span> <span class="title">instantiation</span> <span class="title">via</span> <span class="title">factory</span> <span class="title">method</span> <span class="title">failed</span></span>; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [javax.servlet.Filter]: Factory method ‘springSecurityFilterChain’ threw exception; nested exception is java.lang.IllegalStateException: An incomplete mapping was found <span class="keyword">for</span> []. <span class="function">Try completing it with something like <span class="title">requestUrls</span><span class="params">()</span>..<span class="title">hasRole</span><span class="params">(‘USER’)</span></span></span><br></pre></td></tr></table></figure><h2 id="在WebSecurityConfig-SecurityConfig-中配置"><a href="#在WebSecurityConfig-SecurityConfig-中配置" class="headerlink" title="在WebSecurityConfig(SecurityConfig)中配置"></a>在WebSecurityConfig(SecurityConfig)中配置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">                <span class="comment">//放行swagger</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/swagger-ui.html&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/swagger-ui/*&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/swagger-resources/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/v2/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/v3/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/img.icons/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/webjars/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/doc.html&quot;</span>).permitAll()</span><br><span class="line">    <span class="comment">//只有匿名用户才能访问，其他都要登录</span></span><br><span class="line">                <span class="comment">// 所有加 AnonymousAccess 注解的请求都允许匿名访问</span></span><br><span class="line">                .antMatchers(getAnonymousUrls()).anonymous();</span><br><span class="line">                <span class="comment">//所有请求必须被认证（登录）</span></span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">                </span><br></pre></td></tr></table></figure><p><strong>方法一</strong>: antMatchers(getAnonymousUrls()).anonymous(); 和anyRequest().authenticated(); 同时有</p><p><strong>方法二</strong>: antMatchers(getAnonymousUrls()).anonymous(); 和至少用一个方法上有@AnonymousAccess注解</p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 后端 </category>
          
          <category> SpringBoot </category>
          
          <category> SpringSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> SpringSecurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot SpringSecurity 整合knife4j, Swagger3问题</title>
      <link href="/2021/08/20/Springboot%20SpringSecurity%20%E6%95%B4%E5%90%88knife4j,%20Swagger3%E9%97%AE%E9%A2%98/"/>
      <url>/2021/08/20/Springboot%20SpringSecurity%20%E6%95%B4%E5%90%88knife4j,%20Swagger3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Springboot-SpringSecurity-整合knife4j-Swagger3问题"><a href="#Springboot-SpringSecurity-整合knife4j-Swagger3问题" class="headerlink" title="Springboot SpringSecurity 整合knife4j, Swagger3问题"></a>Springboot SpringSecurity 整合knife4j, Swagger3问题</h1><p>版本说明： swagger3版本3.0.0，knife4j版本3.0.2</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--swagger3--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>SpringSecurity放行静态资源</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">                <span class="comment">//放行swagger</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/swagger-ui.html&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/swagger-ui/*&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/swagger-resources/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/v2/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/v3/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/img.icons/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/webjars/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/doc.html&quot;</span>).permitAll()</span><br></pre></td></tr></table></figure><p>Swagger3Config 继承 WebMvcConfigurationSupport 过滤</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.</span><br><span class="line">                addResourceHandler(<span class="string">&quot;/swagger-ui/**&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/webjars/springfox-swagger-ui/&quot;</span>)</span><br><span class="line">                .resourceChain(<span class="keyword">false</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;doc.html&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/webjars/**&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>开启注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableOpenApi</span> <span class="comment">//swagger3</span></span><br><span class="line"><span class="meta">@EnableKnife4j</span> <span class="comment">//knife4j 3.0.2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Swagger3Config</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 后端 </category>
          
          <category> SpringBoot </category>
          
          <category> SpringSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> SpringSecurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构建React-app应用时create-react-app卡住超慢的解决办法</title>
      <link href="/2021/08/16/%E6%9E%84%E5%BB%BAReact-app%E5%BA%94%E7%94%A8%E6%97%B6create-react-app%E5%8D%A1%E4%BD%8F%E8%B6%85%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2021/08/16/%E6%9E%84%E5%BB%BAReact-app%E5%BA%94%E7%94%A8%E6%97%B6create-react-app%E5%8D%A1%E4%BD%8F%E8%B6%85%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="构建React-app应用时create-react-app卡住超慢的解决办法"><a href="#构建React-app应用时create-react-app卡住超慢的解决办法" class="headerlink" title="构建React-app应用时create-react-app卡住超慢的解决办法"></a>构建React-app应用时create-react-app卡住超慢的解决办法</h1><h2 id="解决办法：npm换源（淘宝镜像）"><a href="#解决办法：npm换源（淘宝镜像）" class="headerlink" title="解决办法：npm换源（淘宝镜像）"></a>解决办法：npm换源（淘宝镜像）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line">-- 配置后可通过下面方式来验证是否成功</span><br><span class="line">npm config get registry</span><br><span class="line">-- 显示出上述地址的话就是更换成功</span><br></pre></td></tr></table></figure><h2 id="再次尝试构建"><a href="#再次尝试构建" class="headerlink" title="再次尝试构建"></a>再次尝试构建</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">creat-react-app first-react-app（app名称）</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 前端 </category>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>佛山探店 | 有趣好玩switch小店</title>
      <link href="/2021/08/10/%E4%BD%9B%E5%B1%B1%E6%8E%A2%E5%BA%97-BlackPearl/"/>
      <url>/2021/08/10/%E4%BD%9B%E5%B1%B1%E6%8E%A2%E5%BA%97-BlackPearl/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="有趣好玩switch小店🎮"><a href="#有趣好玩switch小店🎮" class="headerlink" title="有趣好玩switch小店🎮"></a>有趣好玩switch小店🎮</h1><p>🏠地点：建新路103号三座首层B号二楼（祖庙铂顿城隔壁-三合凉拌楼上）</p><ul><li>⭐环境很好，干净整洁</li><li>👾游戏也有十几个</li><li>✨店内装饰很游戏风</li><li>✨有很多的小摆设</li><li>💵￥50/2小时</li></ul><p><img src="https://i.loli.net/2021/08/14/86QUfN5An2tSxwj.jpg"></p><p><img src="https://i.loli.net/2021/08/14/A7I4m6gRByUMZaG.jpg"></p><p><img src="https://i.loli.net/2021/08/14/EcAPWbCZvQ4gdxo.jpg"></p><p><img src="https://i.loli.net/2021/08/14/1KaAX6pG9nJjrPo.jpg" alt="game1.jpg"></p><p><img src="https://i.loli.net/2021/08/14/tlr2WHIMS5q8kjc.jpg" alt="game2.jpg"></p><p><img src="https://i.loli.net/2021/08/14/sHJPUw2hIXBlOKz.jpg" alt="game3.jpg"></p><p><img src="https://i.loli.net/2021/08/14/bxBKPv69nJyTErs.jpg"></p><p>一次值得的体验，游戏爱好者推荐来玩哈👍</p>]]></content>
      
      
      <categories>
          
          <category> 探店 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 探店 </tag>
            
            <tag> 日常生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git踩坑</title>
      <link href="/2021/08/06/git%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/08/06/git%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="git踩坑"><a href="#git踩坑" class="headerlink" title="git踩坑"></a>git踩坑</h1><h4 id="git仓库大文件push失败报413-Request-Entity-Too-Large-问题解决办法"><a href="#git仓库大文件push失败报413-Request-Entity-Too-Large-问题解决办法" class="headerlink" title="git仓库大文件push失败报413 Request Entity Too Large 问题解决办法"></a>git仓库大文件push失败报413 Request Entity Too Large 问题解决办法</h4><p>使用https方式拉取的git仓库，在push文件时报错Gitlab error push files 413 Request Entity Too Large</p><p>尝试了如下</p><ol><li>增大https方式的post缓存   (不成功)</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config http.postBuffer 524288000</span><br></pre></td></tr></table></figure><p>  2.修改本地仓库的https方式为ssh （成功）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote set-url origin ssh地址</span><br></pre></td></tr></table></figure><hr><h4 id="git-pull遇到错误：error-Your-local-changes-to-the-following-files-would-be-overwritten-by-merge"><a href="#git-pull遇到错误：error-Your-local-changes-to-the-following-files-would-be-overwritten-by-merge" class="headerlink" title="git pull遇到错误：error: Your local changes to the following files would be overwritten by merge"></a>git pull遇到错误：error: Your local changes to the following files would be overwritten by merge</h4><p><strong>原因：本地项目有修改，不能更新</strong></p><p><strong>方法1</strong>: 如果你想保留刚才本地修改的代码，并把git服务器上的代码pull到本地（本地刚才修改的代码将会被暂时封存起来）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash </span><br><span class="line"></span><br><span class="line">git pull origin master </span><br><span class="line"></span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>服务器上的代码更新到了本地，而且你本地修改的代码也没有被覆盖，之后使用add，commit，push 命令即可更新本地代码到服务器了。</p><p><strong>方法2</strong>: 如果你想完全地覆盖本地的代码，只保留服务器端代码，则直接回退到上一个版本，再进行pull</p><ol><li><p><strong>git reset –soft [提交id]</strong></p><p>只移动 HEAD 到指定的 commit，但保留原先暂存区和工作目录的内容，同时会将指定 commit 之后提交的内容设置到暂存区中</p></li><li><p><strong>git reset –mixed [提交id]</strong> </p><p>移动 HEAD 到指定的 commit，同时重置暂存区为指定 commit 的状态(将内容从 HEAD 复制到暂存区中)，但保留原先的工作目录，同时将添加暂存区的修改撤销到工作目录中。该选项为默认选项，可以省略</p></li><li><p><strong>git reset –hard [提交id]</strong> </p><p>移动 HEAD，同时重置暂存区和工作目录到指定 commit。也即是将三个树都重置为指定的 commit。</p></li></ol><p>Git会有三个区域：</p><ul><li><p><strong>Working Tree</strong> 当前的工作区域</p></li><li><p><strong>Index/Stage</strong> 暂存区域，和git stash命令暂存的地方不一样。使用git add xx，就可以将xx添加近Stage里面</p></li><li><p><strong>Repository</strong> 提交的历史，即使用git commit提交后的结果</p><p> <img src="https://s2.loli.net/2022/04/11/FrS2HqAnXGBu9PK.png" alt="image-20220411075350414"></p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard [提交id]</span><br><span class="line"></span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><p><strong>方法3</strong>:合并代码</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;xxx&quot;</span></span><br><span class="line">git pull</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><hr><h4 id="命令Hexo-d上传GitHub超时报错"><a href="#命令Hexo-d上传GitHub超时报错" class="headerlink" title="命令Hexo d上传GitHub超时报错"></a>命令Hexo d上传GitHub超时报错</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">atal: unable to access <span class="string">&#x27;https://github.com/.......&#x27;</span>: OpenSSL SSL_read: Connection was reset, errno 10054</span><br></pre></td></tr></table></figure><p>产生原因：一般是这是因为服务器的SSL证书没有经过第三方机构的签署，所以报错</p><p>参考网上解决办法：解除ssl验证后  (无效果)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global http.sslVerify &quot;false&quot;</span><br></pre></td></tr></table></figure><p>或出现错误</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fatal: unable to access <span class="string">&#x27;https://github.com/.../.git&#x27;</span>: Could not resolve host: github.com</span><br></pre></td></tr></table></figure><p>参考网上解决办法：解除代理  (无效果)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy </span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure><p>或出现错误</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fatal: unable to access <span class="string">&#x27;https://github.com/Chankeitin/Chankeitin.github.io.git/&#x27;</span>: Failed to connect to github.com port 443: Timed out</span><br></pre></td></tr></table></figure><p>或出现错误</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fatal: unable to access <span class="string">&#x27;https://github.com/Chankeitin/Chankeitin.github.io.git/&#x27;</span>: Empty reply from server</span><br><span class="line">FATAL &#123;</span><br><span class="line">  ......</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Something<span class="string">&#x27;s wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html</span></span><br></pre></td></tr></table></figure><p>最后统一解决：</p><p><strong>重复运行命令，直到push成功</strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Aplayer报错解决方案</title>
      <link href="/2021/08/05/Aplay%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/"/>
      <url>/2021/08/05/Aplay%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>hexo - g 报错如下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">INFO  Start processing</span><br><span class="line">Error: [hexo-tag-aplayer] Meting support is disabled, cannot resolve the meting tags properly.</span><br><span class="line">    at throwError (E:\Node_JS_Hexo\node_modules\hexo-tag-aplayer\common\util.js:18:9)</span><br><span class="line">    at Object.&lt;anonymous&gt; (E:\Node_JS_Hexo\node_modules\hexo-tag-aplayer\index.js:160:28)</span><br><span class="line">    at NunjucksTag._run (E:\Node_JS_Hexo\node_modules\hexo\lib\extend\tag.js:120:18)</span><br><span class="line">    at NunjucksTag.run (E:\Node_JS_Hexo\node_modules\hexo\lib\extend\tag.js:116:15)</span><br><span class="line">    at Template.root [as rootRenderFunc] (eval at _compile (E:\Node_JS_Hexo\node_modules\nunjucks\src\environment.js:617:18), &lt;anonymous&gt;:29:66)</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>请在 Hexo 配置文件 _config.yml 中设置即可： （<strong>切记是hexo的配置文件，不是themes文件夹里面的）</strong></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">aplayer:</span>  </span><br><span class="line"><span class="attr">meting:</span> <span class="literal">true</span> </span><br></pre></td></tr></table></figure><p>请不要配置：（这个是给Meting.js用的，Aplayer误设置会导致变成空白的） </p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Aplayer:</span></span><br><span class="line"><span class="attr">asset_inject:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速搭建Hexo博客</title>
      <link href="/2021/08/04/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2/"/>
      <url>/2021/08/04/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="快速搭建Hexo博客"><a href="#快速搭建Hexo博客" class="headerlink" title="快速搭建Hexo博客"></a>快速搭建Hexo博客</h1><h2 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h2 id="Hexo搭建"><a href="#Hexo搭建" class="headerlink" title="Hexo搭建"></a>Hexo搭建</h2><h3 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h3><p>需要先安装下列应用程序</p><ul><li><p><a href="http://nodejs.org/">Node.js</a></p></li><li><p><a href="http://git-scm.com/">Git</a></p></li><li><p>notepad++(作为编辑器 <strong>可选</strong>)</p></li></ul><h3 id="安装hexo脚手架"><a href="#安装hexo脚手架" class="headerlink" title="安装hexo脚手架"></a>安装hexo脚手架</h3><p>打开cmd，输入下面命令全局安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>用<code>hexo -v</code>查看一下版本，验证是否安装成功</p><p>创建一个文件夹blog，然后<code>cd</code>到这个文件夹下</p><p>输入命令初始化hexo项目</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init</span><br><span class="line">或 hexo init blog(博客名)</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹目录下有：</p><ul><li><p>node_modules: 依赖包</p></li><li><p>public：存放生成的静态页面</p></li><li><p>scaffolds：生成文章的一些模板</p></li><li><p>source：用来存放你的文章</p></li><li><p>themes：主题</p></li><li><p>_config.yml: 博客的配置文件</p></li></ul><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><h3 id="测试运行"><a href="#测试运行" class="headerlink" title="测试运行"></a>测试运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>打开hexo的服务，在浏览器输入localhost:4000就可以看到你默认生成的博客了。</p><p>使用ctrl+c可以把服务关掉。</p><h3 id="GitHub-Gitee创建个人仓库"><a href="#GitHub-Gitee创建个人仓库" class="headerlink" title="GitHub/Gitee创建个人仓库"></a>GitHub/Gitee创建个人仓库</h3><p>首先，你先要有一个GitHub/Gitee账户，去注册一个吧。</p><p>注册完登录后，新建仓库</p><p>创建一个和你用户名相同的仓库，后面加.github.io/gitee.io，只有这样，将来要部署到GitHub page/Gitee page的时候，才会被识别，也就是xxxx.github.io/xxxx.gitee.io，其中xxx就是你注册的用户名。</p><h3 id="将hexo部署到GitHub"><a href="#将hexo部署到GitHub" class="headerlink" title="将hexo部署到GitHub"></a>将hexo部署到GitHub</h3><p>这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 <code>_config.yml</code>，翻到最后，修改为</p><p>username为GitHub用户名</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/username/username.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>安装deploy-git ，也就是部署的命令。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>输入命令进行部署</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>过一会儿就可以在<code>http://username.github.io</code> 这个网站看到你的博客了！！</p><hr><h2 id="主题模板"><a href="#主题模板" class="headerlink" title="主题模板"></a>主题模板</h2><h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><p>在<a href="https://hexo.io/themes/%E5%AE%98%E7%BD%91%E4%B8%AD%E9%A2%84%E8%A7%88%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%BB%E9%A2%98%EF%BC%8C%E5%9C%A8GitHub%E4%B8%AD%E6%90%9C%E7%B4%A2%E4%B8%BB%E9%A2%98%E5%90%8D%EF%BC%8C%E5%B9%B6clone%E5%88%B0%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95%E7%9A%84themes%E6%96%87%E4%BB%B6%E5%A4%B9%E5%86%85%EF%BC%88%E5%8F%82%E8%80%83%E8%B7%AF%E5%BE%84%EF%BC%9Ablog/themes/%EF%BC%89">https://hexo.io/themes/官网中预览喜欢的主题，在GitHub中搜索主题名，并clone到博客目录的themes文件夹内（参考路径：blog/themes/）</a></p><p>以Butterfly主题为例</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/jerryc127/hexo-theme-butterfly</span><br></pre></td></tr></table></figure><p>并在<code>_config.yml</code>中配置该主题,<code>ctrl+f</code>搜索关键字<code>theme</code>,把值修改成butterfly（themes中克隆模板的文件夹名）</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure><p>如果没有 pug 以及 stylus 的渲染器，需要安装</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-renderer-pug</span> <span class="string">hexo-renderer-stylus</span> <span class="string">--save</span></span><br></pre></td></tr></table></figure><p>重新编译启动</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>访问localhost:4000，成功即可</p><hr><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">hexo</span> <span class="string">clean</span> <span class="string">清除了之前生成的东西</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">g</span> <span class="string">编译代码</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">d</span> <span class="string">部署文章</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">n</span> <span class="string">page</span> <span class="string">xx</span> <span class="string">新建页面</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">new</span> <span class="string">xx</span> <span class="string">新建博客文章</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客建设及踩坑</title>
      <link href="/2021/08/04/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE%E5%8F%8A%E8%B8%A9%E5%9D%91/"/>
      <url>/2021/08/04/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE%E5%8F%8A%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="Hexo建设"><a href="#Hexo建设" class="headerlink" title="Hexo建设"></a>Hexo建设</h3><h4 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h4><h5 id="设置导航栏（主题里的-config-yml）"><a href="#设置导航栏（主题里的-config-yml）" class="headerlink" title="设置导航栏（主题里的_config.yml）"></a>设置导航栏（主题里的<code>_config.yml</code>）</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">   <span class="string">首页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">   <span class="string">归档:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">   <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">   <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">   <span class="string">娱乐||fas</span> <span class="attr">fa-list:</span></span><br><span class="line">     <span class="string">音乐:</span> <span class="string">/music/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-music</span></span><br><span class="line">     <span class="string">电影:</span> <span class="string">/movies/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-video</span></span><br><span class="line">   <span class="string">友链:</span> <span class="string">/link/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line">   <span class="string">关于:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-heart</span></span><br></pre></td></tr></table></figure><h5 id="配置网站样式"><a href="#配置网站样式" class="headerlink" title="配置网站样式"></a>配置网站样式</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Image (圖片設置)</span><br><span class="line"># --------------------------------------</span><br><span class="line"></span><br><span class="line"># Favicon（網站圖標）</span><br><span class="line">favicon: /img/favicon.png</span><br><span class="line"></span><br><span class="line"># Avatar (頭像)</span><br><span class="line">avatar:</span><br><span class="line">  img: /img/avatar.png</span><br><span class="line">  effect: false</span><br><span class="line"></span><br><span class="line"># the banner image of home page</span><br><span class="line">……</span><br></pre></td></tr></table></figure><h5 id="设置主页名句"><a href="#设置主页名句" class="headerlink" title="设置主页名句"></a>设置主页名句</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subtitle:</span><br><span class="line">  enable: true</span><br><span class="line">  # Typewriter Effect (打字效果)</span><br><span class="line">  effect: true</span><br><span class="line">  # loop (循環打字)</span><br><span class="line">  loop: true</span><br><span class="line">  # source調用第三方服務</span><br><span class="line">  # source: false 關閉調用</span><br><span class="line">  # source: 1  調用搏天api的隨機語錄（簡體） https://api.btstu.cn/</span><br><span class="line">  # source: 2  調用一言網的一句話（簡體） https://hitokoto.cn/</span><br><span class="line">  # source: 3  調用一句網（簡體） http://yijuzhan.com/</span><br><span class="line">  # source: 4  調用今日詩詞（簡體） https://www.jinrishici.com/</span><br><span class="line">  # subtitle 會先顯示 source , 再顯示 sub 的內容</span><br><span class="line">  source: true</span><br><span class="line">  # 如果有英文逗號&#x27; , &#x27;,請使用轉義字元 &amp;#44;</span><br><span class="line">  # 如果有英文雙引號&#x27; &quot; &#x27;,請使用轉義字元 &amp;quot;</span><br><span class="line">  # 開頭不允許轉義字元，如需要，請把整個句子用雙引號包住</span><br><span class="line">  # 如果關閉打字效果，subtitle只會顯示sub的第一行文字</span><br><span class="line">  sub: </span><br><span class="line">    - 有德必有勇，正直的人绝不胆怯。</span><br><span class="line">    - 即使慢，驰而不息，纵会落后，纵会失败，但一定可以达到他所向的目标。</span><br></pre></td></tr></table></figure><h5 id="配置社交图标"><a href="#配置社交图标" class="headerlink" title="配置社交图标"></a>配置社交图标</h5><p>在阿里巴巴矢量图标库里面，把需要的图标添加购物车，在新建项目，在购物车中将图标添加到项目中,在主题配置文件中修改：</p><p>把样式添加到页头</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Inject</span><br><span class="line"># Insert the code to head (before &#x27;&lt;/head&gt;&#x27; tag) and the bottom (before &#x27;&lt;/body&gt;&#x27; tag)</span><br><span class="line"># 插入代码到头部 &lt;/head&gt; 之前 和 底部 &lt;/body&gt; 之前</span><br><span class="line">inject:</span><br><span class="line">  head:</span><br><span class="line">   - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/iconfont.css&quot;&gt; #引入阿里巴巴矢量图库</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">social:</span><br><span class="line">  fab fa-github: https://github.com/xxxxx || Github</span><br><span class="line">  iconfont gitee: https://gitee.com/××× ||Gitee</span><br></pre></td></tr></table></figure><h4 id="文章格式"><a href="#文章格式" class="headerlink" title="文章格式"></a>文章格式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:【必需】页面标题</span><br><span class="line">date:【必需】页面创建日期</span><br><span class="line">type: 【必需】标籤、分类和友情链接三个页面需要配置</span><br><span class="line">updated:【可选】页面更新日期</span><br><span class="line">description:【可选】页面描述</span><br><span class="line">keywords: 【可选】页面关键字</span><br><span class="line">comments: 【可选】显示页面评论模块 (默认 true)</span><br><span class="line">top_img: 【可选】页面顶部图片</span><br><span class="line">mathjax: 【可选】显示 mathjax (当设置 mathjax 的 per_page: false 时，才需要配置，默认 false)</span><br><span class="line">katex: 【可选】显示 katex (当设置 katex 的 per_page: false 时，才需要配置，默认 false)</span><br><span class="line">aside: 【可选】显示侧边栏 (默认 true)</span><br><span class="line">aplayer: 【可选】在需要的页面加载 aplayer 的 js 和 css, 请参考文章下面的音乐 配置</span><br><span class="line">highlight_shrink: 【可选】配置代码框是否展开 (true/false)(默认为设置中 highlight_shrink 的配置)</span><br><span class="line">cover:封面图片的url</span><br><span class="line"></span><br><span class="line">copyright: true</span><br><span class="line">copyright_author: xxxx</span><br><span class="line">copyright_author_href: https://github.com/Chankeitin</span><br><span class="line">copyright_url: https://chankeitin.github.io/</span><br><span class="line">copyright_info: 此文章版权归Chankeitin所有，如有转载，请註明来自原作者</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>copyright -&gt; 复制内容携带作者信息</p><p>cover后面输入你想要的封面图片的url</p><p>top_img后面加上你想要的顶部图片的url</p><h4 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h4><p>友情链接的添加需要在完成该操作的基础上，新建<code>source/_data/link.yml</code>文件，添加如下内容</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">class_name:</span> <span class="string">友情链接</span></span><br><span class="line">  <span class="attr">class_desc:</span> <span class="string">那些人，那些事，那些开发者工具</span></span><br><span class="line">  <span class="attr">link_list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Chankeitin</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://chankeitin.github.io</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">https://i.loli.net/2021/08/05/cZd4CF96pgqrQBH.jpg</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">想成为全栈程序猿</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MyBatis-Plus</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://baomidou.com/</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">https://baomidou.com/img/logo.svg</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">为简化开发而生</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Spring</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://spring.io/</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">http://c.biancheng.net/uploads/allimg/210701/1-210F1141343544.png</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">Spring</span> <span class="string">makes</span> <span class="string">Java</span> <span class="string">simple.</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Hexo</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://hexo.io/zh-tw/</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">快速、简单且强大的博客框架</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
