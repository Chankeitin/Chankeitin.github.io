<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网络协议(二)</title>
      <link href="/2021/10/21/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE(%E4%BA%8C)/"/>
      <url>/2021/10/21/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="网络协议-二"><a href="#网络协议-二" class="headerlink" title="网络协议(二)"></a>网络协议(二)</h1><h2 id="DNS-查询服务器的基本流程是什么？DNS-劫持是什么？"><a href="#DNS-查询服务器的基本流程是什么？DNS-劫持是什么？" class="headerlink" title="DNS 查询服务器的基本流程是什么？DNS 劫持是什么？"></a>DNS 查询服务器的基本流程是什么？DNS 劫持是什么？</h2><p>DNS（Domain Names System），域名系统，是互联网一项服务，是进行域名和与之相对应的 IP 地址进行转换的服务器</p><p><img src="https://i.loli.net/2021/10/18/rfNsjWglJD7uFyI.png" alt="image-20211018173310316"></p><p>DNS 查询的方式有两种：</p><ul><li>递归查询：如果 A 请求 B，那么 B 作为请求的接收者一定要给 A 想要的答案</li></ul><p><img src="https://i.loli.net/2021/10/18/CiKrWdfMXzqeNBk.png" alt="image-20211018173402644"></p><ul><li>迭代查询：如果接收者 B 没有请求者 A 所需要的准确内容，接收者 B 将告诉请求者 A，如何去获得这个内容，但是自己并不去发出请求</li></ul><p><img src="https://i.loli.net/2021/10/18/uB7Jc1H9Qy6rVE4.png" alt="image-20211018173424792"></p><h3 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h3><p>解析域名的过程如下：</p><ul><li><p>首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表</p></li><li><p>若没有命中，则继续搜索操作系统的 DNS 缓存</p></li><li><p>若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果</p></li><li><p>若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询</p></li><li><p>首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器</p><ul><li>本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址</li><li>本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址</li><li>本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来</li></ul></li><li><p>操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起</p></li><li><p>至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起</p></li></ul><h3 id="什么是DNS劫持"><a href="#什么是DNS劫持" class="headerlink" title="什么是DNS劫持?"></a>什么是DNS劫持?</h3><p>DNS劫持又称域名劫持，是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能反应或访问的是假网址。</p><h3 id="预防DNS劫持"><a href="#预防DNS劫持" class="headerlink" title="预防DNS劫持?"></a>预防DNS劫持?</h3><p>修改默认的路由器登陆账号与密码</p><h2 id="Cookie-和-Session-的关系和区别是什么？"><a href="#Cookie-和-Session-的关系和区别是什么？" class="headerlink" title="Cookie 和 Session 的关系和区别是什么？"></a>Cookie 和 Session 的关系和区别是什么？</h2><p>(1)cookie数据存放在客户的浏览器上，session数据放在服务器上<br>(2)cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,如果主要考虑到安全应当使用session<br>(3)session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用COOKIE<br>(4)单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能3K。<br>(5)所以：将登陆信息等重要信息存放为SESSION;其他信息如果需要保留，可以放在COOKIE中</p><h2 id="简述-HTTPS-的加密与认证过程"><a href="#简述-HTTPS-的加密与认证过程" class="headerlink" title="简述 HTTPS 的加密与认证过程"></a>简述 HTTPS 的加密与认证过程</h2><h3 id="https加密过程"><a href="#https加密过程" class="headerlink" title="https加密过程"></a>https加密过程</h3><p><img src="https://i.loli.net/2021/10/18/4nuAhs5byHQapPL.png" alt="image-20211018185523161"></p><h3 id="服务端证书通过CA机构签名认证的过程如下"><a href="#服务端证书通过CA机构签名认证的过程如下" class="headerlink" title="服务端证书通过CA机构签名认证的过程如下"></a>服务端证书通过CA机构签名认证的过程如下</h3><p><img src="https://i.loli.net/2021/10/18/gozbp1Knc7fUra5.png" alt="image-20211018185655146"></p><h2 id="RestFul-是什么？RestFul-请求的-URL-有什么特点？"><a href="#RestFul-是什么？RestFul-请求的-URL-有什么特点？" class="headerlink" title="RestFul 是什么？RestFul 请求的 URL 有什么特点？"></a>RestFul 是什么？RestFul 请求的 URL 有什么特点？</h2><p>REST（Resource Representational State Transfer【表现层状态转化】）。如果一个架构符合REST原则，就称为RESTful架构，是一种<strong>面向资源的软件架构风格</strong></p><p>REST最大的几个特点为：资源、统一接口、URI和无状态。</p><p>资源：网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。资源总要通过某种载体反应其内容，文本可以用txt格式表现，也可以用HTML格式、XML格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现；JSON是现在最常用的资源表示格式。</p><blockquote><p>网络上的实体！</p></blockquote><p>统一接口：数据的元操作，即CRUD(create, read, update和delete,即数据的增删查改)操作，分别对应于HTTP方法：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源，这样就统一了数据操作的接口，仅通过HTTP方法，就可以完成对数据的所有增删查改工作。</p><blockquote><p>通过HTTP方法来确定并完成对实体的操作！</p></blockquote><p>URI：可以用一个URI（Universal Resource Identifier，统一资源定位符）指向资源，即每个URI都对应一个特定的资源。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或识别符。一般的，每个资源至少有一个URI与之对应，最典型的URI即URL。</p><blockquote><p>通过URI来识别不同的资源（实体）！</p></blockquote><p>无状态：所有的资源，都可以通过URI定位，而且这个定位与其他资源无关，也不会因为其他资源的变化而改变。<br>WebSocket是有状态的</p><blockquote><p>通过URI对资源（实体）操作时，无状态，没有上下文的影响！</p></blockquote><p>Resultful特点：<br>1.使用URL描述资源<br>2.使用HTTP方法描述行为。使用HTTP状态码来表示不同的结果<br>3.使用json交互数据，传统模式使用的是键值对形式<br>4.RESTful只是一种风格，并不是强制的标准。</p><h2 id="RestFul-与-RPC-的区别是什么？RestFul-的优点在哪里？"><a href="#RestFul-与-RPC-的区别是什么？RestFul-的优点在哪里？" class="headerlink" title="RestFul 与 RPC 的区别是什么？RestFul 的优点在哪里？"></a>RestFul 与 RPC 的区别是什么？RestFul 的优点在哪里？</h2><h3 id="RESTFUL-与RPC的区别"><a href="#RESTFUL-与RPC的区别" class="headerlink" title="RESTFUL 与RPC的区别"></a>RESTFUL 与RPC的区别</h3><p>1.restfull和rpc都是client/server模式的，都是在 Server端 把一个个函数封装成接口暴露出去</p><p>2.restful使用http协议实现，而rpc则不一定使用http，一般比较常用的是tcp， RPC 可以获得更好的性能（省去了 HTTP 报头等一系列东西）,TCP更加高效，而HTTP在实际应用中更加的灵活。</p><p>3.从使用上来说：Http接口只关注服务提供方（服务端），对于客户端怎么调用，调用方式怎样并不关心；而RPC服务则需要客户端接口与服务端保持一致，服务端提供一个方法，客户端通过接口直接发起调用。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><h4 id="RPC的优势："><a href="#RPC的优势：" class="headerlink" title="RPC的优势："></a>RPC的优势：</h4><ol><li>是查找的精确性，快速性，短路径，和确定性，因为属于内网查询，独立的注册中心，所以查找的速度更快。</li><li>而且由于做了精简和优化，删去了RESTful方式里面很多多余的信息，比如Header，而且做了压缩和序列化，通过二进制方式传输，传输的内容更少，传输的速度也更快。</li><li>环节和流程更少，因为RESTful需要经过路由，负载均衡，网关，防火墙和一系列的身份识别和校验，就像大楼内来了个不认识的人，楼管大叔肯定要查你的身份证等等信息核实你的信息。 而且RPC就省去了这些环节，就像你天天出来进去，楼管大妈早就对你很熟了，不需要每次核实你的信息，RPC省去了很多环节。</li></ol><h4 id="RESTful的优势："><a href="#RESTful的优势：" class="headerlink" title="RESTful的优势："></a>RESTful的优势：</h4><ol><li>通用性更好，RESTful可以供任何接入互联网的终端调用，各种平台，各种终端都可以用RESTful传输和交换数据，而且有一套标准和规范的传输格式，所以格式更加标准化和通用化。</li><li>安全性更高，因为属于连接外围和内网的通道，所以会经过一些列的安全和身份校验。</li><li>移植性更好，从一个服务器迁移到另一个服务器，从一个节点迁移到另一个节点，从一个架构移植到另一种架构，都可以轻松完成。</li></ol><ul><li><p>RPC的应用场景：当你的框架和语言种类也比较多，内部之间调用量非常大的时候，RPC是最佳的选择。RPC更多是内网之间的数据传输，一般是部署在服务层的分布式系统里面，或者微服务系统。有服务治理，服务限流、服务降级、服务熔断、服务监控等等，类似于大楼里面配了治安处，物业处、后勤处、监控中心等。</p></li><li><p>RESTful的应用场景：数据更多是公网上的传输，比如服务端API供 IOS、Android、PC等客户端调用， API供第三方合作方调用等 。</p></li></ul><h2 id="TCP-挥手时出现大量-CLOSE-WAIT-或-TIME-WAIT-怎么解决？"><a href="#TCP-挥手时出现大量-CLOSE-WAIT-或-TIME-WAIT-怎么解决？" class="headerlink" title="TCP 挥手时出现大量 CLOSE_WAIT 或 TIME_WAIT 怎么解决？"></a>TCP 挥手时出现大量 CLOSE_WAIT 或 TIME_WAIT 怎么解决？</h2><h3 id="TIME-WAIT状态"><a href="#TIME-WAIT状态" class="headerlink" title="TIME_WAIT状态"></a>TIME_WAIT状态</h3><p>主动断开方处于TIME_WAIT状态时，源端口无法使用<br> 端口最大数是65535，因此如果频繁主动断开TCP连接，将很快耗尽端口号。一旦达到了上限，则新的请求就无法被处理，接着就是大量Too Many Open Files异常，然后tomcat、nginx、apache崩溃<br>如何解决TIME_WAIT问题</p><h4 id="解决TIME-WAIT大量出现"><a href="#解决TIME-WAIT大量出现" class="headerlink" title="解决TIME_WAIT大量出现"></a>解决TIME_WAIT大量出现</h4><p>最核心的思想，就是打开系统的TIME_WAIT<strong>重用和快速回收</strong></p><p>net.ipv4.tcp_tw_recycle = 1表示开启TCP连接中TIME_WAIT sockets的快速回收，默认为0,表示关闭<br>net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME_WAIT sockets重新用于新的TCP连接，默认为0，表示关闭</p><h3 id="CLOSE-WAIT状态"><a href="#CLOSE-WAIT状态" class="headerlink" title="CLOSE_WAIT状态"></a>CLOSE_WAIT状态</h3><p>如果出现了CLOSE_WAIT<strong>过多</strong>的状态</p><p>1.在对方关闭连接后，自身程序里没有检测 -（被动方的角度）</p><p>2.本身忘了需要关闭连接，于是整个资源就一直被程序占用着。-（主动方的角度）</p><h4 id="如何解决CLOSE-WAIT问题"><a href="#如何解决CLOSE-WAIT问题" class="headerlink" title="如何解决CLOSE_WAIT问题"></a>如何解决CLOSE_WAIT问题</h4><p>关闭正在运行的程序<br>尽快修改程序bug,然后测试提交到线上服务器</p><h2 id="什么是跨域，什么情况下会发生跨域请求？"><a href="#什么是跨域，什么情况下会发生跨域请求？" class="headerlink" title="什么是跨域，什么情况下会发生跨域请求？"></a>什么是跨域，什么情况下会发生跨域请求？</h2><p>跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器施加的安全限制。</p><p>同源策略：所谓同源是指：协议，域名，端口均相同。即便两个不同的域名指向同一个ip地址，也非同源。</p><blockquote><p><a href="http://www.123.com/index.html%E8%B0%83%E7%94%A8">http://www.123.com/index.html调用</a> <a href="http://www.123.com/server.php">http://www.123.com/server.php</a> （非跨域）<br><a href="http://www.123.com/index.html">http://www.123.com/index.html</a> 调用 <a href="http://www.456.com/server.php">http://www.456.com/server.php</a> （主域名不同:123/456，跨域）<br><a href="http://abc.123.com/index.html">http://abc.123.com/index.html</a> 调用 <a href="http://def.123.com/server.php">http://def.123.com/server.php</a> （子域名不同:abc/def，跨域）<br><a href="http://www.123.com:8080/index.html">http://www.123.com:8080/index.html</a> 调用 <a href="http://www.123.com:8081/server.php">http://www.123.com:8081/server.php</a> （端口不同:8080/8081，跨域）<br><a href="http://www.123.com/index.html">http://www.123.com/index.html</a> 调用 <a href="https://www.123.com/server.php">https://www.123.com/server.php</a> （协议不同:http/https，跨域）<br>请注意：localhost和127.0.0.1虽然都指向本机，但也属于跨域。</p></blockquote><h2 id="简述对称与非对称加密的概念"><a href="#简述对称与非对称加密的概念" class="headerlink" title="简述对称与非对称加密的概念"></a>简述对称与非对称加密的概念</h2><p><strong>对称加密</strong>是最快速、最简单的一种加密方式，加密（encryption）与解密（decryption）用的是同样的密钥（secret key)</p><blockquote><p>常见的对称加密有DES、三 重DES、AES等</p></blockquote><p>非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥（public key）和私钥（private key)</p><ul><li>只能私钥加密公钥解密,或者公钥加密私钥解密;</li><li>一方保留密钥,一方公开密钥;不能同时公开,具体公开哪方需要根据实际情况来决定</li></ul><blockquote><p>非对称加密算法常见有:RSA算法(3个人名简写)和diffie - hellman算法(迪菲·赫尔曼算法)</p></blockquote><h2 id="HTTP-中-GET-和-POST-区别"><a href="#HTTP-中-GET-和-POST-区别" class="headerlink" title="HTTP 中 GET 和 POST 区别"></a>HTTP 中 GET 和 POST 区别</h2><p>1、GET 方法：从指定的资源请求数据。</p><p>请注意，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：</p><p>例如：<a href="https://www.xxxx.com/xxx.asp">https://www.xxxx.com/xxx.asp</a>? name1=value1&amp;name2=value2  </p><p>而需要注意的是：GET方法是可见的，而POST方法是在HTTP消息主体中发出的，具有不可见性。下面是一些GET的注释：</p><ul><li><p>请求可被缓存。</p></li><li><p>请求保留在浏览器历史记录中。</p></li><li><p>请求可被收藏为书签。</p></li><li><p>请求不应在处理敏感数据时使用</p></li><li><p>请求有长度限制</p></li><li><p>请求只应当用于取回数据</p></li><li><p>GET—&gt;application/x-www-form-urlencoded 。</p></li><li><p>GET—-&gt;只允许 ASCII 字符。</p></li></ul><p>2、POST 方法：向指定的资源提交要被处理的数据</p><p>  请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：</p><p>GET方法是可见的，而POST方法是在HTTP消息主体中发出的，具有不可见性。下面是一些 POST的注释：</p><ul><li><p>请求不会被缓存</p></li><li><p>请求不会保留在浏览器历史记录中</p></li><li><p>不能被收藏为书签</p></li><li><p>请求对数据长度没有要求</p></li><li><p>POST—&gt;application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 </p></li><li><p>POST—&gt; 没有限制。也允许二进制数据。</p></li></ul><h2 id="TCP-的-keepalive-了解吗？说一说它和-HTTP-的-keepalive-的区别？"><a href="#TCP-的-keepalive-了解吗？说一说它和-HTTP-的-keepalive-的区别？" class="headerlink" title="TCP 的 keepalive 了解吗？说一说它和 HTTP 的 keepalive 的区别？"></a>TCP 的 keepalive 了解吗？说一说它和 HTTP 的 keepalive 的区别？</h2><h3 id="TCP-Keepalive"><a href="#TCP-Keepalive" class="headerlink" title="TCP Keepalive"></a>TCP Keepalive</h3><p>链接建立之后，如果应用程序或者上层协议一直不发送数据，或者隔很长时间才发送一次数据，当链接很久没有数据报文传输时如何去确定对方还在线，到底是掉线了还是确实没有数据传输，链接还需不需要保持，这种情况在TCP协议设计中是需要考虑到的。</p><p>TCP协议通过一种巧妙的方式去解决这个问题，当超过一段时间之后，TCP自动发送一个数据为空的报文给对方，如果对方回应了这个报文，说明对方还在线，链接可以继续保持，如果对方没有报文返回，并且重试了多次之后则认为链接丢失，没有必要保持链接。</p><h3 id="TCP-Keepalive-HTTP-Keep-Alive-的关系"><a href="#TCP-Keepalive-HTTP-Keep-Alive-的关系" class="headerlink" title="TCP Keepalive HTTP Keep-Alive 的关系"></a>TCP Keepalive HTTP Keep-Alive 的关系</h3><p><strong>HTTP协议的Keep-Alive意图在于TCP连接复用，同一个连接上串行方式传递请求-响应数据；TCP的Keepalive机制意图在于探测连接的对端是否存活。</strong></p><p><img src="https://i.loli.net/2021/10/21/c8iT39hYKEu5JI4.png" alt="image-20211021104327114"></p><h2 id="简述常见的-HTTP-状态码的含义（301，304，401，403）"><a href="#简述常见的-HTTP-状态码的含义（301，304，401，403）" class="headerlink" title="简述常见的 HTTP 状态码的含义（301，304，401，403）"></a>简述常见的 HTTP 状态码的含义（301，304，401，403）</h2><p>200 OK ：服务器成功返回用户请求的数据。</p><p>201 CREATED ：用户新建或修改数据成功。</p><p>202 Accepted： 请求已被接受，但尚未处理。</p><p>301 Moved Permanently： 永久重定向。</p><p>304 Not Modified： 请求资源与本地缓存相同，未修改。</p><p>307/302 Temporary Redirect：临时重定向。不会从POST变成GET。</p><p>400 INVALID REQUEST ：用户发出的请求有错误。</p><p>401 Unauthorized ：用户没有权限。</p><p>403 Forbidden ：访问被禁止。</p><p>404 NOT FOUND ：请求针对的是不存在的记录。</p><p>406 Not Acceptable ：用户请求的的格式不正确。</p><p>500 INTERNAL SERVER ERROR ：服务器发生错误。</p><p>503 Service Unavailable：服务器暂时处于超负荷或正在进行停机维护，现在无法处理请求。</p><h2 id="简述-TCP-的-TIME-WAIT-和-CLOSE-WAIT"><a href="#简述-TCP-的-TIME-WAIT-和-CLOSE-WAIT" class="headerlink" title="简述 TCP 的 TIME_WAIT 和 CLOSE_WAIT"></a>简述 TCP 的 TIME_WAIT 和 CLOSE_WAIT</h2><p><strong>TIME_WAIT-主动关闭</strong></p><ul><li>TIME_WAIT 是主动关闭链接时形成的，等待2MSL时间，约4分钟。主要是防止最后一个ACK丢失。  由于TIME_WAIT 的时间会非常长，因此server端应尽量减少主动关闭连接</li></ul><p><strong>CLOSE_WAIT-被动关闭</strong></p><ul><li>CLOSE_WAIT是被动关闭连接是形成的。根据TCP状态机，服务器端收到客户端发送的FIN，则按照TCP实现发送ACK，因此进入CLOSE_WAIT状态。但如果服务器端不执行close()，就不能由CLOSE_WAIT迁移到LAST_ACK，则系统中会存在很多CLOSE_WAIT状态的连接。此时，可能是系统忙于处理读、写操作，而未将已收到FIN的连接，进行close。此时，recv/read已收到FIN的连接socket，会返回0。</li></ul><h2 id="简述-TCP-滑动窗口以及重传机制"><a href="#简述-TCP-滑动窗口以及重传机制" class="headerlink" title="简述 TCP 滑动窗口以及重传机制"></a>简述 TCP 滑动窗口以及重传机制</h2><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p><p>通常窗口的大小是由接收方的决定的。</p><p>发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。不是完全相等，接收窗口的大小是<strong>约等于</strong>发送窗口的大小的</p><h3 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h3><p><img src="https://i.loli.net/2021/10/21/L9vi6aKeN1mHX8k.png" alt="image-20211021164258042"></p><p>当某一段报文丢失了，图中（1001 - 2000）数据段丢失了，接受方没有接收到该数据段，则会一直的给发送方发送ACK（下一个是1001），如果发送端主机连续收到同样一个（下一个1001），就会将对应的数据（1001 - 2000）重新发送。<br>这时候如果接收端收到1001之后，再次返回的就是ACK（8001）了。之前的（2001 - 8000）都接收到了接受缓存区。<br>这种机制被称为“高速重发机制”（快速重传）</p><h2 id="简述-DDOS-攻击原理，如何防范它？"><a href="#简述-DDOS-攻击原理，如何防范它？" class="headerlink" title="简述 DDOS 攻击原理，如何防范它？"></a>简述 DDOS 攻击原理，如何防范它？</h2><p>整个过程可分为：</p><ol><li>扫描大量主机以寻找可入侵主机目标；</li><li>有安全漏洞的主机并获取控制权；</li><li>入侵主机中安装攻击程序；</li><li>用己入侵主机继续进行扫描和入侵。</li></ol><h4 id="DDoS攻击防御方法"><a href="#DDoS攻击防御方法" class="headerlink" title="DDoS攻击防御方法"></a><strong>DDoS攻击防御方法</strong></h4><p><strong>1. 过滤不必要的服务和端口：</strong>可以使用Inexpress、Express、Forwarding等工具来过滤不必要的服务和端口，即在路由器上过滤假IP。比如Cisco公司的CEF(Cisco Express Forwarding)可以针对封包Source IP和Routing Table做比较，并加以过滤。只开放服务端口成为目前很多服务器的流行做法，例如WWW服务器那么只开放80而将其他所有端口关闭或在防火墙上做阻止策略。</p><p><strong>2. 异常流量的清洗过滤：</strong>通过DDOS硬件防火墙对异常流量的清洗过滤，通过数据包的规则过滤、数据流指纹检测过滤、及数据包内容定制过滤等顶尖技术能准确判断外来访问流量是否正常，进一步将异常流量禁止过滤。单台负载每秒可防御800-927万个syn攻击包。</p><p><strong>3. 分布式集群防御：</strong>这是目前网络安全界防御大规模DDOS攻击的最有效办法。分布式集群防御的特点是在每个节点服务器配置多个IP地址（负载均衡），并且每个节点能承受不低于10G的DDOS攻击，如一个节点受攻击无法提供服务，系统将会根据优先级设置自动切换另一个节点，并将攻击者的数据包全部返回发送点，使攻击源成为瘫痪状态，从更为深度的安全防护角度去影响企业的安全执行决策。</p><p><strong>4. 高防智能DNS解析：</strong>高智能DNS解析系统与DDOS防御系统的完美结合，为企业提供对抗新兴安全威胁的超级检测功能。它颠覆了传统一个域名对应一个镜像的做法，智能根据用户的上网路线将DNS解析请求解析到用户所属网络的服务器。同时智能DNS解析系统还有宕机检测功能，随时可将瘫痪的服务器IP智能更换成正常服务器IP，为企业的网络保持一个永不宕机的服务状态。</p><p><strong>5.带宽资源要充足：</strong>带宽直接决定了抗DDOS攻击的能力，至少要选择100M带宽的，越多越好。</p><p><strong>6.服务器的硬件配置：</strong>在带宽以及流量有充分保障的前提下，服务器的硬件配置必须得跟上。当然，主要的因素还是CPU和内存</p><p><strong>7.搭建CDN：</strong>将内容缓存在终端用户附近</p><h2 id="简述-OSI-七层模型，TCP，IP-属于哪一层？"><a href="#简述-OSI-七层模型，TCP，IP-属于哪一层？" class="headerlink" title="简述 OSI 七层模型，TCP，IP 属于哪一层？"></a>简述 OSI 七层模型，TCP，IP 属于哪一层？</h2><p><strong>TCP，IP 属于传输层</strong></p><table><thead><tr><th>OSI七层模型</th><th>TCP/IP模型</th><th>功能</th><th>TCP/IP协议族</th></tr></thead><tbody><tr><td>应用层</td><td>应用层</td><td>直接向用户提供服务，完成用户希望完成的各种网络操作</td><td>HTTP，FTP，TFTP，DNS，Telnet，SMTP</td></tr><tr><td>表示层</td><td>进行数据编解码，数据加解密和格式转换</td><td>没有协议</td><td></td></tr><tr><td>会话层</td><td>解除或建立与别的节点的联系，组织和协调两个会话进程之间的通信，并对数据交换进行管理</td><td>没有协议</td><td></td></tr><tr><td>传输层</td><td>传输层</td><td>向两台主机中进程之间的通信提供通用的数据传输服务，实现端到端连接</td><td>TCP，UDP</td></tr><tr><td>网络层</td><td>网络层</td><td>为分组交换网上的不同主机提供通信服务，也就是进行IP选址和路由选择</td><td>IP，ICMP，RIP，IGMP</td></tr><tr><td>数据链路层</td><td>数据链路层</td><td>在物理层提供的比特流基础上，通过差错控制、流量控制的方法，将由差错的物理线路变为无差错的、能可靠传输数据帧的数据链路</td><td>SLIP，CSLIP，PPP，ARP，RARP，</td></tr><tr><td>物理层</td><td>物理层</td><td>利用传输介质为数据链路层提供物理连接，实现相邻计算机节点之间比特流的透明传输</td><td>IEEE802.1 A，IEEE802.2到IEEE802.11</td></tr></tbody></table><p>题目答案均为转载，题目先后顺序按各大厂总出题次数排列！</p>]]></content>
      
      
      <categories>
          
          <category> 面试技巧 </category>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议(一)</title>
      <link href="/2021/10/18/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE(%E4%B8%80)/"/>
      <url>/2021/10/18/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="网络协议-一"><a href="#网络协议-一" class="headerlink" title="网络协议(一)"></a>网络协议(一)</h1><h2 id="简述-TCP-三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？"><a href="#简述-TCP-三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？" class="headerlink" title="简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？"></a>简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？</h2><p><img src="https://i.loli.net/2021/10/18/GDsdkzVbKlrFgpZ.png" alt="image-20211018110043768"></p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ul><li><p>第一次握手</p><p>客户端给服务器发送一个SYN段(在 TCP 标头中 SYN 位字段为 1 的 TCP/IP 数据包), 该段中也包含客户端的初始序列号(Sequence number (Seq)= J)。</p><blockquote><p>SYN是同步的缩写，SYN 段是发送到另一台计算机的 TCP 数据包，请求在它们之间建立连接</p></blockquote><p>SYN = j , Seq = k</p></li><li><p>第二次握手<br>服务器返回客户端 SYN +ACK 段(在 TCP 标头中SYN和ACK位字段都为 1 的 TCP/IP 数据包)， 该段中包含服务器的初始序列号(Sequence number(Seq) = K)；同时使 Acknowledgment number = J + 1来表示确认已收到客户端的 SYN段(Sequence number = J)。</p><blockquote><p>ACK 是“确认”的缩写。 ACK 数据包是任何确认收到一条消息或一系列数据包的 TCP 数据包</p></blockquote><p>SYN  = j, Seq =y, ACK= k+1</p></li><li><p>第三次握手<br>客户端给服务器响应一个ACK段(在 TCP 标头中 ACK 位字段为 1 的 TCP/IP 数据包), 该段中使 Acknowledgment number = K + 1来表示确认已收到服务器的 SYN段(Sequence number(Seq) = K)。</p><p>ACK= y+1</p></li></ul><h3 id="为什么三次？"><a href="#为什么三次？" class="headerlink" title="为什么三次？"></a>为什么三次？</h3><ol><li><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p></li><li><p>换个易于理解的视角来看为什么要 3 次握手。</p><p>客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。</p></li></ol><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="https://i.loli.net/2021/10/18/R5pbFzeuPY3NWhZ.png" alt="image-20211018111059274"></p><ul><li>客户端发送一个 FIN 段，并包含一个希望接收者看到的自己当前的序列号 K. 同时还包含一个 ACK 表示确认对方最近一次发过来的数据。</li><li>服务端将 K 值加 1 作为 ACK 序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。</li><li>服务端发起自己的 FIN 段，ACK=K+1, Seq=L。</li><li>客户端确认。进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。ACK=L+1。</li></ul><h3 id="为什么关闭连接却是四次挥手"><a href="#为什么关闭连接却是四次挥手" class="headerlink" title="为什么关闭连接却是四次挥手?"></a>为什么关闭连接却是四次挥手?</h3><ol><li><p>TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令<strong>告知对方，我要关闭连接</strong>了。</p></li><li><p><strong>这时对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，也就是说，服务端收到客户端的 FIN 标志，知道客户端想要断开这次连接了，但是，我服务端，我还想发数据呢？我等到发送完了所有的数据后，会发送一个 FIN 段来关闭此方向上的连接。接收方发送 ACK确认关闭连接。</strong></p><p>注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解“上层的意志”。</p></li><li><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是<strong>为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</strong></p></li><li><p>因为服务端在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。而<strong>关闭连接时，当收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据</strong>，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方 ACK 和 FIN 一般都会分开发。</p></li></ol><h2 id="HTTP-与-HTTPS-有哪些区别？"><a href="#HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="HTTP 与 HTTPS 有哪些区别？"></a>HTTP 与 HTTPS 有哪些区别？</h2><p>1、HTTPS  协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(以前的网易官网是http，而网易邮箱是 https 。)</p><p>2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。</p><p>3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>4、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)</p><p>注意：</p><p>(1) 采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问。这套证书其实就是一对公钥和私钥。</p><p>(2) 互联网有太多的服务需要使用证书来验证身份，以至于客户端（操作系统或浏览器等）无法内置所有证书，需要通过服务端将证书发送给客户端。</p><p>(3) 客户端内置的是 CA 的根证书(Root Certificate)，HTTPS 协议中服务器会发送证书链（Certificate Chain）给客户端。</p><p><strong>数据传输的机密性</strong>:包含自己支持的非对成加密的密钥交换算法 ( 一般是<a href="https://baike.baidu.com/item/RSA/210678">RSA</a>)，数据签名摘要算法 ( 一般是<a href="https://baike.baidu.com/item/SHA/9533316">SHA</a>或者<a href="https://baike.baidu.com/item/MD5/212708">MD5</a>) ，加密传输数据的对称加密算法 ( 一般是<a href="https://baike.baidu.com/item/DES/210508">DES</a>)，以及加密密钥的长度。<br>非对称加密公钥和私钥的使用方法：(1) 公钥加密私钥解密。(2) 私钥做数字签名，公钥验证。</p><h2 id="从输入-URL-到展现页面的全过程"><a href="#从输入-URL-到展现页面的全过程" class="headerlink" title="从输入 URL 到展现页面的全过程"></a>从输入 URL 到展现页面的全过程</h2><ol><li><p>输入url地址</p></li><li><p>应用层进行DNS解析</p></li><li><p>应用层生成HTTP请求报文</p></li><li><p>传输层建立TCP连接</p></li><li><p>网络层使用IP协议来选择路线</p></li><li><p>数据链路层实现网络相邻节点间可靠的数据通信</p></li><li><p>物理层传输数据</p></li><li><p>服务器处理反向传输</p></li><li><p>服务器返回一个 HTTP 响应</p></li><li><p>浏览器渲染</p></li></ol><h2 id="TCP-与-UDP-在网络协议中的哪一层，他们之间有什么区别？"><a href="#TCP-与-UDP-在网络协议中的哪一层，他们之间有什么区别？" class="headerlink" title="TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？"></a>TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？</h2><p>TCP与UDP都在<span style='color:red'>传输层</span></p><p><strong>用户数据报协议 UDP（User Datagram Protocol）</strong></p><p>是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</p><p><strong>传输控制协议 TCP（Transmission Control Protocol）</strong></p><p>是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</p><h2 id="TCP-怎么保证可靠传输？"><a href="#TCP-怎么保证可靠传输？" class="headerlink" title="TCP 怎么保证可靠传输？"></a>TCP 怎么保证可靠传输？</h2><p>TCP主要提供了检验和、序列号/确认应答、超时重传、最大消息长度、滑动窗口控制等方法实现了可靠性传输。</p><ul><li><strong>校验和：</strong></li></ul><p>发送的数据包的二进制相加然后取反，<strong>目的是检测数据在传输过程中的任何变化</strong>。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。 </p><ul><li><strong>确认应答+序列号（累计确认+seq）：</strong></li></ul><p>接收方收到报文就会确认（累积确认：对所有按序接收的数据的确认）</p><p>TCP给发送的<strong>每一个包进行编号</strong>，接收方<strong>对数据包进行排序</strong>，把有序数据传送给应用层。 </p><ul><li><strong>超时重传：</strong></li></ul><p>当TCP<strong>发出一个段后，它启动一个定时器</strong>，<strong>等待目的端确认收到这个报文段</strong>。<strong>如果不能及时收到一个确认，将重发这个报文段</strong>。 </p><ul><li><strong>流量控制：</strong></li></ul><p><strong>TCP连接的每一方都有固定大小的缓冲空间</strong>，TCP的<strong>接收端只允许发送端发送接收端缓冲区能接纳的数据</strong>。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。</p><p><strong>接收方有即时窗口（滑动窗口），随ACK报文发送</strong></p><ul><li><strong>拥塞控制：</strong></li></ul><p>当网络拥塞时，减少数据的发送。</p><p><strong>发送方有拥塞窗口，发送数据前比对接收方发过来的即使窗口，取小</strong></p><h2 id="简述-HTTP-1-0，1-1，2-0-的主要区别"><a href="#简述-HTTP-1-0，1-1，2-0-的主要区别" class="headerlink" title="简述 HTTP 1.0，1.1，2.0 的主要区别"></a>简述 HTTP 1.0，1.1，2.0 的主要区别</h2><p>HTTP1.0与HTTP 1.1的主要区别</p><ol><li>长连接</li><li>节约带宽</li><li>HOST域</li></ol><ul><li><p><strong>缓存处理：</strong>在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</p></li><li><p><strong>带宽优化及网络连接的使用：</strong>HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p></li><li><p><strong>错误通知的管理：</strong>在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p></li><li><p><strong>Host头处理：</strong>在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p></li><li><p><strong>长连接：</strong>HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p><h2 id="HTTP-1-x与HTTP-2区别"><a href="#HTTP-1-x与HTTP-2区别" class="headerlink" title="HTTP / 1.x与HTTP / 2区别"></a>HTTP / 1.x与HTTP / 2区别</h2></li></ul><p>HTTP1.1与HTTP 2.0的主要区别</p><ol><li>多路复用</li><li>二进制分帧</li><li>首部压缩</li><li>服务器推送</li></ol><ul><li><p><strong>服务端推送：</strong>它引入了服务器推送的概念，其中服务器预计客户端将需要的资源，并在客户端发出请求之前将其推送。客户端保留拒绝服务器推送的权限；但是，在大多数情况下，此功能可大大提高流程效率。</p></li><li><p><strong>多路复用</strong>：该概念交错了请求和响应，而没有行头阻塞，并且通过单个TCP连接来完成。</p></li><li><p><strong>新的二进制格式：</strong>它是一种二进制协议，即仅以0和1形式的二进制命令通过网络传输。二进制成帧层将消息划分为多个帧，这些帧根据其类型（数据或报头）进行分离。此功能在安全性，压缩和多路复用方面大大提高了效率。</p></li><li><p><strong>header压缩：</strong>HTTP / 2使用HPACK标头压缩算法，该算法可抵御像CRIME这样的攻击，并利用静态霍夫曼编码。</p></li></ul><h2 id="TCP-中常见的拥塞控制算法有哪些？"><a href="#TCP-中常见的拥塞控制算法有哪些？" class="headerlink" title="TCP 中常见的拥塞控制算法有哪些？"></a>TCP 中常见的拥塞控制算法有哪些？</h2><p>拥塞控制主要是四个算法：1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复。</p><p><img src="https://i.loli.net/2021/10/18/aY8qfFDEJAoVSMm.png" alt="image-20211018121313295"></p><h3 id="1-慢启动算法-Slow-Start"><a href="#1-慢启动算法-Slow-Start" class="headerlink" title="1.慢启动算法 - Slow Start"></a>1.慢启动算法 - Slow Start</h3><p>在 TCP 连接刚建立时，一点一点提速，先试探网络的状况，避免扰乱了网络通道的秩序。<br>慢启动是指一开始向网络注入的报文段少，并不是指拥塞窗口 cwnd 增长速度慢。</p><ul><li><strong>慢启动算法：</strong></li></ul><ol><li><p>连接建好的开始先初始化拥塞窗口的 cwnd 大小为 1，表明可以传送一个 MSS 大小的数据。</p></li><li><p>每当收到一个 ACK，cwnd 大小加 1，呈线性上升。</p></li><li><p>每当过了一个往返延迟时间 RTT(Round-Trip TIme),cwnd 大小直接翻倍，乘以 2，呈指数上升。</p></li><li><p>还有一个 ssthresh(slow start threshold)，是一个上限(阈值)，当 cwnd &gt;= ssthresh 时就会进入“拥塞避免算法”。</p><p><img src="https://i.loli.net/2021/10/18/pVGdt38BfCUkh57.png" alt="image-20211018121346465"></p></li></ol><h3 id="2-拥塞避免算法-Congestion-Avoidance"><a href="#2-拥塞避免算法-Congestion-Avoidance" class="headerlink" title="2. 拥塞避免算法- Congestion Avoidance"></a>2. 拥塞避免算法- Congestion Avoidance</h3><p>当窗口大小 cwnd &gt;= 慢启动的阈值后，就会进入拥塞避免算法。<br>拥塞避免 不能完全避免拥塞，而是指在拥塞避免阶段将拥塞窗口控制为线性增长，避免窗口增长过快导致窗口拥塞。缓慢的增加调整到最佳状态，使网络比较不容易出现拥塞。</p><ul><li><strong>拥塞避免算法：</strong></li></ul><ol><li>收到一个 ACK，则 cwnd = cwnd + 1/cwnd</li><li>每当经过了一个往返延迟时间 RTT，cwnd 大小加 1。</li></ol><h3 id="3-拥塞状态时的算法"><a href="#3-拥塞状态时的算法" class="headerlink" title="3.拥塞状态时的算法"></a>3.拥塞状态时的算法</h3><p>TCP 拥塞控制默认认为网络丢包是由于网络拥塞导致的，所以一般的 TCP 拥塞控制算法以丢包为网络进入拥塞状态的信号。对于丢包有两种判断方式，<strong>一种是超时重传 RTO(Retransmission Timeout)超时，另一个是收到三个重复确认 ACK</strong>。</p><ul><li><strong>超时重传 RTO(Retransmission Timeout)超时，TCP 会重传数据包。TCP 认为这种情况比较糟糕，反应也比较激烈：</strong></li></ul><ol><li>由于发生丢包，将慢启动阈值(ssthresh)设置为当前 cwnd 的一半，即 ssthresh = cwnd / 2</li><li>cwnd 重置为 1</li><li>进入慢启动过程</li></ol><p>早期的 TCP Tahoe 算法就是使用上述处理方法，由于一丢包就一切重来，导致 cwnd 又重置为 1，十分不利于网络数据的稳定传递。<br>所以，TCP Reno 算法进行了优化。当收到三个重复确认 ACK 时，TCP 开启快速重传 Fast Retransmit 算法，而不用等到 RTO 超时再进行重传</p><ul><li><strong>三个重复确认 ACK：</strong></li></ul><ol><li>cwnd 大小缩减为当前的一半。</li><li>ssthresh 设置为缩小后的 cwnd 大小</li><li>进入快速恢复算法 Fast Recovery。</li></ol><p><img src="https://i.loli.net/2021/10/18/3IQ96BPRySJpXzv.png" alt="image-20211018121405441"></p><h3 id="4-快速恢复算法-Fast-Recovery"><a href="#4-快速恢复算法-Fast-Recovery" class="headerlink" title="4.快速恢复算法 - Fast Recovery"></a>4.快速恢复算法 - Fast Recovery</h3><p>TCP Tahoe 是早期的算法，所以没有快速恢复算法，而 Reno 算法有。在进入快速恢复之前，cwnd 和 ssthresh 已经被改为原有的 cwnd 的一半。</p><ol><li>cwnd = cwnd + 3 MSS，加 3 MSS 的原因是收到 3 个重复的 ACK。</li><li>重传 DACKs 指定数据包。</li><li>如果再收到 DACKs，那么 cwnd 大小增加 1。</li><li>如果收到新的 ACK，表明重传的包成功了，退出快速恢复算法。将 cwnd 设置为 ssthresh，然后进入拥塞避免算法。</li></ol><h2 id="什么是-TCP-粘包和拆包？"><a href="#什么是-TCP-粘包和拆包？" class="headerlink" title="什么是 TCP 粘包和拆包？"></a>什么是 TCP 粘包和拆包？</h2><p>假设 Client 向 Server 连续发送了两个数据包，用 packet1 和 packet2 来表示，那么服务端收到的数据可以分为三种情况，现列举如下：</p><p>第一种情况，接收端正常收到两个数据包，即没有发生拆包和粘包的现象。</p><p><img src="https://i.loli.net/2021/10/18/zoRirExaU2FysJM.png" alt="image-20211018112224687"></p><p>第二种情况，接收端只收到一个数据包，但是这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。</p><p><img src="https://i.loli.net/2021/10/18/H6k3laKcndSpg58.png" alt="image-20211018112231807"></p><p>第三种情况，这种情况有两种表现形式，如下图。接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。</p><p><img src="https://i.loli.net/2021/10/18/aXHKL9B3hVo5vts.png" alt="image-20211018112240880"></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h2 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h2><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><h2 id="计网七层模型"><a href="#计网七层模型" class="headerlink" title="计网七层模型"></a>计网七层模型</h2><table><thead><tr><th>OSI七层模型</th><th>TCP/IP模型</th><th>功能</th><th>TCP/IP协议族</th></tr></thead><tbody><tr><td>应用层</td><td>应用层</td><td>直接向用户提供服务，完成用户希望完成的各种网络操作</td><td>HTTP，FTP，TFTP，DNS，Telnet，SMTP</td></tr><tr><td>表示层</td><td>进行数据编解码，数据加解密和格式转换</td><td>没有协议</td><td></td></tr><tr><td>会话层</td><td>解除或建立与别的节点的联系，组织和协调两个会话进程之间的通信，并对数据交换进行管理</td><td>没有协议</td><td></td></tr><tr><td>传输层</td><td>传输层</td><td>向两台主机中进程之间的通信提供通用的数据传输服务，实现端到端连接</td><td>TCP，UDP</td></tr><tr><td>网络层</td><td>网络层</td><td>为分组交换网上的不同主机提供通信服务，也就是进行IP选址和路由选择</td><td>IP，ICMP，RIP，IGMP</td></tr><tr><td>数据链路层</td><td>数据链路层</td><td>在物理层提供的比特流基础上，通过差错控制、流量控制的方法，将由差错的物理线路变为无差错的、能可靠传输数据帧的数据链路</td><td>SLIP，CSLIP，PPP，ARP，RARP，</td></tr><tr><td>物理层</td><td>物理层</td><td>利用传输介质为数据链路层提供物理连接，实现相邻计算机节点之间比特流的透明传输</td><td>IEEE802.1 A，IEEE802.2到IEEE802.11</td></tr></tbody></table><h2 id="UDP-、TCP-首部格式"><a href="#UDP-、TCP-首部格式" class="headerlink" title="UDP 、TCP 首部格式"></a>UDP 、TCP 首部格式</h2><h3 id="TCP协议首部格式"><a href="#TCP协议首部格式" class="headerlink" title="TCP协议首部格式"></a>TCP协议首部格式</h3><p><img src="https://i.loli.net/2021/10/18/2oIwAzLHYu4x7XQ.png" alt="image-20211018103946071"></p><p>TCP 首部格式比 UDP 复杂。</p><p><strong>序号：</strong>用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p><p><strong>确认号：</strong>期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p><p><strong>数据偏移：</strong>指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p><p><strong>控制位：</strong>八位从左到右分别是 CWR，ECE，URG，ACK，PSH，RST，SYN，FIN。</p><p><strong>CWR：</strong>CWR 标志与后面的 ECE 标志都用于 IP 首部的 ECN 字段，ECE 标志为 1 时，则通知对方已将拥塞窗口缩小；</p><p><strong>ECE：</strong>若其值为 1 则会通知对方，从对方到这边的网络有阻塞。在收到数据包的 IP 首部中 ECN 为 1 时将 TCP 首部中的 ECE 设为 1；</p><p><strong>URG：</strong>该位设为 1，表示包中有需要紧急处理的数据，对于需要紧急处理的数据，与后面的紧急指针有关；</p><p><strong>ACK：</strong>该位设为 1，确认应答的字段有效，TCP规定除了最初建立连接时的 SYN 包之外该位必须设为 1；</p><p><strong>PSH：</strong>该位设为 1，表示需要将收到的数据立刻传给上层应用协议，若设为 0，则先将数据进行缓存；</p><p><strong>RST：</strong>该位设为 1，表示 TCP 连接出现异常必须强制断开连接；</p><p><strong>SYN：</strong>用于建立连接，该位设为 1，表示希望建立连接，并在其序列号的字段进行序列号初值设定；</p><p><strong>FIN：</strong>该位设为 1，表示今后不再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位置为 1 的 TCP 段。</p><p>每个主机又对对方的 FIN 包进行确认应答之后可以断开连接。不过，主机收到 FIN 设置为 1 的 TCP 段之后不必马上回复一个 FIN 包，而是可以等到缓冲区中的所有数据都因为已成功发送而被自动删除之后再发 FIN 包；</p><p><strong>窗口：</strong>窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p><h3 id="UDP协议首部格式"><a href="#UDP协议首部格式" class="headerlink" title="UDP协议首部格式"></a>UDP协议首部格式</h3><p><img src="https://i.loli.net/2021/10/18/8bTXnoSEcUJ91Vm.png" alt="image-20211018104116091"></p><p>UDP首部有8个字节，由4个字段构成，每个字段都是两个字节，<br>1.源端口号： 可有可无，需要对方回信时选用，不需要时全部置0。<br>2.目的端口号：必须有，在终点交付报文的时候需要用到。<br>3.长度：UDP的数据报的长度（包括首部和数据）其最小值为8字节（只有首部）。<br>4.校验和：检测UDP数据报在传输中是否有错，有错则丢弃。<br>该字段是可选的，当源主机不想计算校验和，则直接令该字段全为0。<br>当传输层从IP层收到UDP数据报时，就根据首部中的目的端口，把UDP数据报通过相应的端口，上交给应用进程。<br>如果接收方UDP发现收到的报文中的目的端口号不正确（不存在对应端口号的应用进程0,），就丢弃该报文，并由ICMP发送“端口不可达”差错报文给对方。</p><h2 id="为什么常说-TCP-有粘包和拆包的问题而不说-UDP-？"><a href="#为什么常说-TCP-有粘包和拆包的问题而不说-UDP-？" class="headerlink" title="为什么常说 TCP 有粘包和拆包的问题而不说 UDP ？"></a>为什么常说 TCP 有粘包和拆包的问题而不说 UDP ？</h2><p>UDP 是基于报文发送的，UDP首部采用了 16bit 来指示 UDP 数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。</p><p>而 TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 并没有把这些数据块区分边界，仅仅是一连串没有结构的字节流；另外从 TCP 的帧结构也可以看出，在 TCP 的首部没有表示数据长度的字段，基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。</p><h2 id="为什么会发生-TCP-粘包、拆包？"><a href="#为什么会发生-TCP-粘包、拆包？" class="headerlink" title="为什么会发生 TCP 粘包、拆包？"></a>为什么会发生 TCP 粘包、拆包？</h2><ul><li>要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。</li><li>待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。</li><li>要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。</li><li>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。</li></ul><h2 id="粘包、拆包解决办法"><a href="#粘包、拆包解决办法" class="headerlink" title="粘包、拆包解决办法"></a>粘包、拆包解决办法</h2><p>由于 TCP 本身是面向字节流的，无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，归纳如下：</p><ul><li><strong>消息定长：</strong>发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</li><li><strong>设置消息边界：</strong>服务端从网络流中按消息边界分离出消息内容。在包尾增加回车换行符进行分割，例如 FTP 协议。</li><li><strong>将消息分为消息头和消息体：</strong>消息头中包含表示消息总长度（或者消息体长度）的字段。</li><li>更复杂的应用层协议比如 Netty 中实现的一些协议都对粘包、拆包做了很好的处理。</li></ul><h2 id="TCP-滑动窗口"><a href="#TCP-滑动窗口" class="headerlink" title="TCP 滑动窗口"></a>TCP 滑动窗口</h2><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p><p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p><p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p><p><img src="https://i.loli.net/2021/10/18/8gMoY4xip93WjtD.png" alt="image-20211018121614865"></p><p>题目答案均为转载，题目先后顺序按各大厂总出题次数排列！</p>]]></content>
      
      
      <categories>
          
          <category> 面试技巧 </category>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Steam流</title>
      <link href="/2021/10/01/Java-steam%E6%B5%81/"/>
      <url>/2021/10/01/Java-steam%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Java-Steam流"><a href="#Java-Steam流" class="headerlink" title="Java Steam流"></a>Java Steam流</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。</p><p>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。</p><p>首先要澄清的是 java8 中的 Stream 与 I/O 流 InputStream 和 OutputStream 是完全不同的概念。<br>Stream 机制是针对集合迭代器的增强。</p><h2 id="创建对象流的三种方式"><a href="#创建对象流的三种方式" class="headerlink" title="创建对象流的三种方式"></a>创建对象流的三种方式</h2><p>由集合对象创建流。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = list.stream();</span><br></pre></td></tr></table></figure><p>数组创建流。通过静态方法 <strong>Arrays.stream()</strong> 将数组转化为流</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream stream = Arrays.stream(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure><p>通过静态方法 <strong>Stream.of()</strong> ，但是底层其实还是调用 <code>Arrays.stream()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>注意：<br>还有两种比较特殊的流</p><ul><li>空流：<strong>Stream.empty()</strong></li><li>无限流：<strong>Stream.generate()</strong> 和 **Stream.iterate()**。可以配合 <strong>limit()</strong> 使用可以限制一下数量</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接受一个 Supplier 作为参数</span></span><br><span class="line">Stream.generate(Math::random).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">// 初始值是 0，新值是前一个元素值 + 2</span></span><br><span class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="流处理的特性"><a href="#流处理的特性" class="headerlink" title="流处理的特性"></a>流处理的特性</h2><ol><li><p>不存储数据</p></li><li><p>不会改变数据源</p></li><li><p>不可以重复使用</p><p>重复利用会抛出一个 <strong>IllegalStateException</strong> 的异常：</p><p><span style='color:red;'>java.lang.IllegalStateException: stream has already been operated upon or closed</span></p></li></ol><p>源数据流经管道，最后输出结果数据。</p><p><img src="https://i.loli.net/2021/10/01/uB6e9AvspgfDzNi.png" alt="image-20211001142843051"></p><h2 id="操作类型"><a href="#操作类型" class="headerlink" title="操作类型"></a>操作类型</h2><p>Stream 的所有操作连起来组合成了管道，管道有两种操作：<br>第一种，中间操作（intermediate）。调用中间操作方法返回的是一个新的流对象。中间操作不会输出值。<br>第二种，终值操作（terminal）。在调用该方法后，将执行之前所有的中间操作，并返回结果。</p><p><span style='background:yellow;color:red'>通过连续执行多个操作倒便就组成了 Stream 中的执行管道（pipeline）。需要注意的是这些管道被添加后并不会真正执行，只有等到调用终值操作之后才会执行。</span></p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ul><li>forEach：该方法用于对 Stream 中的每个元素进行迭代操作。</li><li>map：该方法用于将每个元素映射到对应的结果上。</li><li>filter：该方法用于过滤满足条件的元素。</li><li>limit(n)：获取前n个元素</li><li>skip(n)：跳过前n元素，配合limit(n)可实现分页</li><li>sorted()：自然排序，流中元素需实现Comparable接口</li><li>sorted(Comparator com)：定制排序，自定义Comparator排序器</li><li>distinct：通过流中元素的 <code>hashCode() 和 equals()</code> 去除重复元素</li><li>peek：逐个执行-中间操作</li><li>forEach()：遍历操作-终值操作</li><li>allMatch全部符合该条件返回true</li><li>noneMatch全部不符合该断言返回true</li><li>anyMatch 任意一个元素符合该断言返回true</li><li>allMatch全部符合该条件返回true</li><li>noneMatch全部不符合该断言返回true</li><li>anyMatch 任意一个元素符合该断言返回true</li><li>findFirst：返回流中第一个元素</li><li>findAny：返回流中的任意元素</li><li>count：返回流中元素的总个数</li><li>max：返回流中元素最大值</li><li>min：返回流中元素最小值</li></ul><ul><li>limit skip distinct sorted 都是有状态操作，这些操作只有拿到前面处理后的所有元素之后才能继续下去。</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><h4 id="Apply实体类"><a href="#Apply实体类" class="headerlink" title="Apply实体类"></a>Apply实体类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer appleId;   <span class="comment">//苹果编号</span></span><br><span class="line">        <span class="keyword">private</span> String appleName;  <span class="comment">//苹果类型</span></span><br><span class="line">        <span class="keyword">private</span> String location;   <span class="comment">//苹果产地</span></span><br><span class="line">        <span class="keyword">private</span> Integer weight;    <span class="comment">//苹果重量</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(Integer appleId, String appleName, String location, Integer weight)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.appleId = appleId;</span><br><span class="line">            <span class="keyword">this</span>.appleName = appleName;</span><br><span class="line">            <span class="keyword">this</span>.location = location;</span><br><span class="line">            <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//get set省略</span></span><br></pre></td></tr></table></figure><h4 id="流实现举例"><a href="#流实现举例" class="headerlink" title="流实现举例"></a>流实现举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Apple&gt; collect = list.stream().filter(apple -&gt; apple.weight &gt; <span class="number">5</span>).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        System.out.println(collect);</span><br><span class="line">        <span class="comment">//[Apple&#123;appleId=4, appleName=&#x27;红苹果&#x27;, location=&#x27;海南&#x27;, weight=8&#125;, Apple&#123;appleId=5, appleName=&#x27;青苹果&#x27;, location=&#x27;广东&#x27;, weight=10&#125;]</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; names = list.stream().map(apple -&gt; apple.appleName).collect(Collectors.toList());</span><br><span class="line">        System.out.println(names);</span><br><span class="line">        <span class="comment">//[红苹果, 红苹果, 红苹果, 红苹果, 青苹果, 青苹果]</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; distinctName = names.stream().distinct().collect(Collectors.toList());</span><br><span class="line">        System.out.println(distinctName);</span><br><span class="line">        <span class="comment">//[红苹果, 青苹果]</span></span><br><span class="line"></span><br><span class="line">        list.stream().limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">        <span class="comment">//Apple&#123;appleId=1, appleName=&#x27;红苹果&#x27;, location=&#x27;广东&#x27;, weight=5&#125;</span></span><br><span class="line">        <span class="comment">//Apple&#123;appleId=2, appleName=&#x27;红苹果&#x27;, location=&#x27;广东&#x27;, weight=5&#125;</span></span><br><span class="line">        <span class="comment">//Apple&#123;appleId=3, appleName=&#x27;红苹果&#x27;, location=&#x27;海南&#x27;, weight=4&#125;</span></span><br><span class="line"></span><br><span class="line">        list.stream().filter(apple -&gt; apple.getAppleName().equals(<span class="string">&quot;青苹果&quot;</span>))</span><br><span class="line">                .peek(apple -&gt; System.out.println(<span class="string">&quot;苹果筛选1：&quot;</span>+ apple))</span><br><span class="line">                .filter(apple -&gt; apple.getWeight()&gt;<span class="number">5</span>)</span><br><span class="line">                .peek(apple -&gt; System.out.println(<span class="string">&quot;苹果筛选2：&quot;</span>+ apple))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="comment">//苹果筛选1：Apple&#123;appleId=5, appleName=&#x27;青苹果&#x27;, location=&#x27;广东&#x27;, weight=10&#125;</span></span><br><span class="line">        <span class="comment">//苹果筛选2：Apple&#123;appleId=5, appleName=&#x27;青苹果&#x27;, location=&#x27;广东&#x27;, weight=10&#125;</span></span><br><span class="line">        <span class="comment">//苹果筛选1：Apple&#123;appleId=6, appleName=&#x27;青苹果&#x27;, location=&#x27;海南&#x27;, weight=5&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> count = list.parallelStream().filter(apple -&gt; apple.getLocation().equals(<span class="string">&quot;广东&quot;</span>)).count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">        Stream.iterate(<span class="number">0</span>,x-&gt;x+<span class="number">2</span>).limit(<span class="number">10</span>).collect(Collectors.toList()).forEach(System.out::print);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//024681012141618</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">        String merge = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining());</span><br><span class="line">        System.out.println(merge);</span><br><span class="line">        <span class="comment">//Collectors.joining合并  abcbcefgabcdjkl</span></span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">9</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>);</span><br><span class="line">        IntSummaryStatistics stats = numbers.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line">        System.out.println(<span class="string">&quot;列表中最大的数 : &quot;</span> + stats.getMax());</span><br><span class="line">        System.out.println(<span class="string">&quot;列表中最小的数 : &quot;</span> + stats.getMin());</span><br><span class="line">        System.out.println(<span class="string">&quot;所有数之和 : &quot;</span> + stats.getSum());</span><br><span class="line">        System.out.println(<span class="string">&quot;平均数 : &quot;</span> + stats.getAverage());</span><br><span class="line">        <span class="comment">//统计</span></span><br><span class="line"><span class="comment">//        列表中最大的数 : 10</span></span><br><span class="line"><span class="comment">//        列表中最小的数 : 3</span></span><br><span class="line"><span class="comment">//        所有数之和 : 69</span></span><br><span class="line"><span class="comment">//        平均数 : 6.2727272727272725</span></span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stringStream = strings.stream().flatMap(s -&gt; &#123;</span><br><span class="line"><span class="comment">//            将字符串以,分割后得到一个字符串数组</span></span><br><span class="line">            String[] split = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="comment">//            然后将每个字符串数组对应流返回，flatMap会自动把返回的所有流连接成一个流</span></span><br><span class="line">            Stream&lt;String&gt; stream = Arrays.stream(split).filter(x -&gt; !x.isEmpty());</span><br><span class="line">            <span class="keyword">return</span> stream;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(stringStream.collect(Collectors.toList()));</span><br><span class="line">        <span class="comment">//[abc, bc, efg, abcd, jkl]</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>此集合非彼集合-Arrays.asList()</title>
      <link href="/2021/09/24/java.lang.UnsupportedOperationException/"/>
      <url>/2021/09/24/java.lang.UnsupportedOperationException/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="此集合非彼集合-Arrays-asList"><a href="#此集合非彼集合-Arrays-asList" class="headerlink" title="此集合非彼集合-Arrays.asList()"></a>此集合非彼集合-Arrays.asList()</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天使用Arrays.asList();方法和两个数组arr1.removeAll(arr2);查交集</p><p>但出现<span style='color:red;'>java.lang.UnsupportedOperationException</span></p><p>报错代码（例）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] array = &#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>&#125;;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(array);</span><br><span class="line">        list.add(<span class="string">&quot;6&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="问题所在"><a href="#问题所在" class="headerlink" title="问题所在"></a>问题所在</h2><p>查阅资料，发生问题的原因如下：</p><p> <strong>Arrays的asList方法返回的是Arrays的内部类ArrayList，它并不是java.util.ArrayList</strong>，只不过它们的父类都是AbstractList。</p><p>可以看到Arrays的内部类ArrayList并没有重写add和remove方法，所以当我调用Arrays的内部类ArrayList的add方法时实际上是集成父类AbstractList的add方法。<br>AbstractList的add方法抛出java.lang.UnsupportedOperationException异常</p><p>而<strong>java.util.ArrayList的add方法重写了父类的方法，所以不会报错。</strong></p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>重新建一个数组即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] array = &#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>&#125;;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(array);</span><br><span class="line">        List arrList = <span class="keyword">new</span> ArrayList(list);</span><br><span class="line">        arrList.add(<span class="string">&quot;6&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue跨域代理配置 与 浏览器跨域配置</title>
      <link href="/2021/09/05/vue%E8%B7%A8%E5%9F%9F%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE%E4%B8%8E%20%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%A8%E5%9F%9F%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/09/05/vue%E8%B7%A8%E5%9F%9F%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE%E4%B8%8E%20%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%A8%E5%9F%9F%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="vue跨域代理配置与-浏览器跨域配置"><a href="#vue跨域代理配置与-浏览器跨域配置" class="headerlink" title="vue跨域代理配置与 浏览器跨域配置"></a>vue跨域代理配置与 浏览器跨域配置</h1><h2 id="浏览器报错信息如下"><a href="#浏览器报错信息如下" class="headerlink" title="浏览器报错信息如下"></a>浏览器报错信息如下</h2><p><img src="https://i.loli.net/2021/08/31/mxnHs8G9TrkPdNA.png" alt="跨域报错信息"></p><h2 id="方法一（适用于开发）"><a href="#方法一（适用于开发）" class="headerlink" title="方法一（适用于开发）"></a>方法一（适用于开发）</h2><p>vue.config.js 增加 <strong>disableHostCheck: true</strong></p><blockquote><p>disableHostCheck: true</p></blockquote><p>谷歌为例</p><p>创建快捷方式-&gt;右键属性-&gt;在 <strong>目标</strong>位置后面加上  </p><blockquote><p>–disable-web-security –user-data-dir=D:\MyChromeDevUserData </p></blockquote><p>user-data-dir 中 MyChromeDevUserData 是自己创建的文件夹</p><p><img src="https://i.loli.net/2021/08/31/y8KxTSJn6CeqIOv.png" alt="chrome跨域配置"></p><h2 id="方法2（推荐"><a href="#方法2（推荐" class="headerlink" title="方法2（推荐)"></a>方法2（推荐)</h2><p>在vue.config.js中配置代理</p><p>pathRewrite —- 在项目中找到<code>/api</code>(前)开头的URL，并替换为<code>/api</code>(后）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">port</span>: <span class="number">8200</span>, <span class="comment">// 此处修改你想要的端口号</span></span><br><span class="line">        <span class="attr">proxy</span>: &#123;  <span class="comment">//配置跨域</span></span><br><span class="line">            <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">              <span class="attr">target</span>: <span class="string">&#x27;http://xx.xx.xx.xxx:8100/&#x27;</span>,</span><br><span class="line">              <span class="attr">changOrigin</span>: <span class="literal">true</span>,  <span class="comment">//允许跨域</span></span><br><span class="line">              <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;/api&#x27;</span> </span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在配置统一的url js文件中，把<strong>baseURL改成地址前缀（关键）</strong></p><p>重点：<strong>baseURL: “/“</strong></p><p>若把baseURL写成改成vue的启动地址，则在<strong>window的nginix上没问题</strong>。但部署在Linux服务器上会出现找不到axios请求后台地址失败</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> request = axios.create(&#123;</span><br><span class="line">  <span class="comment">// 根据不同的环境设置baseURL，最终发送请求时的URL为: baseURL + 发送请求时写的URL</span></span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">  <span class="attr">withCredentials</span>: <span class="literal">true</span>, <span class="comment">// 允许携带cookie</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">20000</span> <span class="comment">// 请求超时, 20秒</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经过NGINX反向代理，后端服务器获取不了真实IP</title>
      <link href="/2021/09/01/%E7%BB%8F%E8%BF%87NGINX%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%8C%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8E%B7%E5%8F%96%E4%B8%8D%E4%BA%86%E7%9C%9F%E5%AE%9EIP/"/>
      <url>/2021/09/01/%E7%BB%8F%E8%BF%87NGINX%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%8C%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8E%B7%E5%8F%96%E4%B8%8D%E4%BA%86%E7%9C%9F%E5%AE%9EIP/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="经过NGINX反向代理，后端服务器获取不了真实IP"><a href="#经过NGINX反向代理，后端服务器获取不了真实IP" class="headerlink" title="经过NGINX反向代理，后端服务器获取不了真实IP"></a>经过NGINX反向代理，后端服务器获取不了真实IP</h1><p><strong>原因：</strong>通过了Apache，Squid，nginx等反向代理软件就不能获取到客户端的真实IP地址了。经过代理以后，由于在客户端和服务之间增加了中间层，因此服务器无法直接拿到客户端的IP(拿到的是中间层的ip)，服务器端应用也无法直接通过转发请求的地址返回给客户端。但是在转发请求的HTTP头信息中，增加了x-forwarded-for信息。用以跟踪原有的客户端IP地址和原来客户端请求的服务器地址。</p><p><strong>解决</strong>：在NGINX反向代理服务器上进行修改</p><p>在nginx配置文件中</p><p>每一个location上加上以下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxy_set_header Host $http_host;</span><br><span class="line">proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">proxy_set_header X-Forwarded-Proto $scheme;</span><br></pre></td></tr></table></figure><p>重启nginx即可</p><h2 id="springboot获取ip"><a href="#springboot获取ip" class="headerlink" title="springboot获取ip"></a><strong>springboot获取ip</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取登录用户的IP地址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getIp</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (request == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    String ip = request.getHeader(<span class="string">&quot;X-Requested-For&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (Strings.isEmpty(ip) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">        ip = request.getHeader(<span class="string">&quot;X-Forwarded-For&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Strings.isEmpty(ip) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">        ip = request.getHeader(<span class="string">&quot;Proxy-Client-IP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Strings.isEmpty(ip) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">        ip = request.getHeader(<span class="string">&quot;WL-Proxy-Client-IP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Strings.isEmpty(ip) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">        ip = request.getHeader(<span class="string">&quot;HTTP_CLIENT_IP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Strings.isEmpty(ip) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">        ip = request.getHeader(<span class="string">&quot;HTTP_X_FORWARDED_FOR&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Strings.isEmpty(ip) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">        ip = request.getRemoteAddr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;0:0:0:0:0:0:0:1&quot;</span>.equals(ip))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLocalHost</span><span class="params">(String ip)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;127.0.0.1&quot;</span>.equals(ip) || <span class="string">&quot;localhost&quot;</span>.equals(ip);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析ip地址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ipAddress</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getIpSource</span><span class="params">(String ipAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">&quot;http://opendata.baidu.com/api.php?query=&quot;</span> + ipAddress + <span class="string">&quot;&amp;co=&amp;resource_id=6006&amp;oe=utf8&quot;</span>);</span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(url.openConnection().getInputStream(), <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        StringBuffer result = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            result.append(line);</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close();</span><br><span class="line">        Map map = JSON.parseObject(result.toString(), Map.class);</span><br><span class="line">        List&lt;Map&lt;String, String&gt;&gt; data = (List) map.get(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> data.get(<span class="number">0</span>).get(<span class="string">&quot;location&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 后端 </category>
          
          <category> springboot </category>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker部署springboot项目</title>
      <link href="/2021/08/30/docker%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/"/>
      <url>/2021/08/30/docker%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="docker部署springboot项目"><a href="#docker部署springboot项目" class="headerlink" title="docker部署springboot项目"></a>docker部署springboot项目</h1><ol><li><p>编写dockerfile文件和打包maven项目</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java8</span><br><span class="line"><span class="keyword">MAINTAINER</span> chenqitian</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> overseas-study-0.0.1-SNAPSHOT.jar overseas-app.jar</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [java,-jar]</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8100</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [overseas-app.jar]</span></span><br></pre></td></tr></table></figure><p><strong>FROM-</strong>–指定哪个镜像作为新镜像的基础镜像</p><p><strong>MAINTAINER</strong>—-指明该镜像的作者信息</p><p><strong>ADD</strong>—将主机的文件复制到镜像中</p><p><strong>EXPOSE</strong>—暴露镜像的端口供主机做映射</p><p><strong>CMD</strong>—容器启动时需要执行的命令</p><p><img src="https://i.loli.net/2021/08/30/snmpPWb1fzhrTIg.png"></p></li><li><p>上传服务器</p><p>使用xftp，把dockerfile文件和jar包上传到服务器</p></li><li><p>打包成镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t [镜像名]</span><br></pre></td></tr></table></figure><p>docker images查看所安装的镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure></li><li><p>运行构建的镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8100:8100 [镜像名]</span><br></pre></td></tr></table></figure></li><li><p>完成</p><p>浏览器访问  xx.xx.xx.xx:8100即可</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 后端 </category>
          
          <category> springboot </category>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx+docker部署vue-cil项目</title>
      <link href="/2021/08/27/Nginx+docker%E9%83%A8%E7%BD%B2vue-cil%E9%A1%B9%E7%9B%AE/"/>
      <url>/2021/08/27/Nginx+docker%E9%83%A8%E7%BD%B2vue-cil%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Nginx-docker部署vue-cil项目"><a href="#Nginx-docker部署vue-cil项目" class="headerlink" title="Nginx+docker部署vue-cil项目"></a>Nginx+docker部署vue-cil项目</h1><ol><li><p>编写dockerfile文件</p><p><strong>FROM-</strong>–指定哪个镜像作为新镜像的基础镜像</p><p><strong>MAINTAINER</strong>—-指明该镜像的作者信息</p><p><strong>COPY</strong>—将主机的文件复制到镜像内</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">MAINTAINER</span> chenqitian</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> dist/ /usr/share/nginx/html/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> default.conf /etc/nginx/conf.d/default.conf</span></span><br></pre></td></tr></table></figure></li><li><p>打包vue-cil项目</p><p>cmd中输入以下命令，打包生成dist文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure></li><li><p>修改nginx配置文件<code>default.conf </code></p></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       8200;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   /usr/share/nginx/html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">try_files $uri $uri/ @router;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">location @router &#123;</span><br><span class="line">            rewrite ^.*$ /index.html last;</span><br><span class="line">        &#125;</span><br><span class="line">location ^~ /api &#123;</span><br><span class="line">            proxy_pass   http://47.106.128.108:8100;</span><br><span class="line">            add_header Access-Control-Allow-Methods *;</span><br><span class="line">            add_header Access-Control-Max-Age 3600;</span><br><span class="line">            add_header Access-Control-Allow-Credentials true;</span><br><span class="line">            add_header Access-Control-Allow-Origin $http_origin;</span><br><span class="line">            add_header Access-Control-Allow-Headers $http_access_control_request_headers;</span><br><span class="line">            if ($request_method = OPTIONS ) &#123;</span><br><span class="line">                return 200;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>3.上传到服务器</p><p>​    使用xftp，把dockerfile文件和default.conf上传到服务器</p><p>4.打包成镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t [镜像名]</span><br></pre></td></tr></table></figure><p>5.docker images查看所安装的镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>6.运行构建的镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8200:8200 [镜像名]</span><br></pre></td></tr></table></figure><p>7.完成</p><p>​    浏览器访问  xx.xx.xx.xx:8200即可</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">查看docker进程 -a（全部，包括不正常的）</span><br><span class="line">docker ps -a</span><br><span class="line">删除容器</span><br><span class="line">docker rm [容器id]</span><br><span class="line">删除镜像</span><br><span class="line">docker rmi [镜像id]</span><br><span class="line">查看镜像</span><br><span class="line">docker images</span><br><span class="line">进入容器</span><br><span class="line">docker <span class="built_in">exec</span> -it [容器id] /bin/bash</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
          <category> docker </category>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> nginx </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows配置Nginx部署vue-cil项目</title>
      <link href="/2021/08/25/windows+Nginx%E9%83%A8%E7%BD%B2vue-cil%E9%A1%B9%E7%9B%AE/"/>
      <url>/2021/08/25/windows+Nginx%E9%83%A8%E7%BD%B2vue-cil%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Windows配置Nginx部署vue-cil项目"><a href="#Windows配置Nginx部署vue-cil项目" class="headerlink" title="Windows配置Nginx部署vue-cil项目"></a>Windows配置Nginx部署vue-cil项目</h1><ol><li>nginx下载</li></ol><p><a href="https://nginx.org/en/download.html">nginx下载地址</a></p><ol start="2"><li>打包vue-cil项目</li></ol><p>cmd中输入以下命令，打包生成dist文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><ol start="3"><li>.修改nginx配置文件<code>nginx/conf/nginx.conf </code> </li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       8200;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">try_files $uri $uri/ @router;</span><br><span class="line">        &#125;</span><br><span class="line">location @router &#123;</span><br><span class="line">rewrite ^.*$ /index.html last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ^~ /api &#123;</span><br><span class="line">            proxy_pass   http://xx.xx.xxx.xxx:8100;</span><br><span class="line">            add_header Access-Control-Allow-Methods *;</span><br><span class="line">            add_header Access-Control-Max-Age 3600;</span><br><span class="line">            add_header Access-Control-Allow-Credentials true;</span><br><span class="line">            add_header Access-Control-Allow-Origin $http_origin;</span><br><span class="line">            add_header Access-Control-Allow-Headers $http_access_control_request_headers;</span><br><span class="line">            if ($request_method = OPTIONS ) &#123;</span><br><span class="line">                return 200;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li><p>把打包好的dist放入<code>nginx/html</code>文件夹中</p></li><li><p>CMD启动nginx</p></li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start nginx</span><br></pre></td></tr></table></figure><ol start="6"><li>访问localhost:8200成功</li></ol><h2 id="nginx常用命令"><a href="#nginx常用命令" class="headerlink" title="nginx常用命令"></a>nginx常用命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">查看帮助信息</span><br><span class="line">nginx -h</span><br><span class="line"></span><br><span class="line">查看nginx版本(小写字母v)</span><br><span class="line">nginx -v</span><br><span class="line"></span><br><span class="line">除版本信息外还显示配置参数信息(大写字母V)</span><br><span class="line">nginx -V</span><br><span class="line"></span><br><span class="line">启动nginx</span><br><span class="line">start nginx</span><br><span class="line"></span><br><span class="line">指定配置文件启动nginx</span><br><span class="line">start nginx -c filename</span><br><span class="line"></span><br><span class="line">关闭nginx，完整有序的停止nginx，保存相关信息</span><br><span class="line">nginx -s quit</span><br><span class="line"></span><br><span class="line">关闭nginx，快速停止nginx，可能并不保存相关信息</span><br><span class="line">nginx -s stop</span><br><span class="line"></span><br><span class="line">重新载入nginx，当配置信息修改需要重新加载配置是使用</span><br><span class="line">nginx -s reload</span><br><span class="line"></span><br><span class="line">重新打开日志文件</span><br><span class="line">nginx -s reopen</span><br><span class="line"></span><br><span class="line">测试nginx配置文件是否正确</span><br><span class="line">nginx -t -c filename</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swagger3整合oauth2 认证token</title>
      <link href="/2021/08/24/swagger3%E6%95%B4%E5%90%88oauth2%20%E8%AE%A4%E8%AF%81token/"/>
      <url>/2021/08/24/swagger3%E6%95%B4%E5%90%88oauth2%20%E8%AE%A4%E8%AF%81token/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="swagger3整合oauth2-认证token"><a href="#swagger3整合oauth2-认证token" class="headerlink" title="swagger3整合oauth2 认证token"></a>swagger3整合oauth2 认证token</h1><h2 id="引入swagger3依赖"><a href="#引入swagger3依赖" class="headerlink" title="引入swagger3依赖"></a>引入swagger3依赖</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--Swagger3 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.0</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="swagger配置文件编写"><a href="#swagger配置文件编写" class="headerlink" title="swagger配置文件编写"></a>swagger配置文件编写</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">createRestApi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.OAS_30)</span><br><span class="line">                .enable(enable)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .groupName(<span class="string">&quot;xx项目接口&quot;</span>)</span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">//配置要扫描接口的方式</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.os&quot;</span>))</span><br><span class="line">                .build()</span><br><span class="line"></span><br><span class="line">                .securitySchemes(securitySchemes())</span><br><span class="line">                .securityContexts(securityContexts());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证的安全上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;SecurityScheme&gt; <span class="title">securitySchemes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;SecurityScheme&gt; securitySchemes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        securitySchemes.add(<span class="keyword">new</span> ApiKey(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;header&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> securitySchemes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权信息全局应用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;SecurityContext&gt; <span class="title">securityContexts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;SecurityContext&gt; securityContexts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        securityContexts.add(SecurityContext.builder()</span><br><span class="line">                .securityReferences(defaultAuth())</span><br><span class="line">                .forPaths(PathSelectors.any()).build());</span><br><span class="line">        <span class="keyword">return</span> securityContexts;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;SecurityReference&gt; <span class="title">defaultAuth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AuthorizationScope authorizationScope = <span class="keyword">new</span> AuthorizationScope(<span class="string">&quot;global&quot;</span>, <span class="string">&quot;accessEverything&quot;</span>);</span><br><span class="line">        AuthorizationScope[] authorizationScopes = <span class="keyword">new</span> AuthorizationScope[<span class="number">1</span>];</span><br><span class="line">        authorizationScopes[<span class="number">0</span>] = authorizationScope;</span><br><span class="line">        List&lt;SecurityReference&gt; securityReferences = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        securityReferences.add(<span class="keyword">new</span> SecurityReference(<span class="string">&quot;Authorization&quot;</span>, authorizationScopes));</span><br><span class="line">        <span class="keyword">return</span> securityReferences;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>请求头：Authorization</p><h2 id="swagger中的效果展示"><a href="#swagger中的效果展示" class="headerlink" title="swagger中的效果展示"></a>swagger中的效果展示</h2><p><img src="https://i.loli.net/2021/08/22/FQEVo2rBAiHRk1J.png" alt="image-20210630123347451"></p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 后端 </category>
          
          <category> SpringBoot </category>
          
          <category> SpringSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> SpringSecurity </tag>
            
            <tag> 后端 </tag>
            
            <tag> token </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot启动报错（webSecurity匿名问题）</title>
      <link href="/2021/08/22/springboot%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99%EF%BC%88webSecurity%E5%8C%BF%E5%90%8D%E9%97%AE%E9%A2%98%EF%BC%89/"/>
      <url>/2021/08/22/springboot%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99%EF%BC%88webSecurity%E5%8C%BF%E5%90%8D%E9%97%AE%E9%A2%98%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="springboot启动报错（webSecurity匿名问题）"><a href="#springboot启动报错（webSecurity匿名问题）" class="headerlink" title="springboot启动报错（webSecurity匿名问题）"></a>springboot启动报错（webSecurity匿名问题）</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘springSecurityFilterChain’ defined in <span class="class"><span class="keyword">class</span> <span class="title">path</span> <span class="title">resource</span> [<span class="title">org</span>/<span class="title">springframework</span>/<span class="title">security</span>/<span class="title">config</span>/<span class="title">annotation</span>/<span class="title">web</span>/<span class="title">configuration</span>/<span class="title">WebSecurityConfiguration</span>.<span class="title">class</span>]: <span class="title">Bean</span> <span class="title">instantiation</span> <span class="title">via</span> <span class="title">factory</span> <span class="title">method</span> <span class="title">failed</span></span>; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [javax.servlet.Filter]: Factory method ‘springSecurityFilterChain’ threw exception; nested exception is java.lang.IllegalStateException: An incomplete mapping was found <span class="keyword">for</span> []. <span class="function">Try completing it with something like <span class="title">requestUrls</span><span class="params">()</span>..<span class="title">hasRole</span><span class="params">(‘USER’)</span></span></span><br></pre></td></tr></table></figure><h2 id="在WebSecurityConfig-SecurityConfig-中配置"><a href="#在WebSecurityConfig-SecurityConfig-中配置" class="headerlink" title="在WebSecurityConfig(SecurityConfig)中配置"></a>在WebSecurityConfig(SecurityConfig)中配置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">                <span class="comment">//放行swagger</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/swagger-ui.html&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/swagger-ui/*&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/swagger-resources/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/v2/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/v3/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/img.icons/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/webjars/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/doc.html&quot;</span>).permitAll()</span><br><span class="line">    <span class="comment">//只有匿名用户才能访问，其他都要登录</span></span><br><span class="line">                <span class="comment">// 所有加 AnonymousAccess 注解的请求都允许匿名访问</span></span><br><span class="line">                .antMatchers(getAnonymousUrls()).anonymous();</span><br><span class="line">                <span class="comment">//所有请求必须被认证（登录）</span></span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">                </span><br></pre></td></tr></table></figure><p><strong>方法一</strong>: antMatchers(getAnonymousUrls()).anonymous(); 和anyRequest().authenticated(); 同时有</p><p><strong>方法二</strong>: antMatchers(getAnonymousUrls()).anonymous(); 和至少用一个方法上有@AnonymousAccess注解</p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 后端 </category>
          
          <category> SpringBoot </category>
          
          <category> SpringSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> SpringSecurity </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot SpringSecurity 整合knife4j, Swagger3问题</title>
      <link href="/2021/08/20/Springboot%20SpringSecurity%20%E6%95%B4%E5%90%88knife4j,%20Swagger3%E9%97%AE%E9%A2%98/"/>
      <url>/2021/08/20/Springboot%20SpringSecurity%20%E6%95%B4%E5%90%88knife4j,%20Swagger3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Springboot-SpringSecurity-整合knife4j-Swagger3问题"><a href="#Springboot-SpringSecurity-整合knife4j-Swagger3问题" class="headerlink" title="Springboot SpringSecurity 整合knife4j, Swagger3问题"></a>Springboot SpringSecurity 整合knife4j, Swagger3问题</h1><p>版本说明： swagger3版本3.0.0，knife4j版本3.0.2</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--swagger3--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>SpringSecurity放行静态资源</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">                <span class="comment">//放行swagger</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/swagger-ui.html&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/swagger-ui/*&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/swagger-resources/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/v2/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/v3/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/img.icons/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/webjars/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/doc.html&quot;</span>).permitAll()</span><br></pre></td></tr></table></figure><p>Swagger3Config 继承 WebMvcConfigurationSupport 过滤</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.</span><br><span class="line">                addResourceHandler(<span class="string">&quot;/swagger-ui/**&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/webjars/springfox-swagger-ui/&quot;</span>)</span><br><span class="line">                .resourceChain(<span class="keyword">false</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;doc.html&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/webjars/**&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>开启注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableOpenApi</span> <span class="comment">//swagger3</span></span><br><span class="line"><span class="meta">@EnableKnife4j</span> <span class="comment">//knife4j 3.0.2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Swagger3Config</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 后端 </category>
          
          <category> SpringBoot </category>
          
          <category> SpringSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> SpringSecurity </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构建React-app应用时create-react-app卡住超慢的解决办法</title>
      <link href="/2021/08/16/%E6%9E%84%E5%BB%BAReact-app%E5%BA%94%E7%94%A8%E6%97%B6create-react-app%E5%8D%A1%E4%BD%8F%E8%B6%85%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2021/08/16/%E6%9E%84%E5%BB%BAReact-app%E5%BA%94%E7%94%A8%E6%97%B6create-react-app%E5%8D%A1%E4%BD%8F%E8%B6%85%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="构建React-app应用时create-react-app卡住超慢的解决办法"><a href="#构建React-app应用时create-react-app卡住超慢的解决办法" class="headerlink" title="构建React-app应用时create-react-app卡住超慢的解决办法"></a>构建React-app应用时create-react-app卡住超慢的解决办法</h1><h2 id="解决办法：npm换源（淘宝镜像）"><a href="#解决办法：npm换源（淘宝镜像）" class="headerlink" title="解决办法：npm换源（淘宝镜像）"></a>解决办法：npm换源（淘宝镜像）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line">-- 配置后可通过下面方式来验证是否成功</span><br><span class="line">npm config get registry</span><br><span class="line">-- 显示出上述地址的话就是更换成功</span><br></pre></td></tr></table></figure><h2 id="再次尝试构建"><a href="#再次尝试构建" class="headerlink" title="再次尝试构建"></a>再次尝试构建</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">creat-react-app first-react-app（app名称）</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 前端 </category>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>佛山探店 | 有趣好玩switch小店</title>
      <link href="/2021/08/10/%E4%BD%9B%E5%B1%B1%E6%8E%A2%E5%BA%97-BlackPearl/"/>
      <url>/2021/08/10/%E4%BD%9B%E5%B1%B1%E6%8E%A2%E5%BA%97-BlackPearl/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="有趣好玩switch小店🎮"><a href="#有趣好玩switch小店🎮" class="headerlink" title="有趣好玩switch小店🎮"></a>有趣好玩switch小店🎮</h1><p>🏠地点：建新路103号三座首层B号二楼（祖庙铂顿城隔壁-三合凉拌楼上）</p><ul><li>⭐环境很好，干净整洁</li><li>👾游戏也有十几个</li><li>✨店内装饰很游戏风</li><li>✨有很多的小摆设</li><li>💵￥50/2小时</li></ul><p><img src="https://i.loli.net/2021/08/14/86QUfN5An2tSxwj.jpg"></p><p><img src="https://i.loli.net/2021/08/14/A7I4m6gRByUMZaG.jpg"></p><p><img src="https://i.loli.net/2021/08/14/EcAPWbCZvQ4gdxo.jpg"></p><p><img src="https://i.loli.net/2021/08/14/1KaAX6pG9nJjrPo.jpg" alt="game1.jpg"></p><p><img src="https://i.loli.net/2021/08/14/tlr2WHIMS5q8kjc.jpg" alt="game2.jpg"></p><p><img src="https://i.loli.net/2021/08/14/sHJPUw2hIXBlOKz.jpg" alt="game3.jpg"></p><p><img src="https://i.loli.net/2021/08/14/bxBKPv69nJyTErs.jpg"></p><p>一次值得的体验，游戏爱好者推荐来玩哈👍</p>]]></content>
      
      
      <categories>
          
          <category> 探店 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 探店 </tag>
            
            <tag> 日常生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git踩坑 - 1</title>
      <link href="/2021/08/06/git%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/08/06/git%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="git踩坑-1"><a href="#git踩坑-1" class="headerlink" title="git踩坑 - 1"></a>git踩坑 - 1</h1><h4 id="git仓库大文件push失败报413-Request-Entity-Too-Large-问题解决办法"><a href="#git仓库大文件push失败报413-Request-Entity-Too-Large-问题解决办法" class="headerlink" title="git仓库大文件push失败报413 Request Entity Too Large 问题解决办法"></a>git仓库大文件push失败报413 Request Entity Too Large 问题解决办法</h4><p>使用https方式拉取的git仓库，在push文件时报错Gitlab error push files 413 Request Entity Too Large</p><p>尝试了如下</p><ol><li>增大https方式的post缓存   (不成功)</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config http.postBuffer 524288000</span><br></pre></td></tr></table></figure><p>  2.修改本地仓库的https方式为ssh （成功）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote set-url origin ssh地址</span><br></pre></td></tr></table></figure><hr><h4 id="git-pull遇到错误：error-Your-local-changes-to-the-following-files-would-be-overwritten-by-merge"><a href="#git-pull遇到错误：error-Your-local-changes-to-the-following-files-would-be-overwritten-by-merge" class="headerlink" title="git pull遇到错误：error: Your local changes to the following files would be overwritten by merge"></a>git pull遇到错误：error: Your local changes to the following files would be overwritten by merge</h4><p><strong>原因：本地项目有修改，不能更新</strong></p><p><strong>方法1</strong>: 如果你想保留刚才本地修改的代码，并把git服务器上的代码pull到本地（本地刚才修改的代码将会被暂时封存起来）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash </span><br><span class="line"></span><br><span class="line">git pull origin master </span><br><span class="line"></span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>服务器上的代码更新到了本地，而且你本地修改的代码也没有被覆盖，之后使用add，commit，push 命令即可更新本地代码到服务器了。</p><p><strong>方法2</strong>: 如果你想完全地覆盖本地的代码，只保留服务器端代码，则直接回退到上一个版本，再进行pull</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset *--hard* </span><br><span class="line"></span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><p><strong>方法3</strong>:合并代码</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;xxx&quot;</span></span><br><span class="line">git pull</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><hr><h4 id="命令Hexo-d上传GitHub超时报错"><a href="#命令Hexo-d上传GitHub超时报错" class="headerlink" title="命令Hexo d上传GitHub超时报错"></a>命令Hexo d上传GitHub超时报错</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">atal: unable to access <span class="string">&#x27;https://github.com/.......&#x27;</span>: OpenSSL SSL_read: Connection was reset, errno 10054</span><br></pre></td></tr></table></figure><p>产生原因：一般是这是因为服务器的SSL证书没有经过第三方机构的签署，所以报错</p><p>参考网上解决办法：解除ssl验证后  (无效果)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global http.sslVerify &quot;false&quot;</span><br></pre></td></tr></table></figure><p>或出现错误</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fatal: unable to access <span class="string">&#x27;https://github.com/.../.git&#x27;</span>: Could not resolve host: github.com</span><br></pre></td></tr></table></figure><p>参考网上解决办法：解除代理  (无效果)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy </span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure><p>或出现错误</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fatal: unable to access <span class="string">&#x27;https://github.com/Chankeitin/Chankeitin.github.io.git/&#x27;</span>: Failed to connect to github.com port 443: Timed out</span><br></pre></td></tr></table></figure><p>或出现错误</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fatal: unable to access <span class="string">&#x27;https://github.com/Chankeitin/Chankeitin.github.io.git/&#x27;</span>: Empty reply from server</span><br><span class="line">FATAL &#123;</span><br><span class="line">  ......</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Something<span class="string">&#x27;s wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html</span></span><br></pre></td></tr></table></figure><p>最后统一解决：</p><p><strong>重复运行命令，直到push成功</strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Aplayer报错解决方案</title>
      <link href="/2021/08/05/Aplay%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/"/>
      <url>/2021/08/05/Aplay%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>hexo - g 报错如下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">INFO  Start processing</span><br><span class="line">Error: [hexo-tag-aplayer] Meting support is disabled, cannot resolve the meting tags properly.</span><br><span class="line">    at throwError (E:\Node_JS_Hexo\node_modules\hexo-tag-aplayer\common\util.js:18:9)</span><br><span class="line">    at Object.&lt;anonymous&gt; (E:\Node_JS_Hexo\node_modules\hexo-tag-aplayer\index.js:160:28)</span><br><span class="line">    at NunjucksTag._run (E:\Node_JS_Hexo\node_modules\hexo\lib\extend\tag.js:120:18)</span><br><span class="line">    at NunjucksTag.run (E:\Node_JS_Hexo\node_modules\hexo\lib\extend\tag.js:116:15)</span><br><span class="line">    at Template.root [as rootRenderFunc] (eval at _compile (E:\Node_JS_Hexo\node_modules\nunjucks\src\environment.js:617:18), &lt;anonymous&gt;:29:66)</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>请在 Hexo 配置文件 _config.yml 中设置即可： （<strong>切记是hexo的配置文件，不是themes文件夹里面的）</strong></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">aplayer:</span>  </span><br><span class="line"><span class="attr">meting:</span> <span class="literal">true</span> </span><br></pre></td></tr></table></figure><p>请不要配置：（这个是给Meting.js用的，Aplayer误设置会导致变成空白的） </p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Aplayer:</span></span><br><span class="line"><span class="attr">asset_inject:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速搭建Hexo博客</title>
      <link href="/2021/08/04/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2/"/>
      <url>/2021/08/04/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="快速搭建Hexo博客"><a href="#快速搭建Hexo博客" class="headerlink" title="快速搭建Hexo博客"></a>快速搭建Hexo博客</h1><h2 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h2 id="Hexo搭建"><a href="#Hexo搭建" class="headerlink" title="Hexo搭建"></a>Hexo搭建</h2><h3 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h3><p>需要先安装下列应用程序</p><ul><li><p><a href="http://nodejs.org/">Node.js</a></p></li><li><p><a href="http://git-scm.com/">Git</a></p></li><li><p>notepad++(作为编辑器 <strong>可选</strong>)</p></li></ul><h3 id="安装hexo脚手架"><a href="#安装hexo脚手架" class="headerlink" title="安装hexo脚手架"></a>安装hexo脚手架</h3><p>打开cmd，输入下面命令全局安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>用<code>hexo -v</code>查看一下版本，验证是否安装成功</p><p>创建一个文件夹blog，然后<code>cd</code>到这个文件夹下</p><p>输入命令初始化hexo项目</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init</span><br><span class="line">或 hexo init blog(博客名)</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹目录下有：</p><ul><li><p>node_modules: 依赖包</p></li><li><p>public：存放生成的静态页面</p></li><li><p>scaffolds：生成文章的一些模板</p></li><li><p>source：用来存放你的文章</p></li><li><p>themes：主题</p></li><li><p>_config.yml: 博客的配置文件</p></li></ul><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><h3 id="测试运行"><a href="#测试运行" class="headerlink" title="测试运行"></a>测试运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>打开hexo的服务，在浏览器输入localhost:4000就可以看到你默认生成的博客了。</p><p>使用ctrl+c可以把服务关掉。</p><h3 id="GitHub-Gitee创建个人仓库"><a href="#GitHub-Gitee创建个人仓库" class="headerlink" title="GitHub/Gitee创建个人仓库"></a>GitHub/Gitee创建个人仓库</h3><p>首先，你先要有一个GitHub/Gitee账户，去注册一个吧。</p><p>注册完登录后，新建仓库</p><p>创建一个和你用户名相同的仓库，后面加.github.io/gitee.io，只有这样，将来要部署到GitHub page/Gitee page的时候，才会被识别，也就是xxxx.github.io/xxxx.gitee.io，其中xxx就是你注册的用户名。</p><h3 id="将hexo部署到GitHub"><a href="#将hexo部署到GitHub" class="headerlink" title="将hexo部署到GitHub"></a>将hexo部署到GitHub</h3><p>这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 <code>_config.yml</code>，翻到最后，修改为</p><p>username为GitHub用户名</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/username/username.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>安装deploy-git ，也就是部署的命令。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>输入命令进行部署</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>过一会儿就可以在<code>http://username.github.io</code> 这个网站看到你的博客了！！</p><hr><h2 id="主题模板"><a href="#主题模板" class="headerlink" title="主题模板"></a>主题模板</h2><h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><p>在<a href="https://hexo.io/themes/%E5%AE%98%E7%BD%91%E4%B8%AD%E9%A2%84%E8%A7%88%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%BB%E9%A2%98%EF%BC%8C%E5%9C%A8GitHub%E4%B8%AD%E6%90%9C%E7%B4%A2%E4%B8%BB%E9%A2%98%E5%90%8D%EF%BC%8C%E5%B9%B6clone%E5%88%B0%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95%E7%9A%84themes%E6%96%87%E4%BB%B6%E5%A4%B9%E5%86%85%EF%BC%88%E5%8F%82%E8%80%83%E8%B7%AF%E5%BE%84%EF%BC%9Ablog/themes/%EF%BC%89">https://hexo.io/themes/官网中预览喜欢的主题，在GitHub中搜索主题名，并clone到博客目录的themes文件夹内（参考路径：blog/themes/）</a></p><p>以Butterfly主题为例</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/jerryc127/hexo-theme-butterfly</span><br></pre></td></tr></table></figure><p>并在<code>_config.yml</code>中配置该主题,<code>ctrl+f</code>搜索关键字<code>theme</code>,把值修改成butterfly（themes中克隆模板的文件夹名）</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure><p>如果没有 pug 以及 stylus 的渲染器，需要安装</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-renderer-pug</span> <span class="string">hexo-renderer-stylus</span> <span class="string">--save</span></span><br></pre></td></tr></table></figure><p>重新编译启动</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>访问localhost:4000，成功即可</p><hr><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">hexo</span> <span class="string">clean</span> <span class="string">清除了之前生成的东西</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">g</span> <span class="string">编译代码</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">d</span> <span class="string">部署文章</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">n</span> <span class="string">page</span> <span class="string">xx</span> <span class="string">新建页面</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">new</span> <span class="string">xx</span> <span class="string">新建博客文章</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客建设及踩坑</title>
      <link href="/2021/08/04/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE%E5%8F%8A%E8%B8%A9%E5%9D%91/"/>
      <url>/2021/08/04/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE%E5%8F%8A%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="Hexo建设"><a href="#Hexo建设" class="headerlink" title="Hexo建设"></a>Hexo建设</h3><h4 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h4><h5 id="设置导航栏（主题里的-config-yml）"><a href="#设置导航栏（主题里的-config-yml）" class="headerlink" title="设置导航栏（主题里的_config.yml）"></a>设置导航栏（主题里的<code>_config.yml</code>）</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">   <span class="string">首页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">   <span class="string">归档:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">   <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">   <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">   <span class="string">娱乐||fas</span> <span class="attr">fa-list:</span></span><br><span class="line">     <span class="string">音乐:</span> <span class="string">/music/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-music</span></span><br><span class="line">     <span class="string">电影:</span> <span class="string">/movies/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-video</span></span><br><span class="line">   <span class="string">友链:</span> <span class="string">/link/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line">   <span class="string">关于:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-heart</span></span><br></pre></td></tr></table></figure><h5 id="配置网站样式"><a href="#配置网站样式" class="headerlink" title="配置网站样式"></a>配置网站样式</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Image (圖片設置)</span><br><span class="line"># --------------------------------------</span><br><span class="line"></span><br><span class="line"># Favicon（網站圖標）</span><br><span class="line">favicon: /img/favicon.png</span><br><span class="line"></span><br><span class="line"># Avatar (頭像)</span><br><span class="line">avatar:</span><br><span class="line">  img: /img/avatar.png</span><br><span class="line">  effect: false</span><br><span class="line"></span><br><span class="line"># the banner image of home page</span><br><span class="line">……</span><br></pre></td></tr></table></figure><h5 id="设置主页名句"><a href="#设置主页名句" class="headerlink" title="设置主页名句"></a>设置主页名句</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subtitle:</span><br><span class="line">  enable: true</span><br><span class="line">  # Typewriter Effect (打字效果)</span><br><span class="line">  effect: true</span><br><span class="line">  # loop (循環打字)</span><br><span class="line">  loop: true</span><br><span class="line">  # source調用第三方服務</span><br><span class="line">  # source: false 關閉調用</span><br><span class="line">  # source: 1  調用搏天api的隨機語錄（簡體） https://api.btstu.cn/</span><br><span class="line">  # source: 2  調用一言網的一句話（簡體） https://hitokoto.cn/</span><br><span class="line">  # source: 3  調用一句網（簡體） http://yijuzhan.com/</span><br><span class="line">  # source: 4  調用今日詩詞（簡體） https://www.jinrishici.com/</span><br><span class="line">  # subtitle 會先顯示 source , 再顯示 sub 的內容</span><br><span class="line">  source: true</span><br><span class="line">  # 如果有英文逗號&#x27; , &#x27;,請使用轉義字元 &amp;#44;</span><br><span class="line">  # 如果有英文雙引號&#x27; &quot; &#x27;,請使用轉義字元 &amp;quot;</span><br><span class="line">  # 開頭不允許轉義字元，如需要，請把整個句子用雙引號包住</span><br><span class="line">  # 如果關閉打字效果，subtitle只會顯示sub的第一行文字</span><br><span class="line">  sub: </span><br><span class="line">    - 有德必有勇，正直的人绝不胆怯。</span><br><span class="line">    - 即使慢，驰而不息，纵会落后，纵会失败，但一定可以达到他所向的目标。</span><br></pre></td></tr></table></figure><h5 id="配置社交图标"><a href="#配置社交图标" class="headerlink" title="配置社交图标"></a>配置社交图标</h5><p>在阿里巴巴矢量图标库里面，把需要的图标添加购物车，在新建项目，在购物车中将图标添加到项目中,在主题配置文件中修改：</p><p>把样式添加到页头</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Inject</span><br><span class="line"># Insert the code to head (before &#x27;&lt;/head&gt;&#x27; tag) and the bottom (before &#x27;&lt;/body&gt;&#x27; tag)</span><br><span class="line"># 插入代码到头部 &lt;/head&gt; 之前 和 底部 &lt;/body&gt; 之前</span><br><span class="line">inject:</span><br><span class="line">  head:</span><br><span class="line">   - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/iconfont.css&quot;&gt; #引入阿里巴巴矢量图库</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">social:</span><br><span class="line">  fab fa-github: https://github.com/xxxxx || Github</span><br><span class="line">  iconfont gitee: https://gitee.com/××× ||Gitee</span><br></pre></td></tr></table></figure><h4 id="文章格式"><a href="#文章格式" class="headerlink" title="文章格式"></a>文章格式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:【必需】页面标题</span><br><span class="line">date:【必需】页面创建日期</span><br><span class="line">type: 【必需】标籤、分类和友情链接三个页面需要配置</span><br><span class="line">updated:【可选】页面更新日期</span><br><span class="line">description:【可选】页面描述</span><br><span class="line">keywords: 【可选】页面关键字</span><br><span class="line">comments: 【可选】显示页面评论模块 (默认 true)</span><br><span class="line">top_img: 【可选】页面顶部图片</span><br><span class="line">mathjax: 【可选】显示 mathjax (当设置 mathjax 的 per_page: false 时，才需要配置，默认 false)</span><br><span class="line">katex: 【可选】显示 katex (当设置 katex 的 per_page: false 时，才需要配置，默认 false)</span><br><span class="line">aside: 【可选】显示侧边栏 (默认 true)</span><br><span class="line">aplayer: 【可选】在需要的页面加载 aplayer 的 js 和 css, 请参考文章下面的音乐 配置</span><br><span class="line">highlight_shrink: 【可选】配置代码框是否展开 (true/false)(默认为设置中 highlight_shrink 的配置)</span><br><span class="line">cover:封面图片的url</span><br><span class="line"></span><br><span class="line">copyright: true</span><br><span class="line">copyright_author: xxxx</span><br><span class="line">copyright_author_href: https://github.com/Chankeitin</span><br><span class="line">copyright_url: https://chankeitin.github.io/</span><br><span class="line">copyright_info: 此文章版权归Chankeitin所有，如有转载，请註明来自原作者</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>copyright -&gt; 复制内容携带作者信息</p><p>cover后面输入你想要的封面图片的url</p><p>top_img后面加上你想要的顶部图片的url</p><h4 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h4><p>友情链接的添加需要在完成该操作的基础上，新建<code>source/_data/link.yml</code>文件，添加如下内容</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">class_name:</span> <span class="string">友情链接</span></span><br><span class="line">  <span class="attr">class_desc:</span> <span class="string">那些人，那些事，那些开发者工具</span></span><br><span class="line">  <span class="attr">link_list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Chankeitin</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://chankeitin.github.io</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">https://i.loli.net/2021/08/05/cZd4CF96pgqrQBH.jpg</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">想成为全栈程序猿</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MyBatis-Plus</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://baomidou.com/</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">https://baomidou.com/img/logo.svg</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">为简化开发而生</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Spring</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://spring.io/</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">http://c.biancheng.net/uploads/allimg/210701/1-210F1141343544.png</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">Spring</span> <span class="string">makes</span> <span class="string">Java</span> <span class="string">simple.</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Hexo</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://hexo.io/zh-tw/</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">快速、简单且强大的博客框架</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
