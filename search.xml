<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java-原子操作</title>
      <link href="/2021/11/07/Java-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"/>
      <url>/2021/11/07/Java-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Java-原子操作"><a href="#Java-原子操作" class="headerlink" title="Java-原子操作"></a>Java-原子操作</h1><h2 id="题一"><a href="#题一" class="headerlink" title="题一:"></a>题一:</h2><p>以下多线程对int型变量x的操作，哪个不需要进行同步（  ）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A: x=y;</span><br><span class="line">B: x++;</span><br><span class="line">C: ++x;</span><br><span class="line">D: x=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="答案：C"><a href="#答案：C" class="headerlink" title="答案：C"></a>答案：C</h3><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>A.由于y的值不确定，所以要加锁；</p><p>B,C 两个在多线程情况下是必须要加锁的，因为他们是先被读入寄存器，然后再进行+1操作，如果没有加锁，那么可能会出现数据异常；</p><p>D 原子操作，所以不需要加锁</p><p>  原子性：指该操作不能再继续划分为更小的操作。</p><p>A.由于y的值不确定，所以要加锁；</p><p>B,C 两个在多线程情况下是必须要加锁的，因为他们是先被读入寄存器，然后再进行+1操作，如果没有加锁，那么可能会出现数据异常；</p><p>D 原子操作，所以不需要加锁</p><p>  原子性：指该操作不能再继续划分为更小的操作。</p><blockquote><p>Java中的原子操作包括：   </p><p>​    1、除long和double之外的基本类型的赋值操作</p><p>​    2、所有引用reference的赋值操作</p><p>​    3、java.concurrent.Atomic.* 包中所有类的一切操作</p></blockquote><p>在Java中，我们可以通过同步锁或者CAS操作来实现原子操作。</p><h3 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h3><p>CAS是Compare and swap的简称，这个操作是硬件级别的操作，在硬件层面保证了操作的原子性。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。<strong>当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</strong>Java中的<code>sun.misc.Unsafe</code>类提供了<code>compareAndSwapInt</code>和<code>compareAndSwapLong</code>等几个方法实现CAS。</p><p><img src="https://i.loli.net/2021/11/09/RTCPD39Sx1crunw.png" alt="image-20211109103824788"></p><p>举个栗子：整型原子类源码</p><p><img src="https://i.loli.net/2021/11/09/iVqtZDOk5Qwzd6f.png" alt="image-20211109104146274"></p><p>UnSafe类是CAS的核心类由于Java 方法无法直接访问底层，需要通过本地(native)方法来访问，基于该类可以直接操作特额定的内存数据.UnSafe类在于sun.misc包中，其内部方法操作可以向C的指针一样直接操作内存,因为Java中CAS操作的助兴依赖于UNSafe类的方法。</p><ul><li>变量ValueOffset：它是该变量在内存中的偏移地址,因为UnSafe就是根据内存偏移地址获取数据的</li><li>变量value：被volatile修饰,保证了多线程之间的可见性.</li></ul><p><img src="https://i.loli.net/2021/11/09/5wdaY6KkBszo1Hf.png" alt="image-20211109104346043"></p><h3 id="CAS引出的问题"><a href="#CAS引出的问题" class="headerlink" title="CAS引出的问题"></a>CAS引出的问题</h3><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p><strong>问题描述：</strong>当你获得对象当前数据后，在准备修改为新值前，对象的值被其他线程连续修改了两次，而经过两次修改后，对象的值又恢复为旧值，这样当前线程无法正确判断这个对象是否修改过。</p><p><strong>解决办法</strong>：JDK1.5可以利用<code>AtomicStampedReference</code>类来解决这个问题，<code>AtomicStampedReference</code>内部不仅维护了对象值，还维护了一个<strong>时间戳</strong>。当<code>AtomicStampedReference</code>对应的数值被修改时，除了更新数据本身外，还必须要更新时间戳，对象值和时间戳都必须满足期望值，写入才会成功。</p><blockquote><p>原理：乐观锁-版本号</p></blockquote><h4 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h4><p><strong>问题描述：</strong>CAS失败就会一直进行尝试。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p><p><strong>解决办法</strong>：JVM支持处理器提供的pause指令，使得效率会有一定的提升，pause指令有两个作用：</p><ul><li>第一它可以延迟流水线执行指令,使CPU不会消耗过多的执行资源，</li><li>第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</li></ul><h4 id="不能保证多个共享变量的原子操作"><a href="#不能保证多个共享变量的原子操作" class="headerlink" title="不能保证多个共享变量的原子操作"></a>不能保证多个共享变量的原子操作</h4><p><strong>问题描述</strong>：当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。</p><p><strong>解决办法</strong>：从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-整型数值对比</title>
      <link href="/2021/10/30/Java-%E6%95%B4%E5%9E%8B%E6%95%B0%E5%80%BC%E5%AF%B9%E6%AF%94/"/>
      <url>/2021/10/30/Java-%E6%95%B4%E5%9E%8B%E6%95%B0%E5%80%BC%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Java-整型数值对比"><a href="#Java-整型数值对比" class="headerlink" title="Java-整型数值对比"></a>Java-整型数值对比</h1><h2 id="题一"><a href="#题一" class="headerlink" title="题一:"></a>题一:</h2><p>有如下4条语句：()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i01=<span class="number">59</span>;</span><br><span class="line"><span class="keyword">int</span> i02=<span class="number">59</span>;</span><br><span class="line">Integer i03=Integer.valueOf(<span class="number">59</span>);</span><br><span class="line">Integer i04=<span class="keyword">new</span> Integer(<span class="number">59</span>);</span><br></pre></td></tr></table></figure><p>以下输出结果为false的是:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A. System.out.println(i01==i02);</span><br><span class="line">B. System.out.println(i01==i03);</span><br><span class="line">C. System.out.println(i03==i04);</span><br><span class="line">D. System.out.println(i02==i04);</span><br></pre></td></tr></table></figure><h3 id="答案：C"><a href="#答案：C" class="headerlink" title="答案：C"></a>答案：C</h3><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ol><li>无论如何，Integer与new Integer不会相等。不会经历拆箱过程，</li><li>两个都是非new出来的Integer，如果数在-128到127之间，则是true,否则为false<br>java在编译Integer i2 = 128的时候,被翻译成-&gt; Integer i2 = Integer.valueOf(128);而valueOf()函数会对-128到127之间的数进行缓存</li><li>两个都是new出来的,都为false</li><li>int和integer(无论new否)比，都为true，因为会把Integer自动拆箱为int再去比</li></ol><ul><li><strong>Integer valueOf(int i)：</strong>返回一个表示指定的 int 值的 Integer 实例。</li></ul><p>Byte,Short,Integer,Long,Character这5种整型的包装类也只是在对应值小于等于127并且大于等于-128时才可使用常量池，因为他们至占用一个字节(-128~127);</p><p>再者Integer.valueOf方法中也有判断，如果传递的整型变量&gt;= -128并且小于127时会返回IntegerCache类中一个静态数组中的某一个对象， 否则会返回一个新的Integer对象,代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">一些基本数据类型缓冲池的范围</span><br><span class="line"><span class="keyword">boolean</span> values <span class="keyword">true</span> and <span class="keyword">false</span></span><br><span class="line"><span class="keyword">short</span> values between -<span class="number">128</span> and <span class="number">127</span></span><br><span class="line"><span class="keyword">int</span> values between -<span class="number">128</span> and <span class="number">127</span></span><br><span class="line"><span class="keyword">char</span> in the range \u0000 to \u007F</span><br><span class="line">进入对应类源码查看对应XXXCache类的cache范围即可</span><br></pre></td></tr></table></figure><p>所以如果你测试如下代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        Integer a = <span class="number">127</span>;</span><br><span class="line">        Integer b = <span class="number">127</span>;</span><br><span class="line">         </span><br><span class="line">        Integer c = <span class="number">128</span>;</span><br><span class="line">        Integer d = <span class="number">128</span>;</span><br><span class="line">         </span><br><span class="line">        System.out.println(a == b);</span><br><span class="line">        System.out.println(c == d);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结合自动封装、常量池以及Integer.valueOf方法就不难得出，答案时true和false；</p><p>再看本题</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i01=<span class="number">59</span>;</span><br><span class="line"><span class="keyword">int</span> i02=<span class="number">59</span>;</span><br><span class="line">Integer i03=Integer.valueOf(<span class="number">59</span>);</span><br><span class="line">Integer i04=<span class="keyword">new</span> Integer(<span class="number">59</span>);</span><br></pre></td></tr></table></figure><p>第一行：由于59在-128~127范围之内，所以在自动装箱的时候，会返回IntegerCache[59 - (-128)];</p><p>第三行：同第一行</p><p>第四行：因为有new关键字，所以在heap中开辟了一块新内存放置值为59的Integer对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(i01==i02);<span class="comment">//正确</span></span><br><span class="line">System.out.println(i01==i03);<span class="comment">//正确，都指向IntegerCache[59-(-128)]对象</span></span><br><span class="line">System.out.println(i03==i04);<span class="comment">//错误，引用指向的对象地址不同</span></span><br><span class="line">System.out.println(i02==i04);<span class="comment">//正确</span></span><br></pre></td></tr></table></figure><h2 id="题二"><a href="#题二" class="headerlink" title="题二:"></a>题二:</h2><p>jdk1.5之后，下列 java 程序输出结果为______。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A: <span class="keyword">true</span>,<span class="keyword">false</span></span><br><span class="line">B: <span class="keyword">true</span>,<span class="keyword">true</span></span><br><span class="line">C: <span class="keyword">false</span>,<span class="keyword">true</span></span><br><span class="line">D: <span class="keyword">false</span>,<span class="keyword">false</span></span><br><span class="line">E: 对于不同的环境结果不同</span><br><span class="line">F: 程序无法执行</span><br></pre></td></tr></table></figure><h3 id="答案：B"><a href="#答案：B" class="headerlink" title="答案：B"></a>答案：B</h3><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><h3 id="①比较的是值"><a href="#①比较的是值" class="headerlink" title="①比较的是值"></a>①比较的是值</h3><h4 id="一、基本数据类型与引用数据类型进行比较时，引用数据类型会进行拆箱，然后与基本数据类型进行值的比较"><a href="#一、基本数据类型与引用数据类型进行比较时，引用数据类型会进行拆箱，然后与基本数据类型进行值的比较" class="headerlink" title="一、基本数据类型与引用数据类型进行比较时，引用数据类型会进行拆箱，然后与基本数据类型进行值的比较"></a>一、基本数据类型与引用数据类型进行比较时，引用数据类型会进行拆箱，然后与基本数据类型进行值的比较</h4><p>举例：<br>int i = 12;<br>Integer j = new Integer(12);<br>i == j 返回的是true</p><h4 id="二、引用数据类型与基本数据类型进行比较（equals方法），基本数据类型会进行自动装箱，与引用数据类型进行比较，Object中的equals方法比较的是地址，但是Integer类已经重写了equals方法，只要两个对象的值相同，则可视为同一对象，具体看API文档，所以这归根到底也是值的比较！"><a href="#二、引用数据类型与基本数据类型进行比较（equals方法），基本数据类型会进行自动装箱，与引用数据类型进行比较，Object中的equals方法比较的是地址，但是Integer类已经重写了equals方法，只要两个对象的值相同，则可视为同一对象，具体看API文档，所以这归根到底也是值的比较！" class="headerlink" title="二、引用数据类型与基本数据类型进行比较（equals方法），基本数据类型会进行自动装箱，与引用数据类型进行比较，Object中的equals方法比较的是地址，但是Integer类已经重写了equals方法，只要两个对象的值相同，则可视为同一对象，具体看API文档，所以这归根到底也是值的比较！"></a>二、引用数据类型与基本数据类型进行比较（equals方法），基本数据类型会进行自动装箱，与引用数据类型进行比较，Object中的equals方法比较的是地址，但是Integer类已经重写了equals方法，只要两个对象的值相同，则可视为同一对象，具体看API文档，所以这归根到底也是值的比较！</h4><p>举例：<br>int i = 12;<br>Integer j = new Integer(12);<br>j.equals(i) 返回的是true</p><h3 id="②比较的是地址"><a href="#②比较的是地址" class="headerlink" title="②比较的是地址"></a>②比较的是地址</h3><h4 id="一、如果引用数据类型是这样-Integer-i-12-直接从常量池取对象，这是如果数值是在-128与127之间，则视为同一对象，否则视为不同对象"><a href="#一、如果引用数据类型是这样-Integer-i-12-直接从常量池取对象，这是如果数值是在-128与127之间，则视为同一对象，否则视为不同对象" class="headerlink" title="一、如果引用数据类型是这样 Integer i = 12;直接从常量池取对象，这是如果数值是在-128与127之间，则视为同一对象，否则视为不同对象"></a>一、如果引用数据类型是这样 Integer i = 12;直接从常量池取对象，这是如果数值是在-128与127之间，则视为同一对象，否则视为不同对象</h4><p>举例：<br>Integer i = 12; Integer j = 12; i == j 返回的是true<br>Integer i = 128; Integer j = 128; i == j 返回的是false</p><h4 id="二、如果引用数据类型是直接new的话，不管值是否相同，这时两个对象都是不相同的，因为都会各自在堆内存中开辟一块空间"><a href="#二、如果引用数据类型是直接new的话，不管值是否相同，这时两个对象都是不相同的，因为都会各自在堆内存中开辟一块空间" class="headerlink" title="二、如果引用数据类型是直接new的话，不管值是否相同，这时两个对象都是不相同的，因为都会各自在堆内存中开辟一块空间"></a>二、如果引用数据类型是直接new的话，不管值是否相同，这时两个对象都是不相同的，因为都会各自在堆内存中开辟一块空间</h4><p>举例：<br>Integer i =new Integer(12);<br>Integer j = new Integer(12);<br>i == j 这时返回的是false<br>三、从常量池取对象跟new出来的对象也是不同的<br>举例：<br>Integer i = 12;<br>Integer j = new Integer(12)<br>i == j 这时返回的是false，因为第二个语句其实已经是new了两个对象了！！！</p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java·JVM·JUC(一)</title>
      <link href="/2021/10/30/Java%C2%B7JVM%C2%B7JUC(%E4%B8%80)/"/>
      <url>/2021/10/30/Java%C2%B7JVM%C2%B7JUC(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Java·JVM·JUC-一"><a href="#Java·JVM·JUC-一" class="headerlink" title="Java·JVM·JUC(一)"></a>Java·JVM·JUC(一)</h1><h2 id="Java-中垃圾回收机制中如何判断对象需要回收？常见的-GC-回收算法有哪些？"><a href="#Java-中垃圾回收机制中如何判断对象需要回收？常见的-GC-回收算法有哪些？" class="headerlink" title="Java 中垃圾回收机制中如何判断对象需要回收？常见的 GC 回收算法有哪些？"></a>Java 中垃圾回收机制中如何判断对象需要回收？常见的 GC 回收算法有哪些？</h2><h3 id="如何判断对象需要回收"><a href="#如何判断对象需要回收" class="headerlink" title="如何判断对象需要回收"></a>如何判断对象需要回收</h3><p>一般有两种方法来判断：</p><ul><li><strong>引用计数器法</strong>：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</li><li><strong>可达性分析算法</strong>：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</li></ul><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><ul><li>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</li></ul><p><img src="https://i.loli.net/2021/10/26/7yxgmv3YnMkqCa4.png" alt="image-20211026154904653"></p><ul><li>复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</li></ul><p><img src="https://i.loli.net/2021/10/26/Nr8SpaUs6Bm5woM.png" alt="image-20211026154857764"></p><ul><li>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</li></ul><p><img src="https://i.loli.net/2021/10/30/WiR7Tx4sboPQDMa.png" alt="image-20211026154839186"></p><ul><li>分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</li></ul><p><img src="https://i.loli.net/2021/10/26/ZtiwMGqsPa3lTSD.png" alt="image-20211026154831011"></p><h2 id="HashMap-与-ConcurrentHashMap-的实现原理是怎样的？ConcurrentHashMap-是如何保证线程安全的？"><a href="#HashMap-与-ConcurrentHashMap-的实现原理是怎样的？ConcurrentHashMap-是如何保证线程安全的？" class="headerlink" title="HashMap 与 ConcurrentHashMap 的实现原理是怎样的？ConcurrentHashMap 是如何保证线程安全的？"></a>HashMap 与 ConcurrentHashMap 的实现原理是怎样的？ConcurrentHashMap 是如何保证线程安全的？</h2><ol><li>HashMap不支持并发操作，没有同步方法，ConcurrentHashMap支持并发操作，通过继承 ReentrantLock（JDK1.7重入锁）/CAS和synchronized(JDK1.8内置锁)来进行加锁（分段锁），每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</li><li>JDK1.8之前HashMap的结构为数组+链表，JDK1.8之后HashMap的结构为数组+链表+红黑树；JDK1.8之前ConcurrentHashMap的结构为segment数组+数组+链表，JDK1.8之后ConcurrentHashMap的结构为数组+链表+红黑树。</li></ol><p>如下一些方式可以获得线程安全的HashMap：</p><ul><li>Collections.synchronizedMap</li><li>HashTable</li><li>ConcurrentHashMap</li></ul><h2 id="Synchronized-关键字底层是如何实现的？它与-Lock-相比优缺点分别是什么？"><a href="#Synchronized-关键字底层是如何实现的？它与-Lock-相比优缺点分别是什么？" class="headerlink" title="Synchronized 关键字底层是如何实现的？它与 Lock 相比优缺点分别是什么？"></a>Synchronized 关键字底层是如何实现的？它与 Lock 相比优缺点分别是什么？</h2><p>Synchronized关键字<strong>底层是使用monitor对象锁实现的</strong>，每一个对象关联一个monitor对象，而monitor对象可以看成是一个对象锁，它采用互斥的方式让同一时刻至多只有一个线程能持有对象锁，其他线程再想获取这个对 象锁时会被阻塞住，这样就能保证拥有锁的线程可以安全的执行临界区的代码。</p><p>Lock是一个接口，而synchronized是Java中的关键字，是内置的语言实现；Synchronized既可以加在方法上，也可以加在特定的代码块上，而Lock需要显示地指定起始位置和终止位置。</p><h3 id="Synchronized相比于Lock，它的优点是："><a href="#Synchronized相比于Lock，它的优点是：" class="headerlink" title="Synchronized相比于Lock，它的优点是："></a>Synchronized相比于Lock，它的优点是：</h3><p>Synchronized不需要用户手动去释放锁，当synchronized方法或者代码块执行完毕后，系统会自动让线程释放锁的占用，无论中途是否遇到异常都能自动释放；而Lock需要用户手动去释放，一般写在finally块中避免执行中途遇到异常无法正常释放锁。</p><p>缺点是：</p><ul><li><p>Lock可以被中断或设置超时等待，可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待锁的线程会一直等下去，不能响应中断。</p></li><li><p>Lock可以设置公平锁，而synchronized只能是非公平实现(公平锁通过在锁竞争前判断自己是否是头节点来实现)。</p></li><li><p>Lock可以支持多个条件变量(Condition)，而synchronized只支持一个条件变量，所有的等待都在同一个waitset中。</p></li></ul><h2 id="JMM-中内存模型是怎样的？什么是指令序列重排序？"><a href="#JMM-中内存模型是怎样的？什么是指令序列重排序？" class="headerlink" title="JMM 中内存模型是怎样的？什么是指令序列重排序？"></a>JMM 中内存模型是怎样的？什么是指令序列重排序？</h2><p>Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</p><p><img src="https://i.loli.net/2021/10/26/7YQpVa9behBRUDL.png" alt="image-20211026232307826"></p><p>各部分的特点和作用如下：</p><p><img src="https://i.loli.net/2021/10/26/TJXBxrSsi38IqFh.png" alt="image-20211026232330804"></p><h3 id="什么是重排序"><a href="#什么是重排序" class="headerlink" title="什么是重排序"></a>什么是重排序</h3><ul><li>假设我们写了一个 Java 程序，包含一系列的语句，我们会默认期望这些语句的实际运行顺序和写的代码顺序一致。</li><li>但实际上，编译器、JVM 或者 CPU 都有可能出于优化等目的，对于实际指令执行的顺序进行调整，这就是重排序。</li></ul><p><img src="https://i.loli.net/2021/10/30/K7ToZctWJSers9V.png" alt="image-20211030131544832"></p><h2 id="简述-ArrayList-与-LinkedList-的底层实现以及常见操作的时间复杂度"><a href="#简述-ArrayList-与-LinkedList-的底层实现以及常见操作的时间复杂度" class="headerlink" title="简述 ArrayList 与 LinkedList 的底层实现以及常见操作的时间复杂度"></a>简述 ArrayList 与 LinkedList 的底层实现以及常见操作的时间复杂度</h2><ul><li><p><strong>数据结构实现</strong>：ArrayList 是<strong>动态数组</strong>的数据结构实现，而 LinkedList 是<strong>双向链表</strong>的数据结构实现。</p></li><li><p><strong>随机访问效率</strong>：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</p></li><li><p><strong>增加和删除效率</strong>：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</p></li><li><p><strong>内存空间占用</strong>：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</p></li><li><p><strong>线程安全</strong>：ArrayList 和 LinkedList 都是不同步的，也就是<strong>不保证线程安全</strong>；</p></li></ul><h2 id="简述-BIO-NIO-AIO-的区别"><a href="#简述-BIO-NIO-AIO-的区别" class="headerlink" title="简述 BIO, NIO, AIO 的区别"></a>简述 BIO, NIO, AIO 的区别</h2><p><strong>BIO</strong>：线程发起IO请求，不管内核是否准备好IO操作，从发起请求起，线程一直阻塞，直到操作完成。</p><ul><li>同步并阻塞，服务器实现模式为<strong>一个连接一个线程</strong>，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</li></ul><p><strong>NIO</strong>：线程发起IO请求，立即返回；内核在做好IO操作的准备之后，通过调用注册的回调函数通知线程做IO操作，线程开始阻塞，直到操作完成。</p><ul><li>同步非阻塞，服务器实现模式为<strong>一个请求一个线程</strong>，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。</li></ul><p><strong>AIO</strong>：线程发起IO请求，立即返回；内存做好IO操作的准备之后，做IO操作，直到操作完成或者失败，通过调用注册的回调函数通知线程做IO操作完成或者失败。</p><ul><li>异步非阻塞，服务器实现模式为<strong>一个有效请求一个线程</strong>，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。<br>适用场景分析</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</li><li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</li><li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</li></ul><h2 id="Java-类的加载流程是怎样的？什么是双亲委派机制？"><a href="#Java-类的加载流程是怎样的？什么是双亲委派机制？" class="headerlink" title="Java 类的加载流程是怎样的？什么是双亲委派机制？"></a>Java 类的加载流程是怎样的？什么是双亲委派机制？</h2><h3 id="类的加载流程"><a href="#类的加载流程" class="headerlink" title="类的加载流程"></a>类的加载流程</h3><p>虚拟机把描述类的数据从Class文件<strong>加载</strong>到内存，并对数据进行<strong>校验</strong>，<strong>解析</strong>和<strong>初始化</strong>，最终形成可以被虚拟机直接使用的java类型。</p><h3 id="类的加载原理"><a href="#类的加载原理" class="headerlink" title="类的加载原理"></a>类的加载原理</h3><p>在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。</p><p>类装载方式，有两种 ：</p><ol><li><p>隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中，</p></li><li><p>显式装载， 通过class.forname()等方法，显式加载需要的类</p></li></ol><p>Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。</p><h3 id="双亲委派模型？"><a href="#双亲委派模型？" class="headerlink" title="双亲委派模型？"></a>双亲委派模型？</h3><p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p><p><img src="https://i.loli.net/2021/10/30/4urHVPsEmNnhyFZ.png" alt="image-20211030133559926"></p><p>类加载器分类：</p><ul><li>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；</li><li>其他类加载器：</li><li>扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</li><li>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</li></ul><p><strong>双亲委派模型</strong>：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p><blockquote><p>当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。</p></blockquote><h2 id="volatile-关键字解决了什么问题，它的实现原理是什么？"><a href="#volatile-关键字解决了什么问题，它的实现原理是什么？" class="headerlink" title="volatile 关键字解决了什么问题，它的实现原理是什么？"></a>volatile 关键字解决了什么问题，它的实现原理是什么？</h2><p>Java提供了volatile关键字来保证<strong>可见性、有序性。但不保证原子性</strong>。</p><p>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p><p>2）禁止进行指令重排序。 </p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>第一：使用volatile关键字会<strong>强制将修改的值立即写入主存</strong>；</p><p>第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量的<strong>缓存行无效</strong>（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p><p>第三：由于线程1的工作内存中缓存变量的缓存行无效，所以线程1再次读取变量的值时会去主存读取。</p><h2 id="简述-Synchronized，Volatile，可重入锁的不同使用场景及优缺点"><a href="#简述-Synchronized，Volatile，可重入锁的不同使用场景及优缺点" class="headerlink" title="简述 Synchronized，Volatile，可重入锁的不同使用场景及优缺点"></a>简述 Synchronized，Volatile，可重入锁的不同使用场景及优缺点</h2><h3 id="synchronized的三种应用方式"><a href="#synchronized的三种应用方式" class="headerlink" title="synchronized的三种应用方式"></a>synchronized的三种应用方式</h3><ul><li>修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁：修饰在普通实例方法前，当多个线程操作1个实例可以实现线程安全。但多个线程操作多个实例对象，导致锁不同，无法实现线程安全。锁的是整个实例，当被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法</li><li>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁：修饰在静态方法前，锁的是当前类的Class对象，通过class对象锁可以控制静态成员的并发操作。</li><li>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li></ul><h3 id="synchronized和ReentrantLock-的区别"><a href="#synchronized和ReentrantLock-的区别" class="headerlink" title="synchronized和ReentrantLock 的区别"></a>synchronized和ReentrantLock 的区别</h3><p>二者均是可重入锁</p><ul><li>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</li><li>synchronized均是由JVM虚拟机在字节码底层实现的，而ReentrantLock是可以在代码中通过接口API调用各种方法，灵活性和可操作性更强。</li><li>ReentrantLock 比 synchronized 增加了一些高级功能：</li><li>通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情</li><li>ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁</li><li>synchronized关键字与wait()和notify()/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程</li></ul><h3 id="synchronized-关键字和-volatile-关键字的区别"><a href="#synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="synchronized 关键字和 volatile 关键字的区别"></a>synchronized 关键字和 volatile 关键字的区别</h3><ul><li>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。</li><li>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞</li><li>volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。</li><li>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。</li></ul><p>题目答案均为转载，题目先后顺序按各大厂总出题次数排列！</p>]]></content>
      
      
      <categories>
          
          <category> 面试技巧 </category>
          
          <category> Java·JVM·JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java·JVM·JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议(四)</title>
      <link href="/2021/10/26/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE(%E5%9B%9B)/"/>
      <url>/2021/10/26/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE(%E5%9B%9B)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="网络协议-四"><a href="#网络协议-四" class="headerlink" title="网络协议(四)"></a>网络协议(四)</h1><h2 id="简述-HTTP-的-keepalive-的原理和使用场景"><a href="#简述-HTTP-的-keepalive-的原理和使用场景" class="headerlink" title="简述 HTTP 的 keepalive 的原理和使用场景"></a>简述 HTTP 的 keepalive 的原理和使用场景</h2><p>当使用 Keep-Alive 模式时，Keep-Alive 功能使客户端到服务器端的连接持续有效。</p><ol><li>HTTP1.0 KeepAlive支持的数据交互流程如下：</li></ol><blockquote><p>a)Client发出request，其中该request的HTTP版本号为1.0。同时在request中包含一个header：”Connection： keep-alive”。</p><p>b)Web Server收到request中的HTTP协议为1.0及”Connection： keep-alive”就认为是一个长连接请求，其将在response的header中也增加”Connection： keep-alive”。同时不会关闭已建立的tcp连接。</p><p>c)Client收到Web Server的response中包含”Connection： keep-alive”，就认为是一个长连接，不close tcp连接。并用该tcp连接再发送request。（跳转到a)）</p></blockquote><ol start="2"><li>HTTP1.1 KeepAlive支持的数据交互流程如下：</li></ol><blockquote><p>a)Client发出request，其中该request的HTTP版本号为1.1。</p><p>b)Web Server收到request中的HTTP协议为1.1就认为是一个长连接请求，其将在response的header中也增加”Connection： keep-alive”。同时不会关闭已建立的tcp连接。</p><p>c)Client收到Web Server的response中包含”Connection： keep-alive”，就认为是一个长连接，不close tcp连接。并用该tcp连接再发送request。（跳转到a)）</p></blockquote><h2 id="简述在四层和七层网络协议中负载均衡的原理"><a href="#简述在四层和七层网络协议中负载均衡的原理" class="headerlink" title="简述在四层和七层网络协议中负载均衡的原理"></a>简述在四层和七层网络协议中负载均衡的原理</h2><p><strong>二层负载</strong>均衡会通过一个虚拟 MAC 地址接收请求，然后再分配到真实的 MAC 地址；</p><p><strong>三层负载</strong>均衡会通过一个虚拟 IP 地址接收请求，然后再分配到真实的 IP 地址；</p><p><strong>四层</strong>通过虚拟 IP + 端口接收请求，然后再分配到真实的服务器；</p><p><strong>七层</strong>通过虚拟的 URL 或主机名接收请求，然后再分配到真实的服务器。</p><p>所谓的四到七层负载均衡，就是在对后台的服务器进行负载均衡时，依据四层的信息或七层的信息来决定怎么样转发流量。</p><p>比如四层的负载均衡，就是通过发布三层的 IP 地址（VIP），然后加四层的端口号，来决定哪些流量需要做负载均衡， 对需要处理的流量进行 NAT 处理，转发至后台服务器，并记录下这个 TCP 或者 UDP 的流量是由哪台服务器处理的， 后续这个连接的所有流量都同样转发到同一台服务器处理。</p><p>七层的负载均衡，就是在四层的基础上（没有四层是绝对不可能有七层的），再考虑应用层的特征， 比如同一个 Web 服务器的负载均衡，除了根据 VIP 加 80 端口辨别是否需要处理的流量， 还可根据七层的 URL、浏览器类别、语言来决定是否要进行负载均衡。</p><h2 id="简述-TCP-半连接发生场景"><a href="#简述-TCP-半连接发生场景" class="headerlink" title="简述 TCP 半连接发生场景"></a>简述 TCP 半连接发生场景</h2><blockquote><p>发生在TCP三次握手中<br>如果A向B发起链接，B也按照正常情况响应了，但是A不进行三次握手，这就是半连接。<br><strong>半连接攻击：</strong>半连接，会造成B分配的内存资源就一直这么耗着，直到资源耗尽。（SYN攻击）</p></blockquote><h2 id="什么是-SYN-flood，如何防止这类攻击？"><a href="#什么是-SYN-flood，如何防止这类攻击？" class="headerlink" title="什么是 SYN flood，如何防止这类攻击？"></a>什么是 SYN flood，如何防止这类攻击？</h2><p>SYN Flood顾名思义就是用洪水一样的SYN报文进行攻击。</p><p>在连接超时之前，服务器会一直等待ACK报文，此时该连接状态为半开放连接（也被称为半连接）。半连接会占用服务器的连接数，当连接数被占满时，服务器就无法提供正常的服务了。</p><ol><li>TCP首包丢弃:<br>该算法利用了TCP/IP协议的重传特性，来自某个源IP的第一个syn包到达时被直接丢弃并记录状态(五元组)，在该源IP的第2个syn包到达时进行验证，然后放行。</li></ol><p>当防御设备接到一个IP地址的SYN报文后:</p><ul><li>接受到syn报文      -&gt; 简单比对该IP是否存在于白名单中:   存在则转发到后端，否则进行第2步</li><li>不存在于白名单中 -&gt; 检查是否是该IP在一定时间段内的首次SYN报文： 不是则进行第3步，是则进行第5步</li><li>不是首次SYN报文 -&gt; 检查是否重传报文： 是重传则转发并加入白名单，不是则丢弃并加入黑名单</li><li>是首次SYN报文    -&gt;  丢弃并等待一段时间以试图接受该IP的SYN重传报文，等待超时则判定为攻击报文加入黑名单。</li></ul><ol start="2"><li>cookie源认证<br>原理是syn报文首先由DDOS防护系统来响应syn_ack。带上特定的sequence number （记为cookie）。真实的客户端会返回一个ack 并且Acknowledgment number 为cookie+1。 而伪造的客户端，将不会作出响应。这样我们就可以知道那些IP对应的客户端是真实的，将真实客户端IP加入白名单。下次访问直接通过，而其他伪造的syn报文就被拦截。</li></ol><h2 id="简述-HTTP-报文头部的组成结构"><a href="#简述-HTTP-报文头部的组成结构" class="headerlink" title="简述 HTTP 报文头部的组成结构"></a>简述 HTTP 报文头部的组成结构</h2><p><strong>1、开始行</strong><br>在请求报文称为请求行，在响应报文称为状态行。<br><strong>2、首部行</strong><br>用来说明浏览器、服务器、或报文主体的一些信息。<br><strong>3、实体主体</strong><br>请求报文一般不会有这个字段，而响应报文一般有，但也可以没有。</p><p><img src="https://i.loli.net/2021/10/25/mGz5WCKqVQvatTo.png" alt="image-20211025103309930"></p><h2 id="为什么需要序列化？有什么序列化的方式？"><a href="#为什么需要序列化？有什么序列化的方式？" class="headerlink" title="为什么需要序列化？有什么序列化的方式？"></a>为什么需要序列化？有什么序列化的方式？</h2><p><strong>对象的序列化是指通过某种方法把对象以字节序列的形式保存起来。反之通过字节序列得到原对象就是反序列化</strong>。</p><ol><li>描述数据的传输格式，这样可以方便自己组织数据传输格式，以至于避免一些麻烦及错误</li><li>如果是跨平台的序列化，则发送方序列化后，接收方可以用任何其支持的平台反序列化成相应的版本，比如 Java序列化后</li></ol><h3 id="序列化的方式"><a href="#序列化的方式" class="headerlink" title="序列化的方式"></a>序列化的方式</h3><p>Java原生序列化:只要对象实现了Serializable接口，该对象就可以进行序列化</p><ol><li><strong>Java原生序列化方式</strong>，主要由ObjectInputStream和ObjectOutputStream实现，他们可以直接装饰文件I/O（RandomAccessFile）或者网络I/O（Socket），来实现将<a href="https://cloud.tencent.com/product/cos?from=10680">对象存储</a>到文件或者在网络中传输。不过，还有几点需要注意：</li></ol><ul><li>序列化对象需实现<strong>Serialization</strong>接口</li><li>static属性不能被序列化，序列化保存对象的状态，static属于类状态</li><li>transient修饰的不能被序列化</li><li>版本号serialVersionUID<ul><li>版本号一致，新增字段不影响反序列化对象</li><li>版本号不一致，影响反序列化对象，将报错</li></ul></li></ul><ol start="2"><li><p><strong>JSON</strong>是一种轻量级的数据交换格式。如<a href="https://cloud.tencent.com/product/crs?from=10680">Redis</a>存储对象时，使用JSON格式，使数据支持跨平台、可读性也更强。</p></li><li><p><strong>XML</strong>是一种很常见的数据保存方式。SOAP是基于XML为序列化和反序列化协议的结构化消息传递协议。</p></li><li><p><strong>Kryo</strong>是一个快速有效的Java二进制对象图序列化框架。主要有序列化反序列化更高效、序列化之后字节数据更小、更易用等特点。</p></li></ol><h2 id="TCP-如何实现数据有序性？"><a href="#TCP-如何实现数据有序性？" class="headerlink" title="TCP 如何实现数据有序性？"></a>TCP 如何实现数据有序性？</h2><ol><li><p>主机每次发送数据时，TCP就给每个数据包分配一个序列号并且在一个特定的时间内等待接收主机对分配的这个序列号进行确认</p></li><li><p>如果发送主机在一个特定时间内没有收到接收主机的确认，则发送主机会重传此数据包。</p></li><li><p>接收主机利用序列号对接收的数据进行确认，以便检测对方发送的数据是否有丢失或者乱序等</p></li><li><p>接收主机一旦收到已经顺序化的数据，它就将这些数据按正确的顺序重组成数据流并传递到高层进行处理。</p></li></ol><h2 id="简述-HTTP-短链接与长链接的区别"><a href="#简述-HTTP-短链接与长链接的区别" class="headerlink" title="简述 HTTP 短链接与长链接的区别"></a>简述 HTTP 短链接与长链接的区别</h2><p><strong>短连接</strong></p><blockquote><p>连接-&gt;传输数据-&gt;关闭连接<br>比如HTTP是无状态的的短链接，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。<br>因为连接后接收了数据就断开了，所以每次数据接受处理不会有联系。 这也是HTTP协议无状态的原因之一。</p></blockquote><p><strong>长连接</strong></p><blockquote><p>连接-&gt;传输数据-&gt;保持连接 -&gt; 传输数据-&gt; ………..-&gt;直到一方关闭连接，多是客户端关闭连接。<br>长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。</p></blockquote><p><strong>什么时候用长连接，短连接？</strong></p><blockquote><p>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，<br>这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都<br>不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果<br>用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。</p><p>而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网<br>站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成<br>千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频<br>繁操作情况下需用短连好。</p></blockquote><h2 id="简述-iPv4-和-iPv6-的区别"><a href="#简述-iPv4-和-iPv6-的区别" class="headerlink" title="简述 iPv4 和 iPv6 的区别"></a>简述 iPv4 和 iPv6 的区别</h2><p><strong>1.地址类型。</strong>IPv4具有三种不同类型的地址：多播，广播和单播。IPv6还具有三种不同类型的地址：任意广播，单播和多播。</p><p><strong>2.数据包大小。</strong>对于IPv4，最小数据包大小为576字节。对于IPv6，最小数据包大小为1208字节。</p><p><strong>3.header区域字段数。</strong>IPv4具有12个标头字段，而IPv6支持8个标头字段。</p><p><strong>4.可选字段。</strong>IPv4具有可选字段，而IPv6没有。但是，IPv6具有扩展header，可以在将来扩展协议而不会影响主包结构。</p><p><strong>5.配置。</strong>在IPv4中，新装的系统必须配置好才能与其他系统通信。在IPv6中，配置是可选的，它允许根据所需功能进行选择。</p><p><strong>6.安全性。</strong>在IPv4中，安全性主要取决于网站和应用程序。它不是针对安全性而开发的IP协议。而IPv6集成了Internet协议安全标准（IPSec）。IPv6的网络安全不像IPv4是可选项，IPv6里的网络安全项是强制性的。</p><p><strong>7.与移动设备的兼容性。</strong>IPv4不适合移动网络，因为正如我们前面提到的，它使用点分十进制表示法，而IPv6使用冒号，是移动设备的更好选择。</p><p><strong>8.主要功能。</strong>IPv6允许直接寻址，因为存在大量可能的地址。但是，IPv4已经广泛传播并得到许多设备的支持，这使其更易于使用。</p><p>题目答案均为转载，题目先后顺序按各大厂总出题次数排列！</p>]]></content>
      
      
      <categories>
          
          <category> 面试技巧 </category>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议(三)</title>
      <link href="/2021/10/24/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE(%E4%B8%89)/"/>
      <url>/2021/10/24/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE(%E4%B8%89)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="网络协议-三"><a href="#网络协议-三" class="headerlink" title="网络协议(三)"></a>网络协议(三)</h1><h2 id="从系统层面上，UDP-如何保证尽量可靠？"><a href="#从系统层面上，UDP-如何保证尽量可靠？" class="headerlink" title="从系统层面上，UDP 如何保证尽量可靠？"></a>从系统层面上，UDP 如何保证尽量可靠？</h2><p>  传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。</p><ul><li>实现确认机制、重传机制、窗口确认机制。</li><li>如果你不利用linux协议栈以及上层socket机制，自己通过抓包和发包的方式去实现可靠性传输，那么必须实现如下功能：</li><li>发送：包的分片、包确认、包的重发</li><li>接收：包的调序、包的序号确认</li><li>目前有如下开源程序利用udp实现了可靠的数据传输。分别为RUDP、RTP、UDT。</li></ul><h2 id="简述-JWT-的原理和校验机制"><a href="#简述-JWT-的原理和校验机制" class="headerlink" title="简述 JWT 的原理和校验机制"></a>简述 JWT 的原理和校验机制</h2><p>JWT： JSON Web token 用于json对象在各方之间安全的传输信息，它是安全可被信任的，因为它是数字签名的。JWT是目前最流行的跨域身份验证解决方案</p><p>JWT工作原理：</p><ol><li>应用或客户端向授权服务器请求授权</li><li>当授权被许可后，授权服务器返回一个access token给应用</li><li>客户端存储token，并且在随后的每一次请求中都带着它</li><li>服务器校验token并返回数据</li></ol><h2 id="HTTP-的方法有哪些？"><a href="#HTTP-的方法有哪些？" class="headerlink" title="HTTP 的方法有哪些？"></a>HTTP 的方法有哪些？</h2><ol><li><p>GET方法：获取资源</p></li><li><p>POST方法：传输实体主题</p></li><li><p>PUT方法：传输文件</p></li><li><p>HEAD方法：获取报文首部</p></li><li><p>DELETE方法：删除文件</p></li><li><p>OPTIONS方法：询问支持的方法</p></li></ol><h2 id="TCP-长连接和短连接有那么不同的使用场景？"><a href="#TCP-长连接和短连接有那么不同的使用场景？" class="headerlink" title="TCP 长连接和短连接有那么不同的使用场景？"></a>TCP 长连接和短连接有那么不同的使用场景？</h2><p>数据库的连接用<strong>长连接</strong>， 如果用短连接频繁的通信会造成 socket 错误，而且频繁的 socket创建也是对资源的浪费。网络游戏应用都是长连接</p><p>WEB 网站的 http 服务一般都用<strong>短链接</strong></p><h2 id="什么是-ARP-协议？简述其使用场景"><a href="#什么是-ARP-协议？简述其使用场景" class="headerlink" title="什么是 ARP 协议？简述其使用场景"></a>什么是 ARP 协议？简述其使用场景</h2><p>地址解析协议 <strong>ARP</strong>:知道IP地址请求硬件地址(MAC）</p><p>反向地址转换协议 <strong>RARP</strong>：将局域网中某个主机的物理地址转换为IP地址</p><h3 id="ARP使用场景"><a href="#ARP使用场景" class="headerlink" title="ARP使用场景"></a>ARP使用场景</h3><p>1、发送方是主机H1，要把IP数据报发送到另一个网络上的另一个主机H2.这时H1发送ARP请求分组（在网1上广播），找到目的主句H2的硬件地址；<br>2、发送方是主机H1，要把IP数据报发送到另一个网络上的另一个主机H2.这时H1发送ARP请求分组（在网1上广播），找到网1的一个路由器R1，剩下的工作由路由器R1来完成；<br>3、发送方是路由器R1，要把IP数据报发送到R1连接在同一个网络（网2 ）上的主机H3。这时R1发送ARP请求分组（在网2上广播），找到目的主机H3的硬件地址；<br>4、发送方是路由器R1，要把IP数据报发送到网3上的一个主机H4。这时R1发送ARP请求分组（在网2上广播），找到连接在网2上的一个路由器R2的硬件地址，剩下的工作由路由器R2来完成。<br>反向地址转换协议RARP：将局域网中某个主机的物理地址转换为IP地址</p><h2 id="简述-RPC-的调用过程"><a href="#简述-RPC-的调用过程" class="headerlink" title="简述 RPC 的调用过程"></a>简述 RPC 的调用过程</h2><p><img src="https://i.loli.net/2021/10/24/4AhtEZu8kdYRF2y.png" alt="image-20211024114038289"></p><ol><li><p>调用者（客户端Client）以本地调用的方式发起调用；</p></li><li><p>Client stub（客户端存根）收到调用后，负责将被调用的方法名、参数等打包编码成特定格式的能进行网络传输的消息体；</p></li><li><p>Client stub将消息体通过网络发送给服务端；</p></li><li><p>Server stub（服务端存根）收到通过网络接收到消息后按照相应格式进行拆包解码，获取方法名和参数；</p></li><li><p>Server stub根据方法名和参数进行本地调用；</p></li><li><p>被调用者（Server）本地调用执行后将结果返回给server stub；</p></li><li><p>Server stub将返回值打包编码成消息，并通过网络发送给客户端；</p></li><li><p>Client stub收到消息后，进行拆包解码，返回给Client；</p></li><li><p>Client得到本次RPC调用的最终结果。</p></li></ol><h2 id="TCP-中-SYN-攻击是什么？如何防止？"><a href="#TCP-中-SYN-攻击是什么？如何防止？" class="headerlink" title="TCP 中 SYN 攻击是什么？如何防止？"></a>TCP 中 SYN 攻击是什么？如何防止？</h2><p>SYN攻击属于<strong>DoS</strong>攻击的一种，它利用<strong>TCP协议</strong>缺陷，通过发送大量的<strong>半连接</strong>请求，耗费<strong>CPU</strong>和内存资源。</p><p>SYN攻击通过故意不完成建立连接所需要的三次握手过程，造成连接一方的资源耗尽。</p><p>造成TCP连接的资源消耗，其中包括：数据包信息、条件状态、序列号等。</p><h3 id="如何防止SYN-攻击"><a href="#如何防止SYN-攻击" class="headerlink" title="如何防止SYN 攻击"></a>如何防止SYN 攻击</h3><p>1、具有SYN proxy（SYN代理）功能的防火墙</p><p>   每秒通过指定对象（目标地址和端口、仅目标地址或仅源地址）的SYN片段数的阀值，当来自相同源地址或发往相同目标地址的SYN片段数达到一定阀值时，防火墙开始截断连接请求和代理回复SYN/ACK片段，当防火墙代理半连接的队列被填满，防火墙拒绝来自相安全同区域所有地址的新SYN片段。<br>  缺点：当攻流量较大时，连接出现较大延迟，网络负载高，很多时候成为整个网络瓶颈    </p><p>2、加快淘汰无效SYN请求，通过降低tcp_syn_retries实现；加大队列长度，长度和tcp_max_syn_backing相关，但不完全由它决定。</p><p>  缺点：在高强度攻击面前这两个不能根本解决问题，更有效的是tcp_syncookies。</p><p>3、SYN Cookie，给每一个请求连接的IP地址分配一个Cookie，若短时间内收到某个连续的SYN报文，就认定受到攻击，再来就丢弃。</p><p>  原理：服务器收到SYN报文，返回SYN+ACK包时，不分配一个专门的数据区，而是根据这个SYN包计算出一个cookie值，在收到TCP_ACK时，服务器对比cookie对比检查合法性，再分配专门的数据区处理连接。</p><h2 id="简述-TCP-的报文头部结构"><a href="#简述-TCP-的报文头部结构" class="headerlink" title="简述 TCP 的报文头部结构"></a>简述 TCP 的报文头部结构</h2><p><img src="https://i.loli.net/2021/10/24/NEZvBaW7KPLbCFm.png" alt="image-20211024115019173"></p><h2 id="TCP的拥塞控制具体是怎么实现的？UDP有拥塞控制吗？"><a href="#TCP的拥塞控制具体是怎么实现的？UDP有拥塞控制吗？" class="headerlink" title="TCP的拥塞控制具体是怎么实现的？UDP有拥塞控制吗？"></a>TCP的拥塞控制具体是怎么实现的？UDP有拥塞控制吗？</h2><p>拥塞控制：TCP模块为了防止过多的数据注入网络，使网络中的路由器或链路不致于过载。以此提高网络利用率，降低丢包率，并抱证网络资源对每条数据流的公平性而采取的控制手段。拥塞控制包含四部分内容：慢启动、拥塞避免、快速重传、快速恢复。</p><ul><li>慢启动：  网络传输刚开始时，并不知道网络的实际情况，所以采取一种试探的方式控制数据的发送速率。慢启动阶段，数据的发送速率以指数方式增长，即就是拥塞窗口的增长，每次都是收到确认报文段数量的2倍。可以看出慢启动并不慢，拥塞窗口增长的速度很快。所以，为其设置了一个慢启动门限，当达到门限时，就进入到拥塞避免阶段。</li><li>拥塞避免： 当拥塞窗口的大小采用慢启动方式增长到慢启动门限时，就进入拥塞避免阶段，拥塞避免阶段不再以指数形式增长拥塞窗口，而是每经过一个往返时间RTT就将发送方的拥塞窗口+1， 使其增长速度减缓。按照线性方式增长。如果发生网络拥塞，比如丢包时，就将慢启动门限设为原来的一半，然后将拥塞窗口设置为1，开始执行慢启动算法。（较低的起点，指数级增长）。</li><li>快速重传： 假设发送方发送的报文段分别为： M1,M2,M3,M4,M5,M6 , 当接收方收到M1和M2后，M3报文段丢失，接着收到的M4，M5，M6都不做处理，而是没接收到一个报文段就对M2重复确认，发送方接收到重复的三次确认报文段，就对其后的报文段进行重新发送，而不需要等待超时时间到达。当快速重传后，立即进入到快速恢复阶段。</li><li>快速恢复：将慢启动门限设置为原来的一半，然后将拥塞窗口设置为现在的慢启动门限值，不再执行慢启动算法，而是直接进入拥塞避免阶段。使发送窗口成线性方式增大。</li></ul><p><img src="https://i.loli.net/2021/10/24/Wrl7I2XvadHoghD.png" alt="image-20211024115427867"></p><ul><li>流量控制（滑动窗口协议）TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。【滑动窗口技术存在于数据链路层和传输层。两者有不同的协议，但基本原理相同。区别是一个是发送帧，一个是发送字节数据。接收方的接受窗口告诉发送方本端tcp接受缓冲区还能容纳多少字节，发送方的发送窗口就可以控制发送数据的速度。】</li></ul><p>UDP没有流量控制和拥塞控制，所以在网络拥塞时不会是源主机发送速率降低（对实时通信很有用，比如QQ电话，视频会议等）</p><h2 id="什么是中间人攻击？如何防止攻击？"><a href="#什么是中间人攻击？如何防止攻击？" class="headerlink" title="什么是中间人攻击？如何防止攻击？"></a>什么是中间人攻击？如何防止攻击？</h2><h3 id="MITM-中间人攻击"><a href="#MITM-中间人攻击" class="headerlink" title="MITM 中间人攻击"></a>MITM 中间人攻击</h3><p>攻击者可以将自己植入到彼此正在通信的两方之间，开展窃听、甚至是攻击活动。</p><p><strong>离线中间人攻击</strong>:某中间人成功截获了您发送的消息，对其进行了读取和重新打包操作，然后将新的内容发回给您、或原始收件人。而当此人在不知情的情况下回复时，该中间人便可继续截获并阅读原本通信双方互发的信息。由于双方并非面对面通信，因此信息即使被截获和窃取，他们都不得而知。</p><p><strong>在线中间人攻击</strong>:您用笔记本电脑连接上了某个咖啡馆的免费公共Wi-Fi，并试图访问某个银行的网站。</p><h3 id="防止中间人攻击"><a href="#防止中间人攻击" class="headerlink" title="防止中间人攻击"></a>防止中间人攻击</h3><ul><li><p>使用HTTPS：确保您只访问那些使用着HTTPS的网站。如前所述，HTTPS提供了额外的安全保护层。在此，您可以考虑下载并安装Electronic Frontier Foundation的HTTPS Everywhere浏览器扩展程序。它是Google Chrome浏览器最好的隐私扩展程序之一。</p></li><li><p>不要忽略警告：如果您的浏览器提示，您正在访问的网站存在着安全问题，那么就请引起足够的重视。毕竟安全证书警告可以帮您直观地判定，您的登录凭据是否会被攻击者截获。</p></li><li><p>不要使用公共Wi-Fi：如果您无法避免使用公共Wi-Fi，那么请下载并安装安全防护，为连接增加安全性。同时，在使用公共Wi-Fi连接时，请留意浏览器的安全警告。如果警告的数量突然猛增，那么很可能就表明某个漏洞遭到了中间人攻击。</p></li><li><p>运行并更新防病毒软件：除了此外，也请考虑使用诸如Malwarebytes Premium之类的其他安全工具。</p></li></ul><h2 id="简述什么是-XSS-攻击以及-CSRF-攻击？"><a href="#简述什么是-XSS-攻击以及-CSRF-攻击？" class="headerlink" title="简述什么是 XSS 攻击以及 CSRF 攻击？"></a>简述什么是 XSS 攻击以及 CSRF 攻击？</h2><p><strong>XSS</strong>，即 Cross Site Script，中译是跨站脚本攻击；是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。</p><p>XSS攻击可以分为3类：反射型（非持久型）、存储型（持久型）、基于DOM。</p><p><strong>CSRF</strong>，即 Cross Site Request Forgery，中译是跨站请求伪造，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。</p><p>通常情况下，CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。</p><h2 id="如何防止传输内容被篡改？"><a href="#如何防止传输内容被篡改？" class="headerlink" title="如何防止传输内容被篡改？"></a>如何防止传输内容被篡改？</h2><h3 id="1-设置客户端IP黑-白名单"><a href="#1-设置客户端IP黑-白名单" class="headerlink" title="1.设置客户端IP黑/白名单"></a>1.设置客户端IP黑/白名单</h3><p>1.1.客户端所有请求，请求到代理服务器(nginx)，代理服务器维护黑/白名单的ip，决定是否转发请求。</p><p>1.2.项目创建一个filter，拦截所有请求，在filter的方法中，通过request信息匹配ip黑/白名单，和url的拦截规则，决定是否合法。</p><p>优点：简单粗暴。</p><p>缺点：需要客户端的IP固定。</p><p>应用场景：并发量小的场景。比如系统的后台管理服务，客服需要人工审批和通过涉及到钱财的业务，就可以使用这种简单粗暴的方式，防止账号泄露，接口泄露等等。</p><h3 id="2-请求参数Sign签名"><a href="#2-请求参数Sign签名" class="headerlink" title="2.请求参数Sign签名"></a>2.请求参数Sign签名</h3><p>2.1前端发起http请求，对参数排序，然后使用 参数与私钥拼接，在进行md5加密 等方式，生成一个签名出来，一起发给服务端，服务端这边获取到参数，签名，再使用自己的私钥进行同样方式的加密生成签名，比对签名是否一致。一致则认为合法，不一致则不合法。<strong>但是无法防止重复请求攻击！</strong></p><p>2.2针对上面方法升级，可以缓存每次请求的md5值，或者给每个请求添加uuid+随机数这样一个代表请求序号的标识。然后请求到服务端时，服务端想办法缓存起来起来这个标识，每次请求过来时，判断是否已经请求过。<strong>但是缓存怎么实现，如何维护？而且并发量高的话，每个请求过来都先查缓存，是否影响性能。</strong></p><p>2.3在请求的参数中和签名结果里，加入时间戳这个参数，业务服务器一方面比较签名结果，一方面根据时间戳，来认证请求的合法性，比如允许请求的时间戳与服务器当前时间，存在20秒的误差等自定义规则。超过20秒的合法请求，服务器也不处理，防止恶意的重复请求。</p><p>2.4时间戳+md51 时间差120s以上代表重复请求，md5写缓存，缓存时长120s（大于等于上面的值就行），判断如果有md5代表重复请求。</p><h3 id="3-请求方式换成Https"><a href="#3-请求方式换成Https" class="headerlink" title="3.请求方式换成Https"></a>3.请求方式换成Https</h3><h2 id="如何设计-API-接口使其实现幂等性？"><a href="#如何设计-API-接口使其实现幂等性？" class="headerlink" title="如何设计 API 接口使其实现幂等性？"></a>如何设计 API 接口使其实现幂等性？</h2><p><strong>所谓幂等，就是任意多次执行所产生的影响均与一次执行的影响相同。</strong></p><p><img src="https://i.loli.net/2021/10/24/Mfs1iRGut2BWYQZ.png" alt="image-20211024160432704"></p><ul><li><p>唯一主键索引实现幂等性</p></li><li><p>乐观锁实现幂等性</p></li><li><p>悲观锁实现幂等性</p></li><li><p>Token 令牌如何实现幂等性</p></li></ul><h2 id="简述-BGP-协议和-OSPF-协议的区别"><a href="#简述-BGP-协议和-OSPF-协议的区别" class="headerlink" title="简述 BGP 协议和 OSPF 协议的区别"></a>简述 BGP 协议和 OSPF 协议的区别</h2><ol><li>类型不同</li></ol><p>OSPF是无类别链路状态路由协议，属于IGP，工作也在一个AS内；</p><p>BGP是无类别路径矢量路由协议，属于EGP，工作在AS间</p><ol start="2"><li>作用不同</li></ol><p>OSPF是用来发现、计算路由的；</p><p>BGP是用来传递、控制路由的</p><h2 id="HTTP-是无状态的吗？需要保持状态的场景应该怎么做？"><a href="#HTTP-是无状态的吗？需要保持状态的场景应该怎么做？" class="headerlink" title="HTTP 是无状态的吗？需要保持状态的场景应该怎么做？"></a>HTTP 是无状态的吗？需要保持状态的场景应该怎么做？</h2><p>HTTP 是一种不保存状态，即无状态（stateless）协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。</p><ol><li><p>基于Session实现的会话保持</p><p>在会话开始时（客户端第一次像服务器发送http请求），服务器将会话状态保存起来（本机内存或数据库中），然后分配一个会话标识（SessionId）给客户端，这个会话标识一般保存在客户端Cookie中，以后每次浏览器发送http请求都会带上Cookie中的SessionId到服务器，服务器拿到会话标识就可以把之前存储在服务器端的状态信息与会话联系起来，实现会话保持（如果遇到浏览器禁用Cookie的情况，则可以通过url重写的方式将会话标识放在url的参数里，也可实现会话保持）.</p></li><li><p>基于Cookie实现的会话保持<br>基于Cookie实现会话保持与上述基于Session实现会话保持的最主要区别是前者完全将会话状态信息存储在浏览器Cookie中，这样一来每次浏览器发送</p></li></ol><h2 id="简述-TCP-协议的延迟-ACK-和累计应答"><a href="#简述-TCP-协议的延迟-ACK-和累计应答" class="headerlink" title="简述 TCP 协议的延迟 ACK 和累计应答"></a>简述 TCP 协议的延迟 ACK 和累计应答</h2><p>在收到数据以后并不立即返回确认应答，延迟一会，等待缓冲区中数据被处理，那么剩余的缓冲区就会大些——这是<strong>延迟应答</strong>。</p><p>那么所有的包都可以延迟应答么? 肯定也不是;</p><ul><li>数量限制: 每隔N个包就应答一次;</li><li>时间限制: 超过最大延迟时间就应答一次; 一般N取2, 超时时间取200ms;</li></ul><p>**捎带应答:**在延迟应答的基础上, 我们发现, 很多情况下, 客户端服务器在应用层也是 “一发一收” 的. 意味着客户端给服务器说了”How are you”, 服务器也会给客户端回一个 “Fine, thank you”;那么这个时候ACK就可以搭顺风车, 和服务器回应的 “Fine, thank you” 一起回给客户端。</p><h2 id="SSL握手流程为什么要使用非对称秘钥？"><a href="#SSL握手流程为什么要使用非对称秘钥？" class="headerlink" title="SSL握手流程为什么要使用非对称秘钥？"></a>SSL握手流程为什么要使用非对称秘钥？</h2><p><img src="https://i.loli.net/2021/10/24/47MHDzUfeZ3dItm.png" alt="image-20211024171449089"></p><h2 id="简述-WebSocket-是如何进行传输的"><a href="#简述-WebSocket-是如何进行传输的" class="headerlink" title="简述 WebSocket 是如何进行传输的"></a>简述 WebSocket 是如何进行传输的</h2><ul><li><p>浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，</p></li><li><p>连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。</p></li><li><p>当你获取 Web Socket 连接后，你可以通过 send() 方法来向服务器发送数据，</p></li><li><p>并通过 onmessage 事件来接收服务器返回的数据。</p></li></ul><h2 id="traceroute-有什么作用？"><a href="#traceroute-有什么作用？" class="headerlink" title="traceroute 有什么作用？"></a>traceroute 有什么作用？</h2><p>traceroute是诊断网络问题时常用的工具。</p><p>可以通过traceroute进行初步的检测，定位网络包在是在哪个节点丢失的，之后才可以进行针对性的处理。</p><h2 id="如何解决-TCP-传输丢包问题？"><a href="#如何解决-TCP-传输丢包问题？" class="headerlink" title="如何解决 TCP 传输丢包问题？"></a>如何解决 TCP 传输丢包问题？</h2><ol><li><p>数据分片：发送端对数据进行分片，接受端要对数据进行重组，由TCP确定分片的大小并控制分片和重组</p></li><li><p>到达确认：接收端接收到分片数据时，根据分片数据序号向发送端发送一个确认</p></li><li><p>超时重发：发送方在发送分片时设置超时定时器，如果在定时器超时之后没有收到相应的确认，重发分片数据</p></li><li><p>滑动窗口：TCP连接的每一方的接受缓冲空间大小固定，接收端只允许另一端发送接收端缓冲区所能接纳的数据，TCP在滑动窗口的基础上提供流量控制，防止较快主机致使较慢主机的缓冲区溢出</p></li><li><p>失序处理：作为IP数据报来传输的TCP分片到达时可能会失序，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层;</p></li><li><p>重复处理：作为IP数据报来传输的TCP分片会发生重复，TCP的接收端必须丢弃重复的数据;</p></li><li><p>数据校验：TCP将保持它首部和数据的检验和，这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到分片的检验或有差错，TCP将丢弃这个分片，并不确认收到此报文段导致对端超时并重发</p></li></ol><p>题目答案均为转载，题目先后顺序按各大厂总出题次数排列！</p>]]></content>
      
      
      <categories>
          
          <category> 面试技巧 </category>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议(二)</title>
      <link href="/2021/10/21/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE(%E4%BA%8C)/"/>
      <url>/2021/10/21/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="网络协议-二"><a href="#网络协议-二" class="headerlink" title="网络协议(二)"></a>网络协议(二)</h1><h2 id="DNS-查询服务器的基本流程是什么？DNS-劫持是什么？"><a href="#DNS-查询服务器的基本流程是什么？DNS-劫持是什么？" class="headerlink" title="DNS 查询服务器的基本流程是什么？DNS 劫持是什么？"></a>DNS 查询服务器的基本流程是什么？DNS 劫持是什么？</h2><p>DNS（Domain Names System），域名系统，是互联网一项服务，是进行域名和与之相对应的 IP 地址进行转换的服务器</p><p><img src="https://i.loli.net/2021/10/18/rfNsjWglJD7uFyI.png" alt="image-20211018173310316"></p><p>DNS 查询的方式有两种：</p><ul><li>递归查询：如果 A 请求 B，那么 B 作为请求的接收者一定要给 A 想要的答案</li></ul><p><img src="https://i.loli.net/2021/10/18/CiKrWdfMXzqeNBk.png" alt="image-20211018173402644"></p><ul><li>迭代查询：如果接收者 B 没有请求者 A 所需要的准确内容，接收者 B 将告诉请求者 A，如何去获得这个内容，但是自己并不去发出请求</li></ul><p><img src="https://i.loli.net/2021/10/18/uB7Jc1H9Qy6rVE4.png" alt="image-20211018173424792"></p><h3 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h3><p>解析域名的过程如下：</p><ul><li><p>首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表</p></li><li><p>若没有命中，则继续搜索操作系统的 DNS 缓存</p></li><li><p>若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果</p></li><li><p>若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询</p></li><li><p>首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器</p><ul><li>本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址</li><li>本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址</li><li>本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来</li></ul></li><li><p>操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起</p></li><li><p>至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起</p></li></ul><h3 id="什么是DNS劫持"><a href="#什么是DNS劫持" class="headerlink" title="什么是DNS劫持?"></a>什么是DNS劫持?</h3><p>DNS劫持又称域名劫持，是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能反应或访问的是假网址。</p><h3 id="预防DNS劫持"><a href="#预防DNS劫持" class="headerlink" title="预防DNS劫持?"></a>预防DNS劫持?</h3><p>修改默认的路由器登陆账号与密码</p><h2 id="Cookie-和-Session-的关系和区别是什么？"><a href="#Cookie-和-Session-的关系和区别是什么？" class="headerlink" title="Cookie 和 Session 的关系和区别是什么？"></a>Cookie 和 Session 的关系和区别是什么？</h2><p>(1)cookie数据存放在客户的浏览器上，session数据放在服务器上<br>(2)cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,如果主要考虑到安全应当使用session<br>(3)session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用COOKIE<br>(4)单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能3K。<br>(5)所以：将登陆信息等重要信息存放为SESSION;其他信息如果需要保留，可以放在COOKIE中</p><h2 id="简述-HTTPS-的加密与认证过程"><a href="#简述-HTTPS-的加密与认证过程" class="headerlink" title="简述 HTTPS 的加密与认证过程"></a>简述 HTTPS 的加密与认证过程</h2><h3 id="https加密过程"><a href="#https加密过程" class="headerlink" title="https加密过程"></a>https加密过程</h3><p><img src="https://i.loli.net/2021/10/18/4nuAhs5byHQapPL.png" alt="image-20211018185523161"></p><h3 id="服务端证书通过CA机构签名认证的过程如下"><a href="#服务端证书通过CA机构签名认证的过程如下" class="headerlink" title="服务端证书通过CA机构签名认证的过程如下"></a>服务端证书通过CA机构签名认证的过程如下</h3><p><img src="https://i.loli.net/2021/10/18/gozbp1Knc7fUra5.png" alt="image-20211018185655146"></p><h2 id="RestFul-是什么？RestFul-请求的-URL-有什么特点？"><a href="#RestFul-是什么？RestFul-请求的-URL-有什么特点？" class="headerlink" title="RestFul 是什么？RestFul 请求的 URL 有什么特点？"></a>RestFul 是什么？RestFul 请求的 URL 有什么特点？</h2><p>REST（Resource Representational State Transfer【表现层状态转化】）。如果一个架构符合REST原则，就称为RESTful架构，是一种<strong>面向资源的软件架构风格</strong></p><p>REST最大的几个特点为：资源、统一接口、URI和无状态。</p><p>资源：网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。资源总要通过某种载体反应其内容，文本可以用txt格式表现，也可以用HTML格式、XML格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现；JSON是现在最常用的资源表示格式。</p><blockquote><p>网络上的实体！</p></blockquote><p>统一接口：数据的元操作，即CRUD(create, read, update和delete,即数据的增删查改)操作，分别对应于HTTP方法：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源，这样就统一了数据操作的接口，仅通过HTTP方法，就可以完成对数据的所有增删查改工作。</p><blockquote><p>通过HTTP方法来确定并完成对实体的操作！</p></blockquote><p>URI：可以用一个URI（Universal Resource Identifier，统一资源定位符）指向资源，即每个URI都对应一个特定的资源。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或识别符。一般的，每个资源至少有一个URI与之对应，最典型的URI即URL。</p><blockquote><p>通过URI来识别不同的资源（实体）！</p></blockquote><p>无状态：所有的资源，都可以通过URI定位，而且这个定位与其他资源无关，也不会因为其他资源的变化而改变。<br>WebSocket是有状态的</p><blockquote><p>通过URI对资源（实体）操作时，无状态，没有上下文的影响！</p></blockquote><p>Resultful特点：<br>1.使用URL描述资源<br>2.使用HTTP方法描述行为。使用HTTP状态码来表示不同的结果<br>3.使用json交互数据，传统模式使用的是键值对形式<br>4.RESTful只是一种风格，并不是强制的标准。</p><h2 id="RestFul-与-RPC-的区别是什么？RestFul-的优点在哪里？"><a href="#RestFul-与-RPC-的区别是什么？RestFul-的优点在哪里？" class="headerlink" title="RestFul 与 RPC 的区别是什么？RestFul 的优点在哪里？"></a>RestFul 与 RPC 的区别是什么？RestFul 的优点在哪里？</h2><h3 id="RESTFUL-与RPC的区别"><a href="#RESTFUL-与RPC的区别" class="headerlink" title="RESTFUL 与RPC的区别"></a>RESTFUL 与RPC的区别</h3><p>1.restfull和rpc都是client/server模式的，都是在 Server端 把一个个函数封装成接口暴露出去</p><p>2.restful使用http协议实现，而rpc则不一定使用http，一般比较常用的是tcp， RPC 可以获得更好的性能（省去了 HTTP 报头等一系列东西）,TCP更加高效，而HTTP在实际应用中更加的灵活。</p><p>3.从使用上来说：Http接口只关注服务提供方（服务端），对于客户端怎么调用，调用方式怎样并不关心；而RPC服务则需要客户端接口与服务端保持一致，服务端提供一个方法，客户端通过接口直接发起调用。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><h4 id="RPC的优势："><a href="#RPC的优势：" class="headerlink" title="RPC的优势："></a>RPC的优势：</h4><ol><li>是查找的精确性，快速性，短路径，和确定性，因为属于内网查询，独立的注册中心，所以查找的速度更快。</li><li>而且由于做了精简和优化，删去了RESTful方式里面很多多余的信息，比如Header，而且做了压缩和序列化，通过二进制方式传输，传输的内容更少，传输的速度也更快。</li><li>环节和流程更少，因为RESTful需要经过路由，负载均衡，网关，防火墙和一系列的身份识别和校验，就像大楼内来了个不认识的人，楼管大叔肯定要查你的身份证等等信息核实你的信息。 而且RPC就省去了这些环节，就像你天天出来进去，楼管大妈早就对你很熟了，不需要每次核实你的信息，RPC省去了很多环节。</li></ol><h4 id="RESTful的优势："><a href="#RESTful的优势：" class="headerlink" title="RESTful的优势："></a>RESTful的优势：</h4><ol><li>通用性更好，RESTful可以供任何接入互联网的终端调用，各种平台，各种终端都可以用RESTful传输和交换数据，而且有一套标准和规范的传输格式，所以格式更加标准化和通用化。</li><li>安全性更高，因为属于连接外围和内网的通道，所以会经过一些列的安全和身份校验。</li><li>移植性更好，从一个服务器迁移到另一个服务器，从一个节点迁移到另一个节点，从一个架构移植到另一种架构，都可以轻松完成。</li></ol><ul><li><p>RPC的应用场景：当你的框架和语言种类也比较多，内部之间调用量非常大的时候，RPC是最佳的选择。RPC更多是内网之间的数据传输，一般是部署在服务层的分布式系统里面，或者微服务系统。有服务治理，服务限流、服务降级、服务熔断、服务监控等等，类似于大楼里面配了治安处，物业处、后勤处、监控中心等。</p></li><li><p>RESTful的应用场景：数据更多是公网上的传输，比如服务端API供 IOS、Android、PC等客户端调用， API供第三方合作方调用等 。</p></li></ul><h2 id="TCP-挥手时出现大量-CLOSE-WAIT-或-TIME-WAIT-怎么解决？"><a href="#TCP-挥手时出现大量-CLOSE-WAIT-或-TIME-WAIT-怎么解决？" class="headerlink" title="TCP 挥手时出现大量 CLOSE_WAIT 或 TIME_WAIT 怎么解决？"></a>TCP 挥手时出现大量 CLOSE_WAIT 或 TIME_WAIT 怎么解决？</h2><h3 id="TIME-WAIT状态"><a href="#TIME-WAIT状态" class="headerlink" title="TIME_WAIT状态"></a>TIME_WAIT状态</h3><p>主动断开方处于TIME_WAIT状态时，源端口无法使用<br> 端口最大数是65535，因此如果频繁主动断开TCP连接，将很快耗尽端口号。一旦达到了上限，则新的请求就无法被处理，接着就是大量Too Many Open Files异常，然后tomcat、nginx、apache崩溃<br>如何解决TIME_WAIT问题</p><h4 id="解决TIME-WAIT大量出现"><a href="#解决TIME-WAIT大量出现" class="headerlink" title="解决TIME_WAIT大量出现"></a>解决TIME_WAIT大量出现</h4><p>最核心的思想，就是打开系统的TIME_WAIT<strong>重用和快速回收</strong></p><p>net.ipv4.tcp_tw_recycle = 1表示开启TCP连接中TIME_WAIT sockets的快速回收，默认为0,表示关闭<br>net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME_WAIT sockets重新用于新的TCP连接，默认为0，表示关闭</p><h3 id="CLOSE-WAIT状态"><a href="#CLOSE-WAIT状态" class="headerlink" title="CLOSE_WAIT状态"></a>CLOSE_WAIT状态</h3><p>如果出现了CLOSE_WAIT<strong>过多</strong>的状态</p><p>1.在对方关闭连接后，自身程序里没有检测 -（被动方的角度）</p><p>2.本身忘了需要关闭连接，于是整个资源就一直被程序占用着。-（主动方的角度）</p><h4 id="如何解决CLOSE-WAIT问题"><a href="#如何解决CLOSE-WAIT问题" class="headerlink" title="如何解决CLOSE_WAIT问题"></a>如何解决CLOSE_WAIT问题</h4><p>关闭正在运行的程序<br>尽快修改程序bug,然后测试提交到线上服务器</p><h2 id="什么是跨域，什么情况下会发生跨域请求？"><a href="#什么是跨域，什么情况下会发生跨域请求？" class="headerlink" title="什么是跨域，什么情况下会发生跨域请求？"></a>什么是跨域，什么情况下会发生跨域请求？</h2><p>跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器施加的安全限制。</p><p>同源策略：所谓同源是指：协议，域名，端口均相同。即便两个不同的域名指向同一个ip地址，也非同源。</p><blockquote><p><a href="http://www.123.com/index.html%E8%B0%83%E7%94%A8">http://www.123.com/index.html调用</a> <a href="http://www.123.com/server.php">http://www.123.com/server.php</a> （非跨域）<br><a href="http://www.123.com/index.html">http://www.123.com/index.html</a> 调用 <a href="http://www.456.com/server.php">http://www.456.com/server.php</a> （主域名不同:123/456，跨域）<br><a href="http://abc.123.com/index.html">http://abc.123.com/index.html</a> 调用 <a href="http://def.123.com/server.php">http://def.123.com/server.php</a> （子域名不同:abc/def，跨域）<br><a href="http://www.123.com:8080/index.html">http://www.123.com:8080/index.html</a> 调用 <a href="http://www.123.com:8081/server.php">http://www.123.com:8081/server.php</a> （端口不同:8080/8081，跨域）<br><a href="http://www.123.com/index.html">http://www.123.com/index.html</a> 调用 <a href="https://www.123.com/server.php">https://www.123.com/server.php</a> （协议不同:http/https，跨域）<br>请注意：localhost和127.0.0.1虽然都指向本机，但也属于跨域。</p></blockquote><h2 id="简述对称与非对称加密的概念"><a href="#简述对称与非对称加密的概念" class="headerlink" title="简述对称与非对称加密的概念"></a>简述对称与非对称加密的概念</h2><p><strong>对称加密</strong>是最快速、最简单的一种加密方式，加密（encryption）与解密（decryption）用的是同样的密钥（secret key)</p><blockquote><p>常见的对称加密有DES、三 重DES、AES等</p></blockquote><p>非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥（public key）和私钥（private key)</p><ul><li>只能私钥加密公钥解密,或者公钥加密私钥解密;</li><li>一方保留密钥,一方公开密钥;不能同时公开,具体公开哪方需要根据实际情况来决定</li></ul><blockquote><p>非对称加密算法常见有:RSA算法(3个人名简写)和diffie - hellman算法(迪菲·赫尔曼算法)</p></blockquote><h2 id="HTTP-中-GET-和-POST-区别"><a href="#HTTP-中-GET-和-POST-区别" class="headerlink" title="HTTP 中 GET 和 POST 区别"></a>HTTP 中 GET 和 POST 区别</h2><p>1、GET 方法：从指定的资源请求数据。</p><p>请注意，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：</p><p>例如：<a href="https://www.xxxx.com/xxx.asp">https://www.xxxx.com/xxx.asp</a>? name1=value1&amp;name2=value2  </p><p>而需要注意的是：GET方法是可见的，而POST方法是在HTTP消息主体中发出的，具有不可见性。下面是一些GET的注释：</p><ul><li><p>请求可被缓存。</p></li><li><p>请求保留在浏览器历史记录中。</p></li><li><p>请求可被收藏为书签。</p></li><li><p>请求不应在处理敏感数据时使用</p></li><li><p>请求有长度限制</p></li><li><p>请求只应当用于取回数据</p></li><li><p>GET—&gt;application/x-www-form-urlencoded 。</p></li><li><p>GET—-&gt;只允许 ASCII 字符。</p></li></ul><p>2、POST 方法：向指定的资源提交要被处理的数据</p><p>  请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：</p><p>GET方法是可见的，而POST方法是在HTTP消息主体中发出的，具有不可见性。下面是一些 POST的注释：</p><ul><li><p>请求不会被缓存</p></li><li><p>请求不会保留在浏览器历史记录中</p></li><li><p>不能被收藏为书签</p></li><li><p>请求对数据长度没有要求</p></li><li><p>POST—&gt;application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 </p></li><li><p>POST—&gt; 没有限制。也允许二进制数据。</p></li></ul><h2 id="TCP-的-keepalive-了解吗？说一说它和-HTTP-的-keepalive-的区别？"><a href="#TCP-的-keepalive-了解吗？说一说它和-HTTP-的-keepalive-的区别？" class="headerlink" title="TCP 的 keepalive 了解吗？说一说它和 HTTP 的 keepalive 的区别？"></a>TCP 的 keepalive 了解吗？说一说它和 HTTP 的 keepalive 的区别？</h2><h3 id="TCP-Keepalive"><a href="#TCP-Keepalive" class="headerlink" title="TCP Keepalive"></a>TCP Keepalive</h3><p>链接建立之后，如果应用程序或者上层协议一直不发送数据，或者隔很长时间才发送一次数据，当链接很久没有数据报文传输时如何去确定对方还在线，到底是掉线了还是确实没有数据传输，链接还需不需要保持，这种情况在TCP协议设计中是需要考虑到的。</p><p>TCP协议通过一种巧妙的方式去解决这个问题，当超过一段时间之后，TCP自动发送一个数据为空的报文给对方，如果对方回应了这个报文，说明对方还在线，链接可以继续保持，如果对方没有报文返回，并且重试了多次之后则认为链接丢失，没有必要保持链接。</p><h3 id="TCP-Keepalive-HTTP-Keep-Alive-的关系"><a href="#TCP-Keepalive-HTTP-Keep-Alive-的关系" class="headerlink" title="TCP Keepalive HTTP Keep-Alive 的关系"></a>TCP Keepalive HTTP Keep-Alive 的关系</h3><p><strong>HTTP协议的Keep-Alive意图在于TCP连接复用，同一个连接上串行方式传递请求-响应数据；TCP的Keepalive机制意图在于探测连接的对端是否存活。</strong></p><p><img src="https://i.loli.net/2021/10/21/c8iT39hYKEu5JI4.png" alt="image-20211021104327114"></p><h2 id="简述常见的-HTTP-状态码的含义（301，304，401，403）"><a href="#简述常见的-HTTP-状态码的含义（301，304，401，403）" class="headerlink" title="简述常见的 HTTP 状态码的含义（301，304，401，403）"></a>简述常见的 HTTP 状态码的含义（301，304，401，403）</h2><p>200 OK ：服务器成功返回用户请求的数据。</p><p>201 CREATED ：用户新建或修改数据成功。</p><p>202 Accepted： 请求已被接受，但尚未处理。</p><p>301 Moved Permanently： 永久重定向。</p><p>304 Not Modified： 请求资源与本地缓存相同，未修改。</p><p>307/302 Temporary Redirect：临时重定向。不会从POST变成GET。</p><p>400 INVALID REQUEST ：用户发出的请求有错误。</p><p>401 Unauthorized ：用户没有权限。</p><p>403 Forbidden ：访问被禁止。</p><p>404 NOT FOUND ：请求针对的是不存在的记录。</p><p>406 Not Acceptable ：用户请求的的格式不正确。</p><p>500 INTERNAL SERVER ERROR ：服务器发生错误。</p><p>503 Service Unavailable：服务器暂时处于超负荷或正在进行停机维护，现在无法处理请求。</p><h2 id="简述-TCP-的-TIME-WAIT-和-CLOSE-WAIT"><a href="#简述-TCP-的-TIME-WAIT-和-CLOSE-WAIT" class="headerlink" title="简述 TCP 的 TIME_WAIT 和 CLOSE_WAIT"></a>简述 TCP 的 TIME_WAIT 和 CLOSE_WAIT</h2><p><strong>TIME_WAIT-主动关闭</strong></p><ul><li>TIME_WAIT 是主动关闭链接时形成的，等待2MSL时间，约4分钟。主要是防止最后一个ACK丢失。  由于TIME_WAIT 的时间会非常长，因此server端应尽量减少主动关闭连接</li></ul><p><strong>CLOSE_WAIT-被动关闭</strong></p><ul><li>CLOSE_WAIT是被动关闭连接是形成的。根据TCP状态机，服务器端收到客户端发送的FIN，则按照TCP实现发送ACK，因此进入CLOSE_WAIT状态。但如果服务器端不执行close()，就不能由CLOSE_WAIT迁移到LAST_ACK，则系统中会存在很多CLOSE_WAIT状态的连接。此时，可能是系统忙于处理读、写操作，而未将已收到FIN的连接，进行close。此时，recv/read已收到FIN的连接socket，会返回0。</li></ul><h2 id="简述-TCP-滑动窗口以及重传机制"><a href="#简述-TCP-滑动窗口以及重传机制" class="headerlink" title="简述 TCP 滑动窗口以及重传机制"></a>简述 TCP 滑动窗口以及重传机制</h2><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p><p>通常窗口的大小是由接收方的决定的。</p><p>发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。不是完全相等，接收窗口的大小是<strong>约等于</strong>发送窗口的大小的</p><h3 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h3><p><img src="https://i.loli.net/2021/10/21/L9vi6aKeN1mHX8k.png" alt="image-20211021164258042"></p><p>当某一段报文丢失了，图中（1001 - 2000）数据段丢失了，接受方没有接收到该数据段，则会一直的给发送方发送ACK（下一个是1001），如果发送端主机连续收到同样一个（下一个1001），就会将对应的数据（1001 - 2000）重新发送。<br>这时候如果接收端收到1001之后，再次返回的就是ACK（8001）了。之前的（2001 - 8000）都接收到了接受缓存区。<br>这种机制被称为“高速重发机制”（快速重传）</p><h2 id="简述-DDOS-攻击原理，如何防范它？"><a href="#简述-DDOS-攻击原理，如何防范它？" class="headerlink" title="简述 DDOS 攻击原理，如何防范它？"></a>简述 DDOS 攻击原理，如何防范它？</h2><p>整个过程可分为：</p><ol><li>扫描大量主机以寻找可入侵主机目标；</li><li>有安全漏洞的主机并获取控制权；</li><li>入侵主机中安装攻击程序；</li><li>用己入侵主机继续进行扫描和入侵。</li></ol><h4 id="DDoS攻击防御方法"><a href="#DDoS攻击防御方法" class="headerlink" title="DDoS攻击防御方法"></a><strong>DDoS攻击防御方法</strong></h4><p><strong>1. 过滤不必要的服务和端口：</strong>可以使用Inexpress、Express、Forwarding等工具来过滤不必要的服务和端口，即在路由器上过滤假IP。比如Cisco公司的CEF(Cisco Express Forwarding)可以针对封包Source IP和Routing Table做比较，并加以过滤。只开放服务端口成为目前很多服务器的流行做法，例如WWW服务器那么只开放80而将其他所有端口关闭或在防火墙上做阻止策略。</p><p><strong>2. 异常流量的清洗过滤：</strong>通过DDOS硬件防火墙对异常流量的清洗过滤，通过数据包的规则过滤、数据流指纹检测过滤、及数据包内容定制过滤等顶尖技术能准确判断外来访问流量是否正常，进一步将异常流量禁止过滤。单台负载每秒可防御800-927万个syn攻击包。</p><p><strong>3. 分布式集群防御：</strong>这是目前网络安全界防御大规模DDOS攻击的最有效办法。分布式集群防御的特点是在每个节点服务器配置多个IP地址（负载均衡），并且每个节点能承受不低于10G的DDOS攻击，如一个节点受攻击无法提供服务，系统将会根据优先级设置自动切换另一个节点，并将攻击者的数据包全部返回发送点，使攻击源成为瘫痪状态，从更为深度的安全防护角度去影响企业的安全执行决策。</p><p><strong>4. 高防智能DNS解析：</strong>高智能DNS解析系统与DDOS防御系统的完美结合，为企业提供对抗新兴安全威胁的超级检测功能。它颠覆了传统一个域名对应一个镜像的做法，智能根据用户的上网路线将DNS解析请求解析到用户所属网络的服务器。同时智能DNS解析系统还有宕机检测功能，随时可将瘫痪的服务器IP智能更换成正常服务器IP，为企业的网络保持一个永不宕机的服务状态。</p><p><strong>5.带宽资源要充足：</strong>带宽直接决定了抗DDOS攻击的能力，至少要选择100M带宽的，越多越好。</p><p><strong>6.服务器的硬件配置：</strong>在带宽以及流量有充分保障的前提下，服务器的硬件配置必须得跟上。当然，主要的因素还是CPU和内存</p><p><strong>7.搭建CDN：</strong>将内容缓存在终端用户附近</p><h2 id="简述-OSI-七层模型，TCP，IP-属于哪一层？"><a href="#简述-OSI-七层模型，TCP，IP-属于哪一层？" class="headerlink" title="简述 OSI 七层模型，TCP，IP 属于哪一层？"></a>简述 OSI 七层模型，TCP，IP 属于哪一层？</h2><p><strong>TCP，IP 属于传输层</strong></p><table><thead><tr><th>OSI七层模型</th><th>TCP/IP模型</th><th>功能</th><th>TCP/IP协议族</th></tr></thead><tbody><tr><td>应用层</td><td>应用层</td><td>直接向用户提供服务，完成用户希望完成的各种网络操作</td><td>HTTP，FTP，TFTP，DNS，Telnet，SMTP</td></tr><tr><td>表示层</td><td>进行数据编解码，数据加解密和格式转换</td><td>没有协议</td><td></td></tr><tr><td>会话层</td><td>解除或建立与别的节点的联系，组织和协调两个会话进程之间的通信，并对数据交换进行管理</td><td>没有协议</td><td></td></tr><tr><td>传输层</td><td>传输层</td><td>向两台主机中进程之间的通信提供通用的数据传输服务，实现端到端连接</td><td>TCP，UDP</td></tr><tr><td>网络层</td><td>网络层</td><td>为分组交换网上的不同主机提供通信服务，也就是进行IP选址和路由选择</td><td>IP，ICMP，RIP，IGMP</td></tr><tr><td>数据链路层</td><td>数据链路层</td><td>在物理层提供的比特流基础上，通过差错控制、流量控制的方法，将由差错的物理线路变为无差错的、能可靠传输数据帧的数据链路</td><td>SLIP，CSLIP，PPP，ARP，RARP，</td></tr><tr><td>物理层</td><td>物理层</td><td>利用传输介质为数据链路层提供物理连接，实现相邻计算机节点之间比特流的透明传输</td><td>IEEE802.1 A，IEEE802.2到IEEE802.11</td></tr></tbody></table><p>题目答案均为转载，题目先后顺序按各大厂总出题次数排列！</p>]]></content>
      
      
      <categories>
          
          <category> 面试技巧 </category>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议(一)</title>
      <link href="/2021/10/18/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE(%E4%B8%80)/"/>
      <url>/2021/10/18/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="网络协议-一"><a href="#网络协议-一" class="headerlink" title="网络协议(一)"></a>网络协议(一)</h1><h2 id="简述-TCP-三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？"><a href="#简述-TCP-三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？" class="headerlink" title="简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？"></a>简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？</h2><p><img src="https://i.loli.net/2021/10/18/GDsdkzVbKlrFgpZ.png" alt="image-20211018110043768"></p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ul><li><p>第一次握手</p><p>客户端给服务器发送一个SYN段(在 TCP 标头中 SYN 位字段为 1 的 TCP/IP 数据包), 该段中也包含客户端的初始序列号(Sequence number (Seq)= J)。</p><blockquote><p>SYN是同步的缩写，SYN 段是发送到另一台计算机的 TCP 数据包，请求在它们之间建立连接</p></blockquote><p>SYN = j , Seq = k</p></li><li><p>第二次握手<br>服务器返回客户端 SYN +ACK 段(在 TCP 标头中SYN和ACK位字段都为 1 的 TCP/IP 数据包)， 该段中包含服务器的初始序列号(Sequence number(Seq) = K)；同时使 Acknowledgment number = J + 1来表示确认已收到客户端的 SYN段(Sequence number = J)。</p><blockquote><p>ACK 是“确认”的缩写。 ACK 数据包是任何确认收到一条消息或一系列数据包的 TCP 数据包</p></blockquote><p>SYN  = j, Seq =y, ACK= k+1</p></li><li><p>第三次握手<br>客户端给服务器响应一个ACK段(在 TCP 标头中 ACK 位字段为 1 的 TCP/IP 数据包), 该段中使 Acknowledgment number = K + 1来表示确认已收到服务器的 SYN段(Sequence number(Seq) = K)。</p><p>ACK= y+1</p></li></ul><h3 id="为什么三次？"><a href="#为什么三次？" class="headerlink" title="为什么三次？"></a>为什么三次？</h3><ol><li><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p></li><li><p>换个易于理解的视角来看为什么要 3 次握手。</p><p>客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。</p></li></ol><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="https://i.loli.net/2021/10/18/R5pbFzeuPY3NWhZ.png" alt="image-20211018111059274"></p><ul><li>客户端发送一个 FIN 段，并包含一个希望接收者看到的自己当前的序列号 K. 同时还包含一个 ACK 表示确认对方最近一次发过来的数据。</li><li>服务端将 K 值加 1 作为 ACK 序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。</li><li>服务端发起自己的 FIN 段，ACK=K+1, Seq=L。</li><li>客户端确认。进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。ACK=L+1。</li></ul><h3 id="为什么关闭连接却是四次挥手"><a href="#为什么关闭连接却是四次挥手" class="headerlink" title="为什么关闭连接却是四次挥手?"></a>为什么关闭连接却是四次挥手?</h3><ol><li><p>TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令<strong>告知对方，我要关闭连接</strong>了。</p></li><li><p><strong>这时对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，也就是说，服务端收到客户端的 FIN 标志，知道客户端想要断开这次连接了，但是，我服务端，我还想发数据呢？我等到发送完了所有的数据后，会发送一个 FIN 段来关闭此方向上的连接。接收方发送 ACK确认关闭连接。</strong></p><p>注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解“上层的意志”。</p></li><li><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是<strong>为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</strong></p></li><li><p>因为服务端在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。而<strong>关闭连接时，当收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据</strong>，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方 ACK 和 FIN 一般都会分开发。</p></li></ol><h2 id="HTTP-与-HTTPS-有哪些区别？"><a href="#HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="HTTP 与 HTTPS 有哪些区别？"></a>HTTP 与 HTTPS 有哪些区别？</h2><p>1、HTTPS  协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(以前的网易官网是http，而网易邮箱是 https 。)</p><p>2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。</p><p>3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>4、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)</p><p>注意：</p><p>(1) 采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问。这套证书其实就是一对公钥和私钥。</p><p>(2) 互联网有太多的服务需要使用证书来验证身份，以至于客户端（操作系统或浏览器等）无法内置所有证书，需要通过服务端将证书发送给客户端。</p><p>(3) 客户端内置的是 CA 的根证书(Root Certificate)，HTTPS 协议中服务器会发送证书链（Certificate Chain）给客户端。</p><p><strong>数据传输的机密性</strong>:包含自己支持的非对成加密的密钥交换算法 ( 一般是<a href="https://baike.baidu.com/item/RSA/210678">RSA</a>)，数据签名摘要算法 ( 一般是<a href="https://baike.baidu.com/item/SHA/9533316">SHA</a>或者<a href="https://baike.baidu.com/item/MD5/212708">MD5</a>) ，加密传输数据的对称加密算法 ( 一般是<a href="https://baike.baidu.com/item/DES/210508">DES</a>)，以及加密密钥的长度。<br>非对称加密公钥和私钥的使用方法：(1) 公钥加密私钥解密。(2) 私钥做数字签名，公钥验证。</p><h2 id="从输入-URL-到展现页面的全过程"><a href="#从输入-URL-到展现页面的全过程" class="headerlink" title="从输入 URL 到展现页面的全过程"></a>从输入 URL 到展现页面的全过程</h2><ol><li><p>输入url地址</p></li><li><p>应用层进行DNS解析</p></li><li><p>应用层生成HTTP请求报文</p></li><li><p>传输层建立TCP连接</p></li><li><p>网络层使用IP协议来选择路线</p></li><li><p>数据链路层实现网络相邻节点间可靠的数据通信</p></li><li><p>物理层传输数据</p></li><li><p>服务器处理反向传输</p></li><li><p>服务器返回一个 HTTP 响应</p></li><li><p>浏览器渲染</p></li></ol><h2 id="TCP-与-UDP-在网络协议中的哪一层，他们之间有什么区别？"><a href="#TCP-与-UDP-在网络协议中的哪一层，他们之间有什么区别？" class="headerlink" title="TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？"></a>TCP 与 UDP 在网络协议中的哪一层，他们之间有什么区别？</h2><p>TCP与UDP都在<span style='color:red'>传输层</span></p><p><strong>用户数据报协议 UDP（User Datagram Protocol）</strong></p><p>是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</p><p><strong>传输控制协议 TCP（Transmission Control Protocol）</strong></p><p>是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</p><h2 id="TCP-怎么保证可靠传输？"><a href="#TCP-怎么保证可靠传输？" class="headerlink" title="TCP 怎么保证可靠传输？"></a>TCP 怎么保证可靠传输？</h2><p>TCP主要提供了检验和、序列号/确认应答、超时重传、最大消息长度、滑动窗口控制等方法实现了可靠性传输。</p><ul><li><strong>校验和：</strong></li></ul><p>发送的数据包的二进制相加然后取反，<strong>目的是检测数据在传输过程中的任何变化</strong>。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。 </p><ul><li><strong>确认应答+序列号（累计确认+seq）：</strong></li></ul><p>接收方收到报文就会确认（累积确认：对所有按序接收的数据的确认）</p><p>TCP给发送的<strong>每一个包进行编号</strong>，接收方<strong>对数据包进行排序</strong>，把有序数据传送给应用层。 </p><ul><li><strong>超时重传：</strong></li></ul><p>当TCP<strong>发出一个段后，它启动一个定时器</strong>，<strong>等待目的端确认收到这个报文段</strong>。<strong>如果不能及时收到一个确认，将重发这个报文段</strong>。 </p><ul><li><strong>流量控制：</strong></li></ul><p><strong>TCP连接的每一方都有固定大小的缓冲空间</strong>，TCP的<strong>接收端只允许发送端发送接收端缓冲区能接纳的数据</strong>。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。</p><p><strong>接收方有即时窗口（滑动窗口），随ACK报文发送</strong></p><ul><li><strong>拥塞控制：</strong></li></ul><p>当网络拥塞时，减少数据的发送。</p><p><strong>发送方有拥塞窗口，发送数据前比对接收方发过来的即使窗口，取小</strong></p><h2 id="简述-HTTP-1-0，1-1，2-0-的主要区别"><a href="#简述-HTTP-1-0，1-1，2-0-的主要区别" class="headerlink" title="简述 HTTP 1.0，1.1，2.0 的主要区别"></a>简述 HTTP 1.0，1.1，2.0 的主要区别</h2><p>HTTP1.0与HTTP 1.1的主要区别</p><ol><li>长连接</li><li>节约带宽</li><li>HOST域</li></ol><ul><li><p><strong>缓存处理：</strong>在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</p></li><li><p><strong>带宽优化及网络连接的使用：</strong>HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p></li><li><p><strong>错误通知的管理：</strong>在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p></li><li><p><strong>Host头处理：</strong>在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p></li><li><p><strong>长连接：</strong>HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p><h2 id="HTTP-1-x与HTTP-2区别"><a href="#HTTP-1-x与HTTP-2区别" class="headerlink" title="HTTP / 1.x与HTTP / 2区别"></a>HTTP / 1.x与HTTP / 2区别</h2></li></ul><p>HTTP1.1与HTTP 2.0的主要区别</p><ol><li>多路复用</li><li>二进制分帧</li><li>首部压缩</li><li>服务器推送</li></ol><ul><li><p><strong>服务端推送：</strong>它引入了服务器推送的概念，其中服务器预计客户端将需要的资源，并在客户端发出请求之前将其推送。客户端保留拒绝服务器推送的权限；但是，在大多数情况下，此功能可大大提高流程效率。</p></li><li><p><strong>多路复用</strong>：该概念交错了请求和响应，而没有行头阻塞，并且通过单个TCP连接来完成。</p></li><li><p><strong>新的二进制格式：</strong>它是一种二进制协议，即仅以0和1形式的二进制命令通过网络传输。二进制成帧层将消息划分为多个帧，这些帧根据其类型（数据或报头）进行分离。此功能在安全性，压缩和多路复用方面大大提高了效率。</p></li><li><p><strong>header压缩：</strong>HTTP / 2使用HPACK标头压缩算法，该算法可抵御像CRIME这样的攻击，并利用静态霍夫曼编码。</p></li></ul><h2 id="TCP-中常见的拥塞控制算法有哪些？"><a href="#TCP-中常见的拥塞控制算法有哪些？" class="headerlink" title="TCP 中常见的拥塞控制算法有哪些？"></a>TCP 中常见的拥塞控制算法有哪些？</h2><p>拥塞控制主要是四个算法：1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复。</p><p><img src="https://i.loli.net/2021/10/18/aY8qfFDEJAoVSMm.png" alt="image-20211018121313295"></p><h3 id="1-慢启动算法-Slow-Start"><a href="#1-慢启动算法-Slow-Start" class="headerlink" title="1.慢启动算法 - Slow Start"></a>1.慢启动算法 - Slow Start</h3><p>在 TCP 连接刚建立时，一点一点提速，先试探网络的状况，避免扰乱了网络通道的秩序。<br>慢启动是指一开始向网络注入的报文段少，并不是指拥塞窗口 cwnd 增长速度慢。</p><ul><li><strong>慢启动算法：</strong></li></ul><ol><li><p>连接建好的开始先初始化拥塞窗口的 cwnd 大小为 1，表明可以传送一个 MSS 大小的数据。</p></li><li><p>每当收到一个 ACK，cwnd 大小加 1，呈线性上升。</p></li><li><p>每当过了一个往返延迟时间 RTT(Round-Trip TIme),cwnd 大小直接翻倍，乘以 2，呈指数上升。</p></li><li><p>还有一个 ssthresh(slow start threshold)，是一个上限(阈值)，当 cwnd &gt;= ssthresh 时就会进入“拥塞避免算法”。</p><p><img src="https://i.loli.net/2021/10/18/pVGdt38BfCUkh57.png" alt="image-20211018121346465"></p></li></ol><h3 id="2-拥塞避免算法-Congestion-Avoidance"><a href="#2-拥塞避免算法-Congestion-Avoidance" class="headerlink" title="2. 拥塞避免算法- Congestion Avoidance"></a>2. 拥塞避免算法- Congestion Avoidance</h3><p>当窗口大小 cwnd &gt;= 慢启动的阈值后，就会进入拥塞避免算法。<br>拥塞避免 不能完全避免拥塞，而是指在拥塞避免阶段将拥塞窗口控制为线性增长，避免窗口增长过快导致窗口拥塞。缓慢的增加调整到最佳状态，使网络比较不容易出现拥塞。</p><ul><li><strong>拥塞避免算法：</strong></li></ul><ol><li>收到一个 ACK，则 cwnd = cwnd + 1/cwnd</li><li>每当经过了一个往返延迟时间 RTT，cwnd 大小加 1。</li></ol><h3 id="3-拥塞状态时的算法"><a href="#3-拥塞状态时的算法" class="headerlink" title="3.拥塞状态时的算法"></a>3.拥塞状态时的算法</h3><p>TCP 拥塞控制默认认为网络丢包是由于网络拥塞导致的，所以一般的 TCP 拥塞控制算法以丢包为网络进入拥塞状态的信号。对于丢包有两种判断方式，<strong>一种是超时重传 RTO(Retransmission Timeout)超时，另一个是收到三个重复确认 ACK</strong>。</p><ul><li><strong>超时重传 RTO(Retransmission Timeout)超时，TCP 会重传数据包。TCP 认为这种情况比较糟糕，反应也比较激烈：</strong></li></ul><ol><li>由于发生丢包，将慢启动阈值(ssthresh)设置为当前 cwnd 的一半，即 ssthresh = cwnd / 2</li><li>cwnd 重置为 1</li><li>进入慢启动过程</li></ol><p>早期的 TCP Tahoe 算法就是使用上述处理方法，由于一丢包就一切重来，导致 cwnd 又重置为 1，十分不利于网络数据的稳定传递。<br>所以，TCP Reno 算法进行了优化。当收到三个重复确认 ACK 时，TCP 开启快速重传 Fast Retransmit 算法，而不用等到 RTO 超时再进行重传</p><ul><li><strong>三个重复确认 ACK：</strong></li></ul><ol><li>cwnd 大小缩减为当前的一半。</li><li>ssthresh 设置为缩小后的 cwnd 大小</li><li>进入快速恢复算法 Fast Recovery。</li></ol><p><img src="https://i.loli.net/2021/10/18/3IQ96BPRySJpXzv.png" alt="image-20211018121405441"></p><h3 id="4-快速恢复算法-Fast-Recovery"><a href="#4-快速恢复算法-Fast-Recovery" class="headerlink" title="4.快速恢复算法 - Fast Recovery"></a>4.快速恢复算法 - Fast Recovery</h3><p>TCP Tahoe 是早期的算法，所以没有快速恢复算法，而 Reno 算法有。在进入快速恢复之前，cwnd 和 ssthresh 已经被改为原有的 cwnd 的一半。</p><ol><li>cwnd = cwnd + 3 MSS，加 3 MSS 的原因是收到 3 个重复的 ACK。</li><li>重传 DACKs 指定数据包。</li><li>如果再收到 DACKs，那么 cwnd 大小增加 1。</li><li>如果收到新的 ACK，表明重传的包成功了，退出快速恢复算法。将 cwnd 设置为 ssthresh，然后进入拥塞避免算法。</li></ol><h2 id="什么是-TCP-粘包和拆包？"><a href="#什么是-TCP-粘包和拆包？" class="headerlink" title="什么是 TCP 粘包和拆包？"></a>什么是 TCP 粘包和拆包？</h2><p>假设 Client 向 Server 连续发送了两个数据包，用 packet1 和 packet2 来表示，那么服务端收到的数据可以分为三种情况，现列举如下：</p><p>第一种情况，接收端正常收到两个数据包，即没有发生拆包和粘包的现象。</p><p><img src="https://i.loli.net/2021/10/18/zoRirExaU2FysJM.png" alt="image-20211018112224687"></p><p>第二种情况，接收端只收到一个数据包，但是这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。</p><p><img src="https://i.loli.net/2021/10/18/H6k3laKcndSpg58.png" alt="image-20211018112231807"></p><p>第三种情况，这种情况有两种表现形式，如下图。接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。</p><p><img src="https://i.loli.net/2021/10/18/aXHKL9B3hVo5vts.png" alt="image-20211018112240880"></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h2 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h2><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><h2 id="计网七层模型"><a href="#计网七层模型" class="headerlink" title="计网七层模型"></a>计网七层模型</h2><table><thead><tr><th>OSI七层模型</th><th>TCP/IP模型</th><th>功能</th><th>TCP/IP协议族</th></tr></thead><tbody><tr><td>应用层</td><td>应用层</td><td>直接向用户提供服务，完成用户希望完成的各种网络操作</td><td>HTTP，FTP，TFTP，DNS，Telnet，SMTP</td></tr><tr><td>表示层</td><td>进行数据编解码，数据加解密和格式转换</td><td>没有协议</td><td></td></tr><tr><td>会话层</td><td>解除或建立与别的节点的联系，组织和协调两个会话进程之间的通信，并对数据交换进行管理</td><td>没有协议</td><td></td></tr><tr><td>传输层</td><td>传输层</td><td>向两台主机中进程之间的通信提供通用的数据传输服务，实现端到端连接</td><td>TCP，UDP</td></tr><tr><td>网络层</td><td>网络层</td><td>为分组交换网上的不同主机提供通信服务，也就是进行IP选址和路由选择</td><td>IP，ICMP，RIP，IGMP</td></tr><tr><td>数据链路层</td><td>数据链路层</td><td>在物理层提供的比特流基础上，通过差错控制、流量控制的方法，将由差错的物理线路变为无差错的、能可靠传输数据帧的数据链路</td><td>SLIP，CSLIP，PPP，ARP，RARP，</td></tr><tr><td>物理层</td><td>物理层</td><td>利用传输介质为数据链路层提供物理连接，实现相邻计算机节点之间比特流的透明传输</td><td>IEEE802.1 A，IEEE802.2到IEEE802.11</td></tr></tbody></table><h2 id="UDP-、TCP-首部格式"><a href="#UDP-、TCP-首部格式" class="headerlink" title="UDP 、TCP 首部格式"></a>UDP 、TCP 首部格式</h2><h3 id="TCP协议首部格式"><a href="#TCP协议首部格式" class="headerlink" title="TCP协议首部格式"></a>TCP协议首部格式</h3><p><img src="https://i.loli.net/2021/10/18/2oIwAzLHYu4x7XQ.png" alt="image-20211018103946071"></p><p>TCP 首部格式比 UDP 复杂。</p><p><strong>序号：</strong>用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p><p><strong>确认号：</strong>期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p><p><strong>数据偏移：</strong>指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p><p><strong>控制位：</strong>八位从左到右分别是 CWR，ECE，URG，ACK，PSH，RST，SYN，FIN。</p><p><strong>CWR：</strong>CWR 标志与后面的 ECE 标志都用于 IP 首部的 ECN 字段，ECE 标志为 1 时，则通知对方已将拥塞窗口缩小；</p><p><strong>ECE：</strong>若其值为 1 则会通知对方，从对方到这边的网络有阻塞。在收到数据包的 IP 首部中 ECN 为 1 时将 TCP 首部中的 ECE 设为 1；</p><p><strong>URG：</strong>该位设为 1，表示包中有需要紧急处理的数据，对于需要紧急处理的数据，与后面的紧急指针有关；</p><p><strong>ACK：</strong>该位设为 1，确认应答的字段有效，TCP规定除了最初建立连接时的 SYN 包之外该位必须设为 1；</p><p><strong>PSH：</strong>该位设为 1，表示需要将收到的数据立刻传给上层应用协议，若设为 0，则先将数据进行缓存；</p><p><strong>RST：</strong>该位设为 1，表示 TCP 连接出现异常必须强制断开连接；</p><p><strong>SYN：</strong>用于建立连接，该位设为 1，表示希望建立连接，并在其序列号的字段进行序列号初值设定；</p><p><strong>FIN：</strong>该位设为 1，表示今后不再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位置为 1 的 TCP 段。</p><p>每个主机又对对方的 FIN 包进行确认应答之后可以断开连接。不过，主机收到 FIN 设置为 1 的 TCP 段之后不必马上回复一个 FIN 包，而是可以等到缓冲区中的所有数据都因为已成功发送而被自动删除之后再发 FIN 包；</p><p><strong>窗口：</strong>窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p><h3 id="UDP协议首部格式"><a href="#UDP协议首部格式" class="headerlink" title="UDP协议首部格式"></a>UDP协议首部格式</h3><p><img src="https://i.loli.net/2021/10/18/8bTXnoSEcUJ91Vm.png" alt="image-20211018104116091"></p><p>UDP首部有8个字节，由4个字段构成，每个字段都是两个字节，<br>1.源端口号： 可有可无，需要对方回信时选用，不需要时全部置0。<br>2.目的端口号：必须有，在终点交付报文的时候需要用到。<br>3.长度：UDP的数据报的长度（包括首部和数据）其最小值为8字节（只有首部）。<br>4.校验和：检测UDP数据报在传输中是否有错，有错则丢弃。<br>该字段是可选的，当源主机不想计算校验和，则直接令该字段全为0。<br>当传输层从IP层收到UDP数据报时，就根据首部中的目的端口，把UDP数据报通过相应的端口，上交给应用进程。<br>如果接收方UDP发现收到的报文中的目的端口号不正确（不存在对应端口号的应用进程0,），就丢弃该报文，并由ICMP发送“端口不可达”差错报文给对方。</p><h2 id="为什么常说-TCP-有粘包和拆包的问题而不说-UDP-？"><a href="#为什么常说-TCP-有粘包和拆包的问题而不说-UDP-？" class="headerlink" title="为什么常说 TCP 有粘包和拆包的问题而不说 UDP ？"></a>为什么常说 TCP 有粘包和拆包的问题而不说 UDP ？</h2><p>UDP 是基于报文发送的，UDP首部采用了 16bit 来指示 UDP 数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。</p><p>而 TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 并没有把这些数据块区分边界，仅仅是一连串没有结构的字节流；另外从 TCP 的帧结构也可以看出，在 TCP 的首部没有表示数据长度的字段，基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。</p><h2 id="为什么会发生-TCP-粘包、拆包？"><a href="#为什么会发生-TCP-粘包、拆包？" class="headerlink" title="为什么会发生 TCP 粘包、拆包？"></a>为什么会发生 TCP 粘包、拆包？</h2><ul><li>要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。</li><li>待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。</li><li>要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。</li><li>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。</li></ul><h2 id="粘包、拆包解决办法"><a href="#粘包、拆包解决办法" class="headerlink" title="粘包、拆包解决办法"></a>粘包、拆包解决办法</h2><p>由于 TCP 本身是面向字节流的，无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，归纳如下：</p><ul><li><strong>消息定长：</strong>发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</li><li><strong>设置消息边界：</strong>服务端从网络流中按消息边界分离出消息内容。在包尾增加回车换行符进行分割，例如 FTP 协议。</li><li><strong>将消息分为消息头和消息体：</strong>消息头中包含表示消息总长度（或者消息体长度）的字段。</li><li>更复杂的应用层协议比如 Netty 中实现的一些协议都对粘包、拆包做了很好的处理。</li></ul><h2 id="TCP-滑动窗口"><a href="#TCP-滑动窗口" class="headerlink" title="TCP 滑动窗口"></a>TCP 滑动窗口</h2><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p><p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p><p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p><p><img src="https://i.loli.net/2021/10/18/8gMoY4xip93WjtD.png" alt="image-20211018121614865"></p><p>题目答案均为转载，题目先后顺序按各大厂总出题次数排列！</p>]]></content>
      
      
      <categories>
          
          <category> 面试技巧 </category>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Steam流</title>
      <link href="/2021/10/01/Java-steam%E6%B5%81/"/>
      <url>/2021/10/01/Java-steam%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Java-Steam流"><a href="#Java-Steam流" class="headerlink" title="Java Steam流"></a>Java Steam流</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。</p><p>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。</p><p>首先要澄清的是 java8 中的 Stream 与 I/O 流 InputStream 和 OutputStream 是完全不同的概念。<br>Stream 机制是针对集合迭代器的增强。</p><h2 id="创建对象流的三种方式"><a href="#创建对象流的三种方式" class="headerlink" title="创建对象流的三种方式"></a>创建对象流的三种方式</h2><p>由集合对象创建流。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = list.stream();</span><br></pre></td></tr></table></figure><p>数组创建流。通过静态方法 <strong>Arrays.stream()</strong> 将数组转化为流</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream stream = Arrays.stream(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure><p>通过静态方法 <strong>Stream.of()</strong> ，但是底层其实还是调用 <code>Arrays.stream()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>注意：<br>还有两种比较特殊的流</p><ul><li>空流：<strong>Stream.empty()</strong></li><li>无限流：<strong>Stream.generate()</strong> 和 **Stream.iterate()**。可以配合 <strong>limit()</strong> 使用可以限制一下数量</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接受一个 Supplier 作为参数</span></span><br><span class="line">Stream.generate(Math::random).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">// 初始值是 0，新值是前一个元素值 + 2</span></span><br><span class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="流处理的特性"><a href="#流处理的特性" class="headerlink" title="流处理的特性"></a>流处理的特性</h2><ol><li><p>不存储数据</p></li><li><p>不会改变数据源</p></li><li><p>不可以重复使用</p><p>重复利用会抛出一个 <strong>IllegalStateException</strong> 的异常：</p><p><span style='color:red;'>java.lang.IllegalStateException: stream has already been operated upon or closed</span></p></li></ol><p>源数据流经管道，最后输出结果数据。</p><p><img src="https://i.loli.net/2021/10/01/uB6e9AvspgfDzNi.png" alt="image-20211001142843051"></p><h2 id="操作类型"><a href="#操作类型" class="headerlink" title="操作类型"></a>操作类型</h2><p>Stream 的所有操作连起来组合成了管道，管道有两种操作：<br>第一种，中间操作（intermediate）。调用中间操作方法返回的是一个新的流对象。中间操作不会输出值。<br>第二种，终值操作（terminal）。在调用该方法后，将执行之前所有的中间操作，并返回结果。</p><p><span style='background:yellow;color:red'>通过连续执行多个操作倒便就组成了 Stream 中的执行管道（pipeline）。需要注意的是这些管道被添加后并不会真正执行，只有等到调用终值操作之后才会执行。</span></p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ul><li>forEach：该方法用于对 Stream 中的每个元素进行迭代操作。</li><li>map：该方法用于将每个元素映射到对应的结果上。</li><li>filter：该方法用于过滤满足条件的元素。</li><li>limit(n)：获取前n个元素</li><li>skip(n)：跳过前n元素，配合limit(n)可实现分页</li><li>sorted()：自然排序，流中元素需实现Comparable接口</li><li>sorted(Comparator com)：定制排序，自定义Comparator排序器</li><li>distinct：通过流中元素的 <code>hashCode() 和 equals()</code> 去除重复元素</li><li>peek：逐个执行-中间操作</li><li>forEach()：遍历操作-终值操作</li><li>allMatch全部符合该条件返回true</li><li>noneMatch全部不符合该断言返回true</li><li>anyMatch 任意一个元素符合该断言返回true</li><li>allMatch全部符合该条件返回true</li><li>noneMatch全部不符合该断言返回true</li><li>anyMatch 任意一个元素符合该断言返回true</li><li>findFirst：返回流中第一个元素</li><li>findAny：返回流中的任意元素</li><li>count：返回流中元素的总个数</li><li>max：返回流中元素最大值</li><li>min：返回流中元素最小值</li></ul><ul><li>limit skip distinct sorted 都是有状态操作，这些操作只有拿到前面处理后的所有元素之后才能继续下去。</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><h4 id="Apply实体类"><a href="#Apply实体类" class="headerlink" title="Apply实体类"></a>Apply实体类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer appleId;   <span class="comment">//苹果编号</span></span><br><span class="line">        <span class="keyword">private</span> String appleName;  <span class="comment">//苹果类型</span></span><br><span class="line">        <span class="keyword">private</span> String location;   <span class="comment">//苹果产地</span></span><br><span class="line">        <span class="keyword">private</span> Integer weight;    <span class="comment">//苹果重量</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(Integer appleId, String appleName, String location, Integer weight)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.appleId = appleId;</span><br><span class="line">            <span class="keyword">this</span>.appleName = appleName;</span><br><span class="line">            <span class="keyword">this</span>.location = location;</span><br><span class="line">            <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//get set省略</span></span><br></pre></td></tr></table></figure><h4 id="流实现举例"><a href="#流实现举例" class="headerlink" title="流实现举例"></a>流实现举例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Apple&gt; collect = list.stream().filter(apple -&gt; apple.weight &gt; <span class="number">5</span>).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        System.out.println(collect);</span><br><span class="line">        <span class="comment">//[Apple&#123;appleId=4, appleName=&#x27;红苹果&#x27;, location=&#x27;海南&#x27;, weight=8&#125;, Apple&#123;appleId=5, appleName=&#x27;青苹果&#x27;, location=&#x27;广东&#x27;, weight=10&#125;]</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; names = list.stream().map(apple -&gt; apple.appleName).collect(Collectors.toList());</span><br><span class="line">        System.out.println(names);</span><br><span class="line">        <span class="comment">//[红苹果, 红苹果, 红苹果, 红苹果, 青苹果, 青苹果]</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; distinctName = names.stream().distinct().collect(Collectors.toList());</span><br><span class="line">        System.out.println(distinctName);</span><br><span class="line">        <span class="comment">//[红苹果, 青苹果]</span></span><br><span class="line"></span><br><span class="line">        list.stream().limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">        <span class="comment">//Apple&#123;appleId=1, appleName=&#x27;红苹果&#x27;, location=&#x27;广东&#x27;, weight=5&#125;</span></span><br><span class="line">        <span class="comment">//Apple&#123;appleId=2, appleName=&#x27;红苹果&#x27;, location=&#x27;广东&#x27;, weight=5&#125;</span></span><br><span class="line">        <span class="comment">//Apple&#123;appleId=3, appleName=&#x27;红苹果&#x27;, location=&#x27;海南&#x27;, weight=4&#125;</span></span><br><span class="line"></span><br><span class="line">        list.stream().filter(apple -&gt; apple.getAppleName().equals(<span class="string">&quot;青苹果&quot;</span>))</span><br><span class="line">                .peek(apple -&gt; System.out.println(<span class="string">&quot;苹果筛选1：&quot;</span>+ apple))</span><br><span class="line">                .filter(apple -&gt; apple.getWeight()&gt;<span class="number">5</span>)</span><br><span class="line">                .peek(apple -&gt; System.out.println(<span class="string">&quot;苹果筛选2：&quot;</span>+ apple))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="comment">//苹果筛选1：Apple&#123;appleId=5, appleName=&#x27;青苹果&#x27;, location=&#x27;广东&#x27;, weight=10&#125;</span></span><br><span class="line">        <span class="comment">//苹果筛选2：Apple&#123;appleId=5, appleName=&#x27;青苹果&#x27;, location=&#x27;广东&#x27;, weight=10&#125;</span></span><br><span class="line">        <span class="comment">//苹果筛选1：Apple&#123;appleId=6, appleName=&#x27;青苹果&#x27;, location=&#x27;海南&#x27;, weight=5&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> count = list.parallelStream().filter(apple -&gt; apple.getLocation().equals(<span class="string">&quot;广东&quot;</span>)).count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">        Stream.iterate(<span class="number">0</span>,x-&gt;x+<span class="number">2</span>).limit(<span class="number">10</span>).collect(Collectors.toList()).forEach(System.out::print);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//024681012141618</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">        String merge = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining());</span><br><span class="line">        System.out.println(merge);</span><br><span class="line">        <span class="comment">//Collectors.joining合并  abcbcefgabcdjkl</span></span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">9</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>);</span><br><span class="line">        IntSummaryStatistics stats = numbers.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line">        System.out.println(<span class="string">&quot;列表中最大的数 : &quot;</span> + stats.getMax());</span><br><span class="line">        System.out.println(<span class="string">&quot;列表中最小的数 : &quot;</span> + stats.getMin());</span><br><span class="line">        System.out.println(<span class="string">&quot;所有数之和 : &quot;</span> + stats.getSum());</span><br><span class="line">        System.out.println(<span class="string">&quot;平均数 : &quot;</span> + stats.getAverage());</span><br><span class="line">        <span class="comment">//统计</span></span><br><span class="line"><span class="comment">//        列表中最大的数 : 10</span></span><br><span class="line"><span class="comment">//        列表中最小的数 : 3</span></span><br><span class="line"><span class="comment">//        所有数之和 : 69</span></span><br><span class="line"><span class="comment">//        平均数 : 6.2727272727272725</span></span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stringStream = strings.stream().flatMap(s -&gt; &#123;</span><br><span class="line"><span class="comment">//            将字符串以,分割后得到一个字符串数组</span></span><br><span class="line">            String[] split = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="comment">//            然后将每个字符串数组对应流返回，flatMap会自动把返回的所有流连接成一个流</span></span><br><span class="line">            Stream&lt;String&gt; stream = Arrays.stream(split).filter(x -&gt; !x.isEmpty());</span><br><span class="line">            <span class="keyword">return</span> stream;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(stringStream.collect(Collectors.toList()));</span><br><span class="line">        <span class="comment">//[abc, bc, efg, abcd, jkl]</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>此集合非彼集合-Arrays.asList()</title>
      <link href="/2021/09/24/java.lang.UnsupportedOperationException/"/>
      <url>/2021/09/24/java.lang.UnsupportedOperationException/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="此集合非彼集合-Arrays-asList"><a href="#此集合非彼集合-Arrays-asList" class="headerlink" title="此集合非彼集合-Arrays.asList()"></a>此集合非彼集合-Arrays.asList()</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天使用Arrays.asList();方法和两个数组arr1.removeAll(arr2);查交集</p><p>但出现<span style='color:red;'>java.lang.UnsupportedOperationException</span></p><p>报错代码（例）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] array = &#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>&#125;;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(array);</span><br><span class="line">        list.add(<span class="string">&quot;6&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="问题所在"><a href="#问题所在" class="headerlink" title="问题所在"></a>问题所在</h2><p>查阅资料，发生问题的原因如下：</p><p> <strong>Arrays的asList方法返回的是Arrays的内部类ArrayList，它并不是java.util.ArrayList</strong>，只不过它们的父类都是AbstractList。</p><p>可以看到Arrays的内部类ArrayList并没有重写add和remove方法，所以当我调用Arrays的内部类ArrayList的add方法时实际上是集成父类AbstractList的add方法。<br>AbstractList的add方法抛出java.lang.UnsupportedOperationException异常</p><p>而<strong>java.util.ArrayList的add方法重写了父类的方法，所以不会报错。</strong></p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>重新建一个数组即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] array = &#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>&#125;;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(array);</span><br><span class="line">        List arrList = <span class="keyword">new</span> ArrayList(list);</span><br><span class="line">        arrList.add(<span class="string">&quot;6&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue跨域代理配置 与 浏览器跨域配置</title>
      <link href="/2021/09/05/vue%E8%B7%A8%E5%9F%9F%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE%E4%B8%8E%20%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%A8%E5%9F%9F%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/09/05/vue%E8%B7%A8%E5%9F%9F%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE%E4%B8%8E%20%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%A8%E5%9F%9F%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="vue跨域代理配置与-浏览器跨域配置"><a href="#vue跨域代理配置与-浏览器跨域配置" class="headerlink" title="vue跨域代理配置与 浏览器跨域配置"></a>vue跨域代理配置与 浏览器跨域配置</h1><h2 id="浏览器报错信息如下"><a href="#浏览器报错信息如下" class="headerlink" title="浏览器报错信息如下"></a>浏览器报错信息如下</h2><p><img src="https://i.loli.net/2021/08/31/mxnHs8G9TrkPdNA.png" alt="跨域报错信息"></p><h2 id="方法一（适用于开发）"><a href="#方法一（适用于开发）" class="headerlink" title="方法一（适用于开发）"></a>方法一（适用于开发）</h2><p>vue.config.js 增加 <strong>disableHostCheck: true</strong></p><blockquote><p>disableHostCheck: true</p></blockquote><p>谷歌为例</p><p>创建快捷方式-&gt;右键属性-&gt;在 <strong>目标</strong>位置后面加上  </p><blockquote><p>–disable-web-security –user-data-dir=D:\MyChromeDevUserData </p></blockquote><p>user-data-dir 中 MyChromeDevUserData 是自己创建的文件夹</p><p><img src="https://i.loli.net/2021/08/31/y8KxTSJn6CeqIOv.png" alt="chrome跨域配置"></p><h2 id="方法2（推荐"><a href="#方法2（推荐" class="headerlink" title="方法2（推荐)"></a>方法2（推荐)</h2><p>在vue.config.js中配置代理</p><p>pathRewrite —- 在项目中找到<code>/api</code>(前)开头的URL，并替换为<code>/api</code>(后）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">port</span>: <span class="number">8200</span>, <span class="comment">// 此处修改你想要的端口号</span></span><br><span class="line">        <span class="attr">proxy</span>: &#123;  <span class="comment">//配置跨域</span></span><br><span class="line">            <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">              <span class="attr">target</span>: <span class="string">&#x27;http://xx.xx.xx.xxx:8100/&#x27;</span>,</span><br><span class="line">              <span class="attr">changOrigin</span>: <span class="literal">true</span>,  <span class="comment">//允许跨域</span></span><br><span class="line">              <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;/api&#x27;</span> </span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在配置统一的url js文件中，把<strong>baseURL改成地址前缀（关键）</strong></p><p>重点：<strong>baseURL: “/“</strong></p><p>若把baseURL写成改成vue的启动地址，则在<strong>window的nginix上没问题</strong>。但部署在Linux服务器上会出现找不到axios请求后台地址失败</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> request = axios.create(&#123;</span><br><span class="line">  <span class="comment">// 根据不同的环境设置baseURL，最终发送请求时的URL为: baseURL + 发送请求时写的URL</span></span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">  <span class="attr">withCredentials</span>: <span class="literal">true</span>, <span class="comment">// 允许携带cookie</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">20000</span> <span class="comment">// 请求超时, 20秒</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经过NGINX反向代理，后端服务器获取不了真实IP</title>
      <link href="/2021/09/01/%E7%BB%8F%E8%BF%87NGINX%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%8C%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8E%B7%E5%8F%96%E4%B8%8D%E4%BA%86%E7%9C%9F%E5%AE%9EIP/"/>
      <url>/2021/09/01/%E7%BB%8F%E8%BF%87NGINX%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%8C%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8E%B7%E5%8F%96%E4%B8%8D%E4%BA%86%E7%9C%9F%E5%AE%9EIP/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="经过NGINX反向代理，后端服务器获取不了真实IP"><a href="#经过NGINX反向代理，后端服务器获取不了真实IP" class="headerlink" title="经过NGINX反向代理，后端服务器获取不了真实IP"></a>经过NGINX反向代理，后端服务器获取不了真实IP</h1><p><strong>原因：</strong>通过了Apache，Squid，nginx等反向代理软件就不能获取到客户端的真实IP地址了。经过代理以后，由于在客户端和服务之间增加了中间层，因此服务器无法直接拿到客户端的IP(拿到的是中间层的ip)，服务器端应用也无法直接通过转发请求的地址返回给客户端。但是在转发请求的HTTP头信息中，增加了x-forwarded-for信息。用以跟踪原有的客户端IP地址和原来客户端请求的服务器地址。</p><p><strong>解决</strong>：在NGINX反向代理服务器上进行修改</p><p>在nginx配置文件中</p><p>每一个location上加上以下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxy_set_header Host $http_host;</span><br><span class="line">proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">proxy_set_header X-Forwarded-Proto $scheme;</span><br></pre></td></tr></table></figure><p>重启nginx即可</p><h2 id="springboot获取ip"><a href="#springboot获取ip" class="headerlink" title="springboot获取ip"></a><strong>springboot获取ip</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取登录用户的IP地址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getIp</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (request == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    String ip = request.getHeader(<span class="string">&quot;X-Requested-For&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (Strings.isEmpty(ip) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">        ip = request.getHeader(<span class="string">&quot;X-Forwarded-For&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Strings.isEmpty(ip) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">        ip = request.getHeader(<span class="string">&quot;Proxy-Client-IP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Strings.isEmpty(ip) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">        ip = request.getHeader(<span class="string">&quot;WL-Proxy-Client-IP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Strings.isEmpty(ip) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">        ip = request.getHeader(<span class="string">&quot;HTTP_CLIENT_IP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Strings.isEmpty(ip) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">        ip = request.getHeader(<span class="string">&quot;HTTP_X_FORWARDED_FOR&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Strings.isEmpty(ip) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">        ip = request.getRemoteAddr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;0:0:0:0:0:0:0:1&quot;</span>.equals(ip))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLocalHost</span><span class="params">(String ip)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;127.0.0.1&quot;</span>.equals(ip) || <span class="string">&quot;localhost&quot;</span>.equals(ip);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析ip地址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ipAddress</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getIpSource</span><span class="params">(String ipAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">&quot;http://opendata.baidu.com/api.php?query=&quot;</span> + ipAddress + <span class="string">&quot;&amp;co=&amp;resource_id=6006&amp;oe=utf8&quot;</span>);</span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(url.openConnection().getInputStream(), <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        StringBuffer result = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            result.append(line);</span><br><span class="line">        &#125;</span><br><span class="line">        reader.close();</span><br><span class="line">        Map map = JSON.parseObject(result.toString(), Map.class);</span><br><span class="line">        List&lt;Map&lt;String, String&gt;&gt; data = (List) map.get(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> data.get(<span class="number">0</span>).get(<span class="string">&quot;location&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 后端 </category>
          
          <category> springboot </category>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker部署springboot项目</title>
      <link href="/2021/08/30/docker%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/"/>
      <url>/2021/08/30/docker%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="docker部署springboot项目"><a href="#docker部署springboot项目" class="headerlink" title="docker部署springboot项目"></a>docker部署springboot项目</h1><ol><li><p>编写dockerfile文件和打包maven项目</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java8</span><br><span class="line"><span class="keyword">MAINTAINER</span> chenqitian</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> overseas-study-0.0.1-SNAPSHOT.jar overseas-app.jar</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [java,-jar]</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8100</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [overseas-app.jar]</span></span><br></pre></td></tr></table></figure><p><strong>FROM-</strong>–指定哪个镜像作为新镜像的基础镜像</p><p><strong>MAINTAINER</strong>—-指明该镜像的作者信息</p><p><strong>ADD</strong>—将主机的文件复制到镜像中</p><p><strong>EXPOSE</strong>—暴露镜像的端口供主机做映射</p><p><strong>CMD</strong>—容器启动时需要执行的命令</p><p><img src="https://i.loli.net/2021/08/30/snmpPWb1fzhrTIg.png"></p></li><li><p>上传服务器</p><p>使用xftp，把dockerfile文件和jar包上传到服务器</p></li><li><p>打包成镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t [镜像名]</span><br></pre></td></tr></table></figure><p>docker images查看所安装的镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure></li><li><p>运行构建的镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8100:8100 [镜像名]</span><br></pre></td></tr></table></figure></li><li><p>完成</p><p>浏览器访问  xx.xx.xx.xx:8100即可</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 后端 </category>
          
          <category> springboot </category>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx+docker部署vue-cil项目</title>
      <link href="/2021/08/27/Nginx+docker%E9%83%A8%E7%BD%B2vue-cil%E9%A1%B9%E7%9B%AE/"/>
      <url>/2021/08/27/Nginx+docker%E9%83%A8%E7%BD%B2vue-cil%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Nginx-docker部署vue-cil项目"><a href="#Nginx-docker部署vue-cil项目" class="headerlink" title="Nginx+docker部署vue-cil项目"></a>Nginx+docker部署vue-cil项目</h1><ol><li><p>编写dockerfile文件</p><p><strong>FROM-</strong>–指定哪个镜像作为新镜像的基础镜像</p><p><strong>MAINTAINER</strong>—-指明该镜像的作者信息</p><p><strong>COPY</strong>—将主机的文件复制到镜像内</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">MAINTAINER</span> chenqitian</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> dist/ /usr/share/nginx/html/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> default.conf /etc/nginx/conf.d/default.conf</span></span><br></pre></td></tr></table></figure></li><li><p>打包vue-cil项目</p><p>cmd中输入以下命令，打包生成dist文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure></li><li><p>修改nginx配置文件<code>default.conf </code></p></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       8200;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   /usr/share/nginx/html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">try_files $uri $uri/ @router;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">location @router &#123;</span><br><span class="line">            rewrite ^.*$ /index.html last;</span><br><span class="line">        &#125;</span><br><span class="line">location ^~ /api &#123;</span><br><span class="line">            proxy_pass   http://47.106.128.108:8100;</span><br><span class="line">            add_header Access-Control-Allow-Methods *;</span><br><span class="line">            add_header Access-Control-Max-Age 3600;</span><br><span class="line">            add_header Access-Control-Allow-Credentials true;</span><br><span class="line">            add_header Access-Control-Allow-Origin $http_origin;</span><br><span class="line">            add_header Access-Control-Allow-Headers $http_access_control_request_headers;</span><br><span class="line">            if ($request_method = OPTIONS ) &#123;</span><br><span class="line">                return 200;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>3.上传到服务器</p><p>​    使用xftp，把dockerfile文件和default.conf上传到服务器</p><p>4.打包成镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t [镜像名]</span><br></pre></td></tr></table></figure><p>5.docker images查看所安装的镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>6.运行构建的镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8200:8200 [镜像名]</span><br></pre></td></tr></table></figure><p>7.完成</p><p>​    浏览器访问  xx.xx.xx.xx:8200即可</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">查看docker进程 -a（全部，包括不正常的）</span><br><span class="line">docker ps -a</span><br><span class="line">删除容器</span><br><span class="line">docker rm [容器id]</span><br><span class="line">删除镜像</span><br><span class="line">docker rmi [镜像id]</span><br><span class="line">查看镜像</span><br><span class="line">docker images</span><br><span class="line">进入容器</span><br><span class="line">docker <span class="built_in">exec</span> -it [容器id] /bin/bash</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
          <category> docker </category>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> nginx </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows配置Nginx部署vue-cil项目</title>
      <link href="/2021/08/25/windows+Nginx%E9%83%A8%E7%BD%B2vue-cil%E9%A1%B9%E7%9B%AE/"/>
      <url>/2021/08/25/windows+Nginx%E9%83%A8%E7%BD%B2vue-cil%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Windows配置Nginx部署vue-cil项目"><a href="#Windows配置Nginx部署vue-cil项目" class="headerlink" title="Windows配置Nginx部署vue-cil项目"></a>Windows配置Nginx部署vue-cil项目</h1><ol><li>nginx下载</li></ol><p><a href="https://nginx.org/en/download.html">nginx下载地址</a></p><ol start="2"><li>打包vue-cil项目</li></ol><p>cmd中输入以下命令，打包生成dist文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><ol start="3"><li>.修改nginx配置文件<code>nginx/conf/nginx.conf </code> </li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       8200;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">try_files $uri $uri/ @router;</span><br><span class="line">        &#125;</span><br><span class="line">location @router &#123;</span><br><span class="line">rewrite ^.*$ /index.html last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ^~ /api &#123;</span><br><span class="line">            proxy_pass   http://xx.xx.xxx.xxx:8100;</span><br><span class="line">            add_header Access-Control-Allow-Methods *;</span><br><span class="line">            add_header Access-Control-Max-Age 3600;</span><br><span class="line">            add_header Access-Control-Allow-Credentials true;</span><br><span class="line">            add_header Access-Control-Allow-Origin $http_origin;</span><br><span class="line">            add_header Access-Control-Allow-Headers $http_access_control_request_headers;</span><br><span class="line">            if ($request_method = OPTIONS ) &#123;</span><br><span class="line">                return 200;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li><p>把打包好的dist放入<code>nginx/html</code>文件夹中</p></li><li><p>CMD启动nginx</p></li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start nginx</span><br></pre></td></tr></table></figure><ol start="6"><li>访问localhost:8200成功</li></ol><h2 id="nginx常用命令"><a href="#nginx常用命令" class="headerlink" title="nginx常用命令"></a>nginx常用命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">查看帮助信息</span><br><span class="line">nginx -h</span><br><span class="line"></span><br><span class="line">查看nginx版本(小写字母v)</span><br><span class="line">nginx -v</span><br><span class="line"></span><br><span class="line">除版本信息外还显示配置参数信息(大写字母V)</span><br><span class="line">nginx -V</span><br><span class="line"></span><br><span class="line">启动nginx</span><br><span class="line">start nginx</span><br><span class="line"></span><br><span class="line">指定配置文件启动nginx</span><br><span class="line">start nginx -c filename</span><br><span class="line"></span><br><span class="line">关闭nginx，完整有序的停止nginx，保存相关信息</span><br><span class="line">nginx -s quit</span><br><span class="line"></span><br><span class="line">关闭nginx，快速停止nginx，可能并不保存相关信息</span><br><span class="line">nginx -s stop</span><br><span class="line"></span><br><span class="line">重新载入nginx，当配置信息修改需要重新加载配置是使用</span><br><span class="line">nginx -s reload</span><br><span class="line"></span><br><span class="line">重新打开日志文件</span><br><span class="line">nginx -s reopen</span><br><span class="line"></span><br><span class="line">测试nginx配置文件是否正确</span><br><span class="line">nginx -t -c filename</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swagger3整合oauth2 认证token</title>
      <link href="/2021/08/24/swagger3%E6%95%B4%E5%90%88oauth2%20%E8%AE%A4%E8%AF%81token/"/>
      <url>/2021/08/24/swagger3%E6%95%B4%E5%90%88oauth2%20%E8%AE%A4%E8%AF%81token/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="swagger3整合oauth2-认证token"><a href="#swagger3整合oauth2-认证token" class="headerlink" title="swagger3整合oauth2 认证token"></a>swagger3整合oauth2 认证token</h1><h2 id="引入swagger3依赖"><a href="#引入swagger3依赖" class="headerlink" title="引入swagger3依赖"></a>引入swagger3依赖</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--Swagger3 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.0</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="swagger配置文件编写"><a href="#swagger配置文件编写" class="headerlink" title="swagger配置文件编写"></a>swagger配置文件编写</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">createRestApi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.OAS_30)</span><br><span class="line">                .enable(enable)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .groupName(<span class="string">&quot;xx项目接口&quot;</span>)</span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">//配置要扫描接口的方式</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.os&quot;</span>))</span><br><span class="line">                .build()</span><br><span class="line"></span><br><span class="line">                .securitySchemes(securitySchemes())</span><br><span class="line">                .securityContexts(securityContexts());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证的安全上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;SecurityScheme&gt; <span class="title">securitySchemes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;SecurityScheme&gt; securitySchemes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        securitySchemes.add(<span class="keyword">new</span> ApiKey(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;header&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> securitySchemes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权信息全局应用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;SecurityContext&gt; <span class="title">securityContexts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;SecurityContext&gt; securityContexts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        securityContexts.add(SecurityContext.builder()</span><br><span class="line">                .securityReferences(defaultAuth())</span><br><span class="line">                .forPaths(PathSelectors.any()).build());</span><br><span class="line">        <span class="keyword">return</span> securityContexts;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;SecurityReference&gt; <span class="title">defaultAuth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AuthorizationScope authorizationScope = <span class="keyword">new</span> AuthorizationScope(<span class="string">&quot;global&quot;</span>, <span class="string">&quot;accessEverything&quot;</span>);</span><br><span class="line">        AuthorizationScope[] authorizationScopes = <span class="keyword">new</span> AuthorizationScope[<span class="number">1</span>];</span><br><span class="line">        authorizationScopes[<span class="number">0</span>] = authorizationScope;</span><br><span class="line">        List&lt;SecurityReference&gt; securityReferences = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        securityReferences.add(<span class="keyword">new</span> SecurityReference(<span class="string">&quot;Authorization&quot;</span>, authorizationScopes));</span><br><span class="line">        <span class="keyword">return</span> securityReferences;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>请求头：Authorization</p><h2 id="swagger中的效果展示"><a href="#swagger中的效果展示" class="headerlink" title="swagger中的效果展示"></a>swagger中的效果展示</h2><p><img src="https://i.loli.net/2021/08/22/FQEVo2rBAiHRk1J.png" alt="image-20210630123347451"></p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 后端 </category>
          
          <category> SpringBoot </category>
          
          <category> SpringSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> SpringSecurity </tag>
            
            <tag> 后端 </tag>
            
            <tag> token </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot启动报错（webSecurity匿名问题）</title>
      <link href="/2021/08/22/springboot%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99%EF%BC%88webSecurity%E5%8C%BF%E5%90%8D%E9%97%AE%E9%A2%98%EF%BC%89/"/>
      <url>/2021/08/22/springboot%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99%EF%BC%88webSecurity%E5%8C%BF%E5%90%8D%E9%97%AE%E9%A2%98%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="springboot启动报错（webSecurity匿名问题）"><a href="#springboot启动报错（webSecurity匿名问题）" class="headerlink" title="springboot启动报错（webSecurity匿名问题）"></a>springboot启动报错（webSecurity匿名问题）</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘springSecurityFilterChain’ defined in <span class="class"><span class="keyword">class</span> <span class="title">path</span> <span class="title">resource</span> [<span class="title">org</span>/<span class="title">springframework</span>/<span class="title">security</span>/<span class="title">config</span>/<span class="title">annotation</span>/<span class="title">web</span>/<span class="title">configuration</span>/<span class="title">WebSecurityConfiguration</span>.<span class="title">class</span>]: <span class="title">Bean</span> <span class="title">instantiation</span> <span class="title">via</span> <span class="title">factory</span> <span class="title">method</span> <span class="title">failed</span></span>; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [javax.servlet.Filter]: Factory method ‘springSecurityFilterChain’ threw exception; nested exception is java.lang.IllegalStateException: An incomplete mapping was found <span class="keyword">for</span> []. <span class="function">Try completing it with something like <span class="title">requestUrls</span><span class="params">()</span>..<span class="title">hasRole</span><span class="params">(‘USER’)</span></span></span><br></pre></td></tr></table></figure><h2 id="在WebSecurityConfig-SecurityConfig-中配置"><a href="#在WebSecurityConfig-SecurityConfig-中配置" class="headerlink" title="在WebSecurityConfig(SecurityConfig)中配置"></a>在WebSecurityConfig(SecurityConfig)中配置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">                <span class="comment">//放行swagger</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/swagger-ui.html&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/swagger-ui/*&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/swagger-resources/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/v2/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/v3/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/img.icons/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/webjars/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/doc.html&quot;</span>).permitAll()</span><br><span class="line">    <span class="comment">//只有匿名用户才能访问，其他都要登录</span></span><br><span class="line">                <span class="comment">// 所有加 AnonymousAccess 注解的请求都允许匿名访问</span></span><br><span class="line">                .antMatchers(getAnonymousUrls()).anonymous();</span><br><span class="line">                <span class="comment">//所有请求必须被认证（登录）</span></span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">                </span><br></pre></td></tr></table></figure><p><strong>方法一</strong>: antMatchers(getAnonymousUrls()).anonymous(); 和anyRequest().authenticated(); 同时有</p><p><strong>方法二</strong>: antMatchers(getAnonymousUrls()).anonymous(); 和至少用一个方法上有@AnonymousAccess注解</p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 后端 </category>
          
          <category> SpringBoot </category>
          
          <category> SpringSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> SpringSecurity </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot SpringSecurity 整合knife4j, Swagger3问题</title>
      <link href="/2021/08/20/Springboot%20SpringSecurity%20%E6%95%B4%E5%90%88knife4j,%20Swagger3%E9%97%AE%E9%A2%98/"/>
      <url>/2021/08/20/Springboot%20SpringSecurity%20%E6%95%B4%E5%90%88knife4j,%20Swagger3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Springboot-SpringSecurity-整合knife4j-Swagger3问题"><a href="#Springboot-SpringSecurity-整合knife4j-Swagger3问题" class="headerlink" title="Springboot SpringSecurity 整合knife4j, Swagger3问题"></a>Springboot SpringSecurity 整合knife4j, Swagger3问题</h1><p>版本说明： swagger3版本3.0.0，knife4j版本3.0.2</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--swagger3--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>SpringSecurity放行静态资源</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">                <span class="comment">//放行swagger</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/swagger-ui.html&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/swagger-ui/*&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/swagger-resources/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/v2/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/v3/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/img.icons/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/webjars/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/doc.html&quot;</span>).permitAll()</span><br></pre></td></tr></table></figure><p>Swagger3Config 继承 WebMvcConfigurationSupport 过滤</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.</span><br><span class="line">                addResourceHandler(<span class="string">&quot;/swagger-ui/**&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/webjars/springfox-swagger-ui/&quot;</span>)</span><br><span class="line">                .resourceChain(<span class="keyword">false</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;doc.html&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/webjars/**&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>开启注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableOpenApi</span> <span class="comment">//swagger3</span></span><br><span class="line"><span class="meta">@EnableKnife4j</span> <span class="comment">//knife4j 3.0.2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Swagger3Config</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 后端 </category>
          
          <category> SpringBoot </category>
          
          <category> SpringSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> SpringSecurity </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构建React-app应用时create-react-app卡住超慢的解决办法</title>
      <link href="/2021/08/16/%E6%9E%84%E5%BB%BAReact-app%E5%BA%94%E7%94%A8%E6%97%B6create-react-app%E5%8D%A1%E4%BD%8F%E8%B6%85%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2021/08/16/%E6%9E%84%E5%BB%BAReact-app%E5%BA%94%E7%94%A8%E6%97%B6create-react-app%E5%8D%A1%E4%BD%8F%E8%B6%85%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="构建React-app应用时create-react-app卡住超慢的解决办法"><a href="#构建React-app应用时create-react-app卡住超慢的解决办法" class="headerlink" title="构建React-app应用时create-react-app卡住超慢的解决办法"></a>构建React-app应用时create-react-app卡住超慢的解决办法</h1><h2 id="解决办法：npm换源（淘宝镜像）"><a href="#解决办法：npm换源（淘宝镜像）" class="headerlink" title="解决办法：npm换源（淘宝镜像）"></a>解决办法：npm换源（淘宝镜像）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line">-- 配置后可通过下面方式来验证是否成功</span><br><span class="line">npm config get registry</span><br><span class="line">-- 显示出上述地址的话就是更换成功</span><br></pre></td></tr></table></figure><h2 id="再次尝试构建"><a href="#再次尝试构建" class="headerlink" title="再次尝试构建"></a>再次尝试构建</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">creat-react-app first-react-app（app名称）</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 前端 </category>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>佛山探店 | 有趣好玩switch小店</title>
      <link href="/2021/08/10/%E4%BD%9B%E5%B1%B1%E6%8E%A2%E5%BA%97-BlackPearl/"/>
      <url>/2021/08/10/%E4%BD%9B%E5%B1%B1%E6%8E%A2%E5%BA%97-BlackPearl/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="有趣好玩switch小店🎮"><a href="#有趣好玩switch小店🎮" class="headerlink" title="有趣好玩switch小店🎮"></a>有趣好玩switch小店🎮</h1><p>🏠地点：建新路103号三座首层B号二楼（祖庙铂顿城隔壁-三合凉拌楼上）</p><ul><li>⭐环境很好，干净整洁</li><li>👾游戏也有十几个</li><li>✨店内装饰很游戏风</li><li>✨有很多的小摆设</li><li>💵￥50/2小时</li></ul><p><img src="https://i.loli.net/2021/08/14/86QUfN5An2tSxwj.jpg"></p><p><img src="https://i.loli.net/2021/08/14/A7I4m6gRByUMZaG.jpg"></p><p><img src="https://i.loli.net/2021/08/14/EcAPWbCZvQ4gdxo.jpg"></p><p><img src="https://i.loli.net/2021/08/14/1KaAX6pG9nJjrPo.jpg" alt="game1.jpg"></p><p><img src="https://i.loli.net/2021/08/14/tlr2WHIMS5q8kjc.jpg" alt="game2.jpg"></p><p><img src="https://i.loli.net/2021/08/14/sHJPUw2hIXBlOKz.jpg" alt="game3.jpg"></p><p><img src="https://i.loli.net/2021/08/14/bxBKPv69nJyTErs.jpg"></p><p>一次值得的体验，游戏爱好者推荐来玩哈👍</p>]]></content>
      
      
      <categories>
          
          <category> 探店 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 探店 </tag>
            
            <tag> 日常生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git踩坑 - 1</title>
      <link href="/2021/08/06/git%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/08/06/git%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="git踩坑-1"><a href="#git踩坑-1" class="headerlink" title="git踩坑 - 1"></a>git踩坑 - 1</h1><h4 id="git仓库大文件push失败报413-Request-Entity-Too-Large-问题解决办法"><a href="#git仓库大文件push失败报413-Request-Entity-Too-Large-问题解决办法" class="headerlink" title="git仓库大文件push失败报413 Request Entity Too Large 问题解决办法"></a>git仓库大文件push失败报413 Request Entity Too Large 问题解决办法</h4><p>使用https方式拉取的git仓库，在push文件时报错Gitlab error push files 413 Request Entity Too Large</p><p>尝试了如下</p><ol><li>增大https方式的post缓存   (不成功)</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config http.postBuffer 524288000</span><br></pre></td></tr></table></figure><p>  2.修改本地仓库的https方式为ssh （成功）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote set-url origin ssh地址</span><br></pre></td></tr></table></figure><hr><h4 id="git-pull遇到错误：error-Your-local-changes-to-the-following-files-would-be-overwritten-by-merge"><a href="#git-pull遇到错误：error-Your-local-changes-to-the-following-files-would-be-overwritten-by-merge" class="headerlink" title="git pull遇到错误：error: Your local changes to the following files would be overwritten by merge"></a>git pull遇到错误：error: Your local changes to the following files would be overwritten by merge</h4><p><strong>原因：本地项目有修改，不能更新</strong></p><p><strong>方法1</strong>: 如果你想保留刚才本地修改的代码，并把git服务器上的代码pull到本地（本地刚才修改的代码将会被暂时封存起来）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash </span><br><span class="line"></span><br><span class="line">git pull origin master </span><br><span class="line"></span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>服务器上的代码更新到了本地，而且你本地修改的代码也没有被覆盖，之后使用add，commit，push 命令即可更新本地代码到服务器了。</p><p><strong>方法2</strong>: 如果你想完全地覆盖本地的代码，只保留服务器端代码，则直接回退到上一个版本，再进行pull</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset *--hard* </span><br><span class="line"></span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><p><strong>方法3</strong>:合并代码</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;xxx&quot;</span></span><br><span class="line">git pull</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><hr><h4 id="命令Hexo-d上传GitHub超时报错"><a href="#命令Hexo-d上传GitHub超时报错" class="headerlink" title="命令Hexo d上传GitHub超时报错"></a>命令Hexo d上传GitHub超时报错</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">atal: unable to access <span class="string">&#x27;https://github.com/.......&#x27;</span>: OpenSSL SSL_read: Connection was reset, errno 10054</span><br></pre></td></tr></table></figure><p>产生原因：一般是这是因为服务器的SSL证书没有经过第三方机构的签署，所以报错</p><p>参考网上解决办法：解除ssl验证后  (无效果)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global http.sslVerify &quot;false&quot;</span><br></pre></td></tr></table></figure><p>或出现错误</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fatal: unable to access <span class="string">&#x27;https://github.com/.../.git&#x27;</span>: Could not resolve host: github.com</span><br></pre></td></tr></table></figure><p>参考网上解决办法：解除代理  (无效果)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy </span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure><p>或出现错误</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fatal: unable to access <span class="string">&#x27;https://github.com/Chankeitin/Chankeitin.github.io.git/&#x27;</span>: Failed to connect to github.com port 443: Timed out</span><br></pre></td></tr></table></figure><p>或出现错误</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fatal: unable to access <span class="string">&#x27;https://github.com/Chankeitin/Chankeitin.github.io.git/&#x27;</span>: Empty reply from server</span><br><span class="line">FATAL &#123;</span><br><span class="line">  ......</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Something<span class="string">&#x27;s wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html</span></span><br></pre></td></tr></table></figure><p>最后统一解决：</p><p><strong>重复运行命令，直到push成功</strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Aplayer报错解决方案</title>
      <link href="/2021/08/05/Aplay%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/"/>
      <url>/2021/08/05/Aplay%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>hexo - g 报错如下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">INFO  Start processing</span><br><span class="line">Error: [hexo-tag-aplayer] Meting support is disabled, cannot resolve the meting tags properly.</span><br><span class="line">    at throwError (E:\Node_JS_Hexo\node_modules\hexo-tag-aplayer\common\util.js:18:9)</span><br><span class="line">    at Object.&lt;anonymous&gt; (E:\Node_JS_Hexo\node_modules\hexo-tag-aplayer\index.js:160:28)</span><br><span class="line">    at NunjucksTag._run (E:\Node_JS_Hexo\node_modules\hexo\lib\extend\tag.js:120:18)</span><br><span class="line">    at NunjucksTag.run (E:\Node_JS_Hexo\node_modules\hexo\lib\extend\tag.js:116:15)</span><br><span class="line">    at Template.root [as rootRenderFunc] (eval at _compile (E:\Node_JS_Hexo\node_modules\nunjucks\src\environment.js:617:18), &lt;anonymous&gt;:29:66)</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>请在 Hexo 配置文件 _config.yml 中设置即可： （<strong>切记是hexo的配置文件，不是themes文件夹里面的）</strong></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">aplayer:</span>  </span><br><span class="line"><span class="attr">meting:</span> <span class="literal">true</span> </span><br></pre></td></tr></table></figure><p>请不要配置：（这个是给Meting.js用的，Aplayer误设置会导致变成空白的） </p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Aplayer:</span></span><br><span class="line"><span class="attr">asset_inject:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速搭建Hexo博客</title>
      <link href="/2021/08/04/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2/"/>
      <url>/2021/08/04/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="快速搭建Hexo博客"><a href="#快速搭建Hexo博客" class="headerlink" title="快速搭建Hexo博客"></a>快速搭建Hexo博客</h1><h2 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h2 id="Hexo搭建"><a href="#Hexo搭建" class="headerlink" title="Hexo搭建"></a>Hexo搭建</h2><h3 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h3><p>需要先安装下列应用程序</p><ul><li><p><a href="http://nodejs.org/">Node.js</a></p></li><li><p><a href="http://git-scm.com/">Git</a></p></li><li><p>notepad++(作为编辑器 <strong>可选</strong>)</p></li></ul><h3 id="安装hexo脚手架"><a href="#安装hexo脚手架" class="headerlink" title="安装hexo脚手架"></a>安装hexo脚手架</h3><p>打开cmd，输入下面命令全局安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>用<code>hexo -v</code>查看一下版本，验证是否安装成功</p><p>创建一个文件夹blog，然后<code>cd</code>到这个文件夹下</p><p>输入命令初始化hexo项目</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init</span><br><span class="line">或 hexo init blog(博客名)</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹目录下有：</p><ul><li><p>node_modules: 依赖包</p></li><li><p>public：存放生成的静态页面</p></li><li><p>scaffolds：生成文章的一些模板</p></li><li><p>source：用来存放你的文章</p></li><li><p>themes：主题</p></li><li><p>_config.yml: 博客的配置文件</p></li></ul><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><h3 id="测试运行"><a href="#测试运行" class="headerlink" title="测试运行"></a>测试运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>打开hexo的服务，在浏览器输入localhost:4000就可以看到你默认生成的博客了。</p><p>使用ctrl+c可以把服务关掉。</p><h3 id="GitHub-Gitee创建个人仓库"><a href="#GitHub-Gitee创建个人仓库" class="headerlink" title="GitHub/Gitee创建个人仓库"></a>GitHub/Gitee创建个人仓库</h3><p>首先，你先要有一个GitHub/Gitee账户，去注册一个吧。</p><p>注册完登录后，新建仓库</p><p>创建一个和你用户名相同的仓库，后面加.github.io/gitee.io，只有这样，将来要部署到GitHub page/Gitee page的时候，才会被识别，也就是xxxx.github.io/xxxx.gitee.io，其中xxx就是你注册的用户名。</p><h3 id="将hexo部署到GitHub"><a href="#将hexo部署到GitHub" class="headerlink" title="将hexo部署到GitHub"></a>将hexo部署到GitHub</h3><p>这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 <code>_config.yml</code>，翻到最后，修改为</p><p>username为GitHub用户名</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/username/username.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>安装deploy-git ，也就是部署的命令。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>输入命令进行部署</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>过一会儿就可以在<code>http://username.github.io</code> 这个网站看到你的博客了！！</p><hr><h2 id="主题模板"><a href="#主题模板" class="headerlink" title="主题模板"></a>主题模板</h2><h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><p>在<a href="https://hexo.io/themes/%E5%AE%98%E7%BD%91%E4%B8%AD%E9%A2%84%E8%A7%88%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%BB%E9%A2%98%EF%BC%8C%E5%9C%A8GitHub%E4%B8%AD%E6%90%9C%E7%B4%A2%E4%B8%BB%E9%A2%98%E5%90%8D%EF%BC%8C%E5%B9%B6clone%E5%88%B0%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95%E7%9A%84themes%E6%96%87%E4%BB%B6%E5%A4%B9%E5%86%85%EF%BC%88%E5%8F%82%E8%80%83%E8%B7%AF%E5%BE%84%EF%BC%9Ablog/themes/%EF%BC%89">https://hexo.io/themes/官网中预览喜欢的主题，在GitHub中搜索主题名，并clone到博客目录的themes文件夹内（参考路径：blog/themes/）</a></p><p>以Butterfly主题为例</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/jerryc127/hexo-theme-butterfly</span><br></pre></td></tr></table></figure><p>并在<code>_config.yml</code>中配置该主题,<code>ctrl+f</code>搜索关键字<code>theme</code>,把值修改成butterfly（themes中克隆模板的文件夹名）</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure><p>如果没有 pug 以及 stylus 的渲染器，需要安装</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-renderer-pug</span> <span class="string">hexo-renderer-stylus</span> <span class="string">--save</span></span><br></pre></td></tr></table></figure><p>重新编译启动</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>访问localhost:4000，成功即可</p><hr><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">hexo</span> <span class="string">clean</span> <span class="string">清除了之前生成的东西</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">g</span> <span class="string">编译代码</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">d</span> <span class="string">部署文章</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">n</span> <span class="string">page</span> <span class="string">xx</span> <span class="string">新建页面</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">new</span> <span class="string">xx</span> <span class="string">新建博客文章</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客建设及踩坑</title>
      <link href="/2021/08/04/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE%E5%8F%8A%E8%B8%A9%E5%9D%91/"/>
      <url>/2021/08/04/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E8%AE%BE%E5%8F%8A%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="Hexo建设"><a href="#Hexo建设" class="headerlink" title="Hexo建设"></a>Hexo建设</h3><h4 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h4><h5 id="设置导航栏（主题里的-config-yml）"><a href="#设置导航栏（主题里的-config-yml）" class="headerlink" title="设置导航栏（主题里的_config.yml）"></a>设置导航栏（主题里的<code>_config.yml</code>）</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">   <span class="string">首页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">   <span class="string">归档:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">   <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">   <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">   <span class="string">娱乐||fas</span> <span class="attr">fa-list:</span></span><br><span class="line">     <span class="string">音乐:</span> <span class="string">/music/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-music</span></span><br><span class="line">     <span class="string">电影:</span> <span class="string">/movies/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-video</span></span><br><span class="line">   <span class="string">友链:</span> <span class="string">/link/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line">   <span class="string">关于:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-heart</span></span><br></pre></td></tr></table></figure><h5 id="配置网站样式"><a href="#配置网站样式" class="headerlink" title="配置网站样式"></a>配置网站样式</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Image (圖片設置)</span><br><span class="line"># --------------------------------------</span><br><span class="line"></span><br><span class="line"># Favicon（網站圖標）</span><br><span class="line">favicon: /img/favicon.png</span><br><span class="line"></span><br><span class="line"># Avatar (頭像)</span><br><span class="line">avatar:</span><br><span class="line">  img: /img/avatar.png</span><br><span class="line">  effect: false</span><br><span class="line"></span><br><span class="line"># the banner image of home page</span><br><span class="line">……</span><br></pre></td></tr></table></figure><h5 id="设置主页名句"><a href="#设置主页名句" class="headerlink" title="设置主页名句"></a>设置主页名句</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subtitle:</span><br><span class="line">  enable: true</span><br><span class="line">  # Typewriter Effect (打字效果)</span><br><span class="line">  effect: true</span><br><span class="line">  # loop (循環打字)</span><br><span class="line">  loop: true</span><br><span class="line">  # source調用第三方服務</span><br><span class="line">  # source: false 關閉調用</span><br><span class="line">  # source: 1  調用搏天api的隨機語錄（簡體） https://api.btstu.cn/</span><br><span class="line">  # source: 2  調用一言網的一句話（簡體） https://hitokoto.cn/</span><br><span class="line">  # source: 3  調用一句網（簡體） http://yijuzhan.com/</span><br><span class="line">  # source: 4  調用今日詩詞（簡體） https://www.jinrishici.com/</span><br><span class="line">  # subtitle 會先顯示 source , 再顯示 sub 的內容</span><br><span class="line">  source: true</span><br><span class="line">  # 如果有英文逗號&#x27; , &#x27;,請使用轉義字元 &amp;#44;</span><br><span class="line">  # 如果有英文雙引號&#x27; &quot; &#x27;,請使用轉義字元 &amp;quot;</span><br><span class="line">  # 開頭不允許轉義字元，如需要，請把整個句子用雙引號包住</span><br><span class="line">  # 如果關閉打字效果，subtitle只會顯示sub的第一行文字</span><br><span class="line">  sub: </span><br><span class="line">    - 有德必有勇，正直的人绝不胆怯。</span><br><span class="line">    - 即使慢，驰而不息，纵会落后，纵会失败，但一定可以达到他所向的目标。</span><br></pre></td></tr></table></figure><h5 id="配置社交图标"><a href="#配置社交图标" class="headerlink" title="配置社交图标"></a>配置社交图标</h5><p>在阿里巴巴矢量图标库里面，把需要的图标添加购物车，在新建项目，在购物车中将图标添加到项目中,在主题配置文件中修改：</p><p>把样式添加到页头</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Inject</span><br><span class="line"># Insert the code to head (before &#x27;&lt;/head&gt;&#x27; tag) and the bottom (before &#x27;&lt;/body&gt;&#x27; tag)</span><br><span class="line"># 插入代码到头部 &lt;/head&gt; 之前 和 底部 &lt;/body&gt; 之前</span><br><span class="line">inject:</span><br><span class="line">  head:</span><br><span class="line">   - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/iconfont.css&quot;&gt; #引入阿里巴巴矢量图库</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">social:</span><br><span class="line">  fab fa-github: https://github.com/xxxxx || Github</span><br><span class="line">  iconfont gitee: https://gitee.com/××× ||Gitee</span><br></pre></td></tr></table></figure><h4 id="文章格式"><a href="#文章格式" class="headerlink" title="文章格式"></a>文章格式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:【必需】页面标题</span><br><span class="line">date:【必需】页面创建日期</span><br><span class="line">type: 【必需】标籤、分类和友情链接三个页面需要配置</span><br><span class="line">updated:【可选】页面更新日期</span><br><span class="line">description:【可选】页面描述</span><br><span class="line">keywords: 【可选】页面关键字</span><br><span class="line">comments: 【可选】显示页面评论模块 (默认 true)</span><br><span class="line">top_img: 【可选】页面顶部图片</span><br><span class="line">mathjax: 【可选】显示 mathjax (当设置 mathjax 的 per_page: false 时，才需要配置，默认 false)</span><br><span class="line">katex: 【可选】显示 katex (当设置 katex 的 per_page: false 时，才需要配置，默认 false)</span><br><span class="line">aside: 【可选】显示侧边栏 (默认 true)</span><br><span class="line">aplayer: 【可选】在需要的页面加载 aplayer 的 js 和 css, 请参考文章下面的音乐 配置</span><br><span class="line">highlight_shrink: 【可选】配置代码框是否展开 (true/false)(默认为设置中 highlight_shrink 的配置)</span><br><span class="line">cover:封面图片的url</span><br><span class="line"></span><br><span class="line">copyright: true</span><br><span class="line">copyright_author: xxxx</span><br><span class="line">copyright_author_href: https://github.com/Chankeitin</span><br><span class="line">copyright_url: https://chankeitin.github.io/</span><br><span class="line">copyright_info: 此文章版权归Chankeitin所有，如有转载，请註明来自原作者</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>copyright -&gt; 复制内容携带作者信息</p><p>cover后面输入你想要的封面图片的url</p><p>top_img后面加上你想要的顶部图片的url</p><h4 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h4><p>友情链接的添加需要在完成该操作的基础上，新建<code>source/_data/link.yml</code>文件，添加如下内容</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">class_name:</span> <span class="string">友情链接</span></span><br><span class="line">  <span class="attr">class_desc:</span> <span class="string">那些人，那些事，那些开发者工具</span></span><br><span class="line">  <span class="attr">link_list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Chankeitin</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://chankeitin.github.io</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">https://i.loli.net/2021/08/05/cZd4CF96pgqrQBH.jpg</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">想成为全栈程序猿</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MyBatis-Plus</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://baomidou.com/</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">https://baomidou.com/img/logo.svg</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">为简化开发而生</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Spring</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://spring.io/</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">http://c.biancheng.net/uploads/allimg/210701/1-210F1141343544.png</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">Spring</span> <span class="string">makes</span> <span class="string">Java</span> <span class="string">simple.</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Hexo</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://hexo.io/zh-tw/</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">快速、简单且强大的博客框架</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
